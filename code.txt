=== FILE: include/discord.h ===
#pragma once

/**
 * @file discord.h
 * @brief Main discord.cpp header - includes all public APIs
 * 
 * This header provides a single entry point for all discord.cpp functionality.
 * Individual module headers can be included for finer-grained control.
 */

// Version and configuration
#include "config.h"

// Core module (exceptions, interfaces, main client)
#include "core.h"

// API module (HTTP client, REST endpoints, rate limiting)
#include "api.h"

// Gateway module (WebSocket, real-time events)
#include "gateway.h"

// Events module (event handling and dispatch)
#include "events.h"

// Cache module (caching layer)
#include "cache.h"

// Utilities module (common utilities and helpers)
#include "utils.h"

// Commands module (command handling)
#include "commands.h"

namespace discord {
    /**
     * @brief Get library version
     * @return Version string in format "major.minor.patch"
     */
    inline const char* version() {
        return "1.0.0";
    }
    
    /**
     * @brief Get build information
     * @return Build information string
     */
    inline const char* build_info() {
        return "discord.cpp v1.0.0 - Modern C++ Discord API wrapper";
    }
} // namespace discord

=== END FILE ===

=== FILE: include/discord/config.h ===
#pragma once

// Build configuration and version information
#define DISCORD_CPP_VERSION_MAJOR 1
#define DISCORD_CPP_VERSION_MINOR 0
#define DISCORD_CPP_VERSION_PATCH 0

#define DISCORD_CPP_VERSION \
    ((DISCORD_CPP_VERSION_MAJOR * 10000) + \
     (DISCORD_CPP_VERSION_MINOR * 100) + \
     DISCORD_CPP_VERSION_PATCH)

// Feature flags
#define DISCORD_CPP_ENABLE_CACHE 1
#define DISCORD_CPP_ENABLE_RATE_LIMITER 1
#define DISCORD_CPP_ENABLE_LOGGING 1
#define DISCORD_CPP_ENABLE_THREADING 1

// Platform detection
#if defined(_WIN32)
    #define DISCORD_CPP_PLATFORM_WINDOWS 1
#elif defined(__APPLE__)
    #define DISCORD_CPP_PLATFORM_MACOS 1
#elif defined(__linux__)
    #define DISCORD_CPP_PLATFORM_LINUX 1
#else
    #define DISCORD_CPP_PLATFORM_UNKNOWN 1
#endif

// Compiler detection and feature support
#if __cplusplus >= 202002L
    #define DISCORD_CPP_CXX20 1
#else
    #define DISCORD_CPP_CXX20 0
#endif

=== END FILE ===

=== FILE: include/discord/core.h ===
#pragma once

/**
 * @file core.h
 * @brief Core Discord client and utilities module
 */

#include "config.h"
#include "core/exceptions.h"
#include "core/interfaces.h"
#include "core/client.h"

namespace discord::core {
    // Re-export commonly used types and exceptions
    using discord::ErrorCode;
    using discord::DiscordException;
    using discord::HTTPException;
    using discord::WebSocketException;
    using discord::AuthenticationException;
    using discord::RateLimitException;
    using discord::ValidationException;
} // namespace discord::core

=== END FILE ===

=== FILE: include/discord/core/exceptions.h ===
#pragma once

#include <string>
#include <stdexcept>
#include <nlohmann/json.hpp>

namespace discord {

enum class ErrorCode {
    UNKNOWN_ERROR = 0,
    UNKNOWN_ACCOUNT = 10001,
    UNKNOWN_APPLICATION = 10002,
    UNKNOWN_CHANNEL = 10003,
    UNKNOWN_GUILD = 10004,
    UNKNOWN_INTEGRATION = 10005,
    UNKNOWN_INVITE = 10006,
    UNKNOWN_MEMBER = 10007,
    UNKNOWN_MESSAGE = 10008,
    UNKNOWN_OVERWRITE = 10009,
    UNKNOWN_PROVIDER = 10010,
    UNKNOWN_ROLE = 10011,
    UNKNOWN_TOKEN = 10012,
    UNKNOWN_USER = 10013,
    UNKNOWN_EMOJI = 10014,
    UNKNOWN_WEBHOOK = 10015,
    UNKNOWN_WEBHOOK_SERVICE = 10016,
    UNKNOWN_SESSION = 10020,
    UNKNOWN_BAN = 10026,
    UNKNOWN_SKU = 10027,
    UNKNOWN_STORE_LISTING = 10028,
    UNKNOWN_ENTITLEMENT = 10029,
    UNKNOWN_BUILD = 10030,
    UNKNOWN_LOBBY = 10031,
    UNKNOWN_BRANCH = 10032,
    UNKNOWN_STORE_DIRECTORY_LAYOUT = 10033,
    UNKNOWN_REDISTRIBUTABLE = 10036,
    UNKNOWN_GIFT_CODE = 10038,
    UNKNOWN_STREAM = 10049,
    UNKNOWN_PREMIUM_SERVER_SUBSCRIPTION_COOLDOWN = 10050,
    UNKNOWN_GUILD_TEMPLATE = 10057,
    UNKNOWN_DISCOVERABLE_SERVER_CATEGORY = 10059,
    UNKNOWN_STICKER = 10060,
    UNKNOWN_INTERACTION = 10062,
    UNKNOWN_APPLICATION_COMMAND = 10063,
    UNKNOWN_APPLICATION_COMMAND_PERMISSIONS = 10066,
    UNKNOWN_STAGE_INSTANCE = 10067,
    UNKNOWN_GUILD_MEMBER_VERIFICATION_FORM = 10068,
    UNKNOWN_GUILD_WELCOME_SCREEN = 10069,
    UNKNOWN_GUILD_SCHEDULED_EVENT = 10070,
    UNKNOWN_GUILD_SCHEDULED_EVENT_USER = 10071,
    UNKNOWN_GUILD_ONBOARDING = 10072,
    
    BOTS_NOT_ALLOWED = 20001,
    ONLY_BOTS_ALLOWED = 20002,
    UNAUTHORIZED_HTTP = 20003,
    ACCOUNT_VERIFICATION_REQUIRED_HTTP = 20004,
    DIRECT_MESSAGES_TOO_FAST = 20016,
    REQUEST_ENTITY_TOO_LARGE_HTTP = 20018,
    FEATURE_TEMPORARILY_DISABLED_HTTP = 20022,
    USER_BANNED_HTTP = 20026,
    TARGET_USER_NOT_CONNECTED_TO_VOICE_HTTP = 20028,
    
    MAXIMUM_GUILDS = 30001,
    MAXIMUM_FRIENDS = 30002,
    MAXIMUM_PINS = 30003,
    MAXIMUM_RECIPIENTS = 30004,
    MAXIMUM_ROLES = 30005,
    MAXIMUM_WEBHOOKS = 30007,
    MAXIMUM_EMOJIS = 30008,
    MAXIMUM_REACTIONS = 30010,
    MAXIMUM_CHANNELS = 30013,
    MAXIMUM_ATTACHMENTS = 30015,
    MAXIMUM_INVITES = 30016,
    MAXIMUM_ANIMATED_EMOJIS = 30018,
    MAXIMUM_GUILD_MEMBERS = 30030,
    MAXIMUM_GUILD_ONBOARDING_PROMPTS = 30031,
    
    UNAUTHORIZED = 40001,
    ACCOUNT_VERIFICATION_REQUIRED = 40002,
    OPEN_DIRECT_MESSAGES_ONLY = 40003,
    REQUEST_ENTITY_TOO_LARGE = 40005,
    FEATURE_TEMPORARILY_DISABLED = 40006,
    USER_BANNED = 40007,
    CONNECTION_REVOKED = 40012,
    TARGET_USER_NOT_CONNECTED_TO_VOICE = 40032,
    ALREADY_CROSSPOSTED = 40033,
    MISSING_ACCESS = 50001,
    INVALID_ACCOUNT_TYPE = 50002,
    CANNOT_EXECUTE_ON_DM = 50003,
    EMBED_DISABLED = 50004,
    CANNOT_EDIT_MESSAGE_BY_OTHER = 50005,
    CANNOT_SEND_EMPTY_MESSAGE = 50006,
    CANNOT_MESSAGE_USER = 50007,
    CANNOT_SEND_MESSAGES_IN_NON_TEXT_CHANNEL = 50008,
    CHANNEL_VERIFICATION_LEVEL_TOO_HIGH = 50009,
    OAUTH2_APPLICATION_BOT_ABSENT = 50010,
    MAXIMUM_OAUTH2_APPLICATIONS = 50011,
    INVALID_OAUTH2_STATE = 50012,
    MISSING_PERMISSIONS = 50013,
    INVALID_AUTHENTICATION_TOKEN = 50014,
    NOTE_TOO_LONG = 50015,
    INVALID_BULK_DELETE_QUANTITY = 50016,
    CANNOT_PIN_MESSAGE_IN_OTHER_CHANNEL = 50019,
    INVALID_OR_TAKEN_INVITE_CODE = 50020,
    CANNOT_EXECUTE_ON_SYSTEM_MESSAGE = 50021,
    INVALID_OAUTH2_ACCESS_TOKEN = 50025,
    MISSING_OAUTH2_SCOPE = 50026,
    INVALID_WEBHOOK_TOKEN = 50027,
    INVALID_ROLE = 50028,
    INVALID_RECIPIENTS = 50033,
    INVALID_MESSAGE_TYPE = 50034,
    INVALID_PIN_MESSAGE = 50035,
    INVALID_OR_TAKEN_STICKER = 50036,
    INVALID_STICKER_SENT = 50037,
    INVALID_API_VERSION = 50041,
    FILE_UPLOADED_EXCEEDS_MAXIMUM_SIZE = 50045,
    INVALID_FILE_UPLOADED = 50046,
    INVALID_GUILD = 50055,
    INVALID_MESSAGE_FLAGS = 50068,
    INVALID_ASSET = 50074,
    INVALID_SKU = 50078,
    INVALID_LOBBY = 50081,
    INVALID_LOBBY_TYPE = 50083,
    INVALID_LOCATION_METADATA = 50084,
    INVALID_VOICE_STATE = 50085,
    INVALID_PANEL_BUILDER = 50086,
    INVALID_ONBOARDING = 50091,
    CANNOT_DELETE_COMMUNITY_REQUIRED_CHANNEL = 50094,
    INVALID_STICKER_SENT_V2 = 50095,
    INVALID_COMMAND_TYPE = 50097,
    INVALID_ONBOARDING_PROMPT_TITLE = 50098,
    INVALID_ONBOARDING_PROMPT_OPTIONS = 50099,
    INVALID_ONBOARDING_PROMPT_OPTION_TITLE = 50100,
    INVALID_ONBOARDING_PROMPT_OPTION_DESCRIPTION = 50101,
    INVALID_ONBOARDING_DEFAULT_CHANNEL_IDS = 50102,
    INVALID_ONBOARDING_DEFAULT_CHANNEL_IDS_COUNT = 50103,
    INVALID_ONBOARDING_MODE = 50104,
    INVALID_SORT_ORDER = 50105,
    INVALID_GUILD_ONBOARDING = 50106,
    TOO_MANY_ONBOARDING_PROMPTS = 50107,
    TOO_MANY_ONBOARDING_PROMPT_OPTIONS = 50108,
    INVALID_ONBOARDING_PROMPT_OPTION_EMOJI = 50109,
    INVALID_ONBOARDING_PROMPT_OPTION_EMOJI_NAME = 50110,
    INVALID_ONBOARDING_PROMPT_OPTION_EMOJI_ID = 50111,
    
    RATE_LIMITED = 10001,
    ACCOUNT_VERIFICATION_REQUIRED_GATEWAY = 10002,
    INVALID_API_VERSION_GATEWAY = 10003,
    TEMPORARY_OUTAGE = 10004,
    SERVER_ERROR = 10005,
    INVALID_GATEWAY_INTENTS = 10006,
    INVALID_INTENTS = 10007,
    DISALLOWED_INTENTS = 10008
};

class DiscordException : public std::exception {
public:
    DiscordException(int code, const std::string& message, const nlohmann::json& response = {});
    
    const char* what() const noexcept override;
    int get_code() const;
    const std::string& get_message() const;
    const nlohmann::json& get_response() const;
    
    static DiscordException from_response(const nlohmann::json& response);

private:
    int code_;
    std::string message_;
    nlohmann::json response_;
    std::string full_message_;
};

class RateLimitException : public DiscordException {
public:
    RateLimitException(int retry_after, const std::string& message);
    int get_retry_after() const;

private:
    int retry_after_;
};

class WebSocketException : public DiscordException {
public:
    WebSocketException(int close_code, const std::string& message);
    int get_close_code() const;

private:
    int close_code_;
};

class AuthenticationException : public DiscordException {
public:
    AuthenticationException(const std::string& message);
};

class PermissionException : public DiscordException {
public:
    PermissionException(const std::string& message);
};

class ValidationException : public DiscordException {
public:
    ValidationException(const std::string& message);
};

}
=== END FILE ===

=== FILE: include/discord/core/interfaces.h ===
#pragma once

#include <memory>
#include <string>
#include <vector>
#include <functional>
#include <future>
#include <chrono>
#include <optional>
#include <variant>
#include <nlohmann/json.hpp>

namespace discord {

// Forward declarations
class DiscordClient;
struct User;
struct Guild;
struct Channel;

// Core interfaces for extensibility

class ICache {
public:
    virtual ~ICache() = default;
    virtual void set(const std::string& key, const nlohmann::json& value, std::chrono::seconds ttl = {}) = 0;
    virtual std::optional<nlohmann::json> get(const std::string& key) = 0;
    virtual void remove(const std::string& key) = 0;
    virtual void clear() = 0;
    virtual bool exists(const std::string& key) = 0;
    virtual std::vector<std::string> keys(const std::string& pattern = "*") = 0;
};

class IHttpClient {
public:
    using Headers = std::vector<std::pair<std::string, std::string>>;
    using Params = std::vector<std::pair<std::string, std::string>>;
    
    virtual ~IHttpClient() = default;
    virtual std::future<nlohmann::json> get(const std::string& url, const Headers& headers = {}) = 0;
    virtual std::future<nlohmann::json> post(const std::string& url, const nlohmann::json& data, const Headers& headers = {}) = 0;
    virtual std::future<nlohmann::json> put(const std::string& url, const nlohmann::json& data, const Headers& headers = {}) = 0;
    virtual std::future<nlohmann::json> patch(const std::string& url, const nlohmann::json& data, const Headers& headers = {}) = 0;
    virtual std::future<nlohmann::json> delete_(const std::string& url, const Headers& headers = {}) = 0;
    virtual std::future<void> set_timeout(std::chrono::milliseconds timeout) = 0;
};

class IEventHandler {
public:
    virtual ~IEventHandler() = default;
    virtual void handle(const nlohmann::json& event) = 0;
    virtual std::string getEventType() const = 0;
    virtual int getPriority() const { return 0; }
};

class IRateLimiter {
public:
    virtual ~IRateLimiter() = default;
    virtual std::future<bool> can_request(const std::string& bucket) = 0;
    virtual std::future<void> wait_for_slot(const std::string& bucket) = 0;
    virtual void update_limits(const std::string& bucket, int remaining, int reset_after) = 0;
    virtual void reset() = 0;
};

class IWebSocketClient {
public:
    virtual ~IWebSocketClient() = default;
    virtual std::future<bool> connect(const std::string& url) = 0;
    virtual std::future<void> disconnect() = 0;
    virtual std::future<void> send(const nlohmann::json& message) = 0;
    virtual std::future<void> send_heartbeat() = 0;
    virtual void set_message_handler(std::function<void(const nlohmann::json&)> handler) = 0;
    virtual void set_close_handler(std::function<void(int, const std::string&)> handler) = 0;
    virtual bool is_connected() const = 0;
};

class ILogger {
public:
    enum class Level {
        Trace = 0,
        Debug = 1,
        Info = 2,
        Warning = 3,
        Error = 4,
        Critical = 5
    };
    
    virtual ~ILogger() = default;
    virtual void log(Level level, const std::string& message) = 0;
    virtual void set_level(Level level) = 0;
    virtual Level get_level() const = 0;
};

class IThreadPool {
public:
    virtual ~IThreadPool() = default;
    virtual std::future<void> submit(std::function<void()> task) = 0;
    virtual void shutdown() = 0;
    virtual size_t get_thread_count() const = 0;
    virtual size_t get_pending_tasks() const = 0;
    
    template<typename F, typename... Args>
    auto submit(F&& f, Args&&... args) -> std::future<decltype(f(args...))> {
        return submit([f = std::forward<F>(f), args...]() { f(args...); });
    }
};

// Event context for handlers
struct EventContext {
    std::string type;
    nlohmann::json data;
    std::chrono::system_clock::time_point timestamp;
    DiscordClient* client;
};



} // namespace discord
=== END FILE ===

=== FILE: include/discord/core/client.h ===
#pragma once

#include "interfaces.h"
#include "../utils/types.h"
#include <memory>
#include <functional>
#include <future>
#include <string>
#include <nlohmann/json.hpp>

namespace discord {

// Forward declarations
class ICache;
class IHttpClient;
class IWebSocketClient;
class IRateLimiter;
class ILogger;
class IThreadPool;

struct User;
struct Guild;
struct Channel;
struct Message;

// Main Discord client interface
class DiscordClient {
public:
    explicit DiscordClient(std::string token);
    ~DiscordClient();
    
    // Connection management
    bool connect();
    void disconnect();
    bool is_connected() const;
    bool is_ready() const;
    
    // Event handlers
    void on_ready(std::function<void()> callback);
    void on_message(std::function<void(const nlohmann::json&)> callback);
    void on_message_deleted(std::function<void(const std::string&, const std::string&)> callback);
    void on_message_updated(std::function<void(const nlohmann::json&, const nlohmann::json&)> callback);
    void on_interaction(std::function<void(const nlohmann::json&)> callback);
    void on_guild_join(std::function<void(const nlohmann::json&)> callback);
    void on_guild_leave(std::function<void(const std::string&)> callback);
    void on_member_join(std::function<void(const nlohmann::json&)> callback);
    void on_member_leave(std::function<void(const nlohmann::json&)> callback);
    
    // REST API methods
    nlohmann::json get_user(const std::string& user_id);
    nlohmann::json get_guild(const std::string& guild_id);
    nlohmann::json get_channel(const std::string& channel_id);
    nlohmann::json get_channel_messages(const std::string& channel_id, int limit = 50, const std::string& before = "", const std::string& after = "");
    
    nlohmann::json send_message(const std::string& channel_id, const std::string& content);
    nlohmann::json send_embed(const std::string& channel_id, const nlohmann::json& embed);
    void delete_message(const std::string& channel_id, const std::string& message_id);
    void edit_message(const std::string& channel_id, const std::string& message_id, const std::string& new_content);
    
    void add_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji);
    void remove_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji, const std::string& user_id = "");
    
    void create_interaction_response(const std::string& interaction_id, const std::string& interaction_token, const nlohmann::json& response);
    void edit_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id, const nlohmann::json& message);
    void delete_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id);
    
    // Guild management
    void create_role(const std::string& guild_id, const nlohmann::json& role_data);
    void delete_role(const std::string& guild_id, const std::string& role_id);
    void add_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id);
    void remove_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id);
    
    // Channel management
    nlohmann::json create_text_channel(const std::string& guild_id, const std::string& name, const std::string& parent_id = "", int position = 0);
    nlohmann::json create_voice_channel(const std::string& guild_id, const std::string& name, int bitrate = 64000, int user_limit = 0);
    void delete_channel(const std::string& channel_id);
    void edit_channel(const std::string& channel_id, const nlohmann::json& data);
    
    // Configuration
    void set_token(const std::string& token);
    const std::string& get_token() const;
    void set_intents(int intents);
    int get_intents() const;

private:
    class Impl;
    std::unique_ptr<Impl> pImpl;
};

// Factory for creating clients
class DiscordClientFactory {
public:
    static std::unique_ptr<DiscordClient> create(const std::string& token);
    static std::unique_ptr<DiscordClient> create_with_config(const nlohmann::json& config);
};

} // namespace discord
=== END FILE ===

=== FILE: include/discord/utils.h ===
#pragma once

/**
 * @file utils.h
 * @brief Utility module containing helpers and common utilities
 */

#include "config.h"
#include "utils/types.h"
#include "utils/logger.h"
#include "utils/thread_pool.h"
#include "utils/config_manager.h"
#include "utils/auth.h"
#include "utils/embed_builder.h"

namespace discord::utils {
    // Re-export commonly used types
    template<typename T>
    using Result = discord::Result<T>;
    
    using discord::Logger;
    using discord::ThreadPool;
    using discord::ConfigManager;
    using discord::Auth;
    using discord::EmbedBuilder;
} // namespace discord::utils

=== END FILE ===

=== FILE: include/discord/utils/types.h ===
#pragma once

#include <string>
#include <vector>
#include <chrono>
#include <optional>
#include <variant>
#include <nlohmann/json.hpp>

namespace discord {

// Result type for better error handling
template<typename T>
class Result {
private:
    std::variant<T, std::string> value_;
    
public:
    Result(T value) : value_(std::move(value)) {}
    Result(const std::string& error) : value_(error) {}
    
    bool is_success() const {
        return std::holds_alternative<T>(value_);
    }
    
    bool is_error() const {
        return std::holds_alternative<std::string>(value_);
    }
    
    const T& value() const {
        if (is_error()) {
            throw std::runtime_error("Attempted to get value from error result");
        }
        return std::get<T>(value_);
    }
    
    const std::string& error() const {
        if (is_success()) {
            throw std::runtime_error("Attempted to get error from success result");
        }
        return std::get<std::string>(value_);
    }
    
    T value_or(T&& default_value) const {
        return is_success() ? value() : std::move(default_value);
    }
    
    template<typename F>
    Result<T> map(F&& func) const {
        if (is_success()) {
            try {
                return Result<T>(func(value()));
            } catch (const std::exception& e) {
                return Result<T>(e.what());
            }
        }
        return *this;
    }
};

// Specialization for void
template<>
class Result<void> {
private:
    std::optional<std::string> error_;
    
public:
    Result() : error_(std::nullopt) {}
    Result(const std::string& error) : error_(error) {}
    
    bool is_success() const { return !error_.has_value(); }
    bool is_error() const { return error_.has_value(); }
    
    const std::string& error() const {
        if (is_success()) {
            throw std::runtime_error("Attempted to get error from success result");
        }
        return *error_;
    }
};

enum class GatewayIntent {
    GUILDS = 1 << 0,
    GUILD_MEMBERS = 1 << 1,
    GUILD_BANS = 1 << 2,
    GUILD_EMOJIS_AND_STICKERS = 1 << 3,
    GUILD_INTEGRATIONS = 1 << 4,
    GUILD_WEBHOOKS = 1 << 5,
    GUILD_INVITES = 1 << 6,
    GUILD_VOICE_STATES = 1 << 7,
    GUILD_PRESENCES = 1 << 8,
    GUILD_MESSAGES = 1 << 9,
    GUILD_MESSAGE_REACTIONS = 1 << 10,
    GUILD_MESSAGE_TYPING = 1 << 11,
    DIRECT_MESSAGES = 1 << 12,
    DIRECT_MESSAGE_REACTIONS = 1 << 13,
    DIRECT_MESSAGE_TYPING = 1 << 14,
    MESSAGE_CONTENT = 1 << 15,
    GUILD_SCHEDULED_EVENTS = 1 << 16,
    AUTO_MODERATION_CONFIGURATION = 1 << 20,
    AUTO_MODERATION_EXECUTION = 1 << 21
};

// Permission flags
enum class Permission : uint64_t {
    CREATE_INSTANT_INVITE = 0x0000000001,
    KICK_MEMBERS = 0x0000000002,
    BAN_MEMBERS = 0x0000000004,
    ADMINISTRATOR = 0x0000000008,
    MANAGE_CHANNELS = 0x0000000010,
    MANAGE_GUILD = 0x0000000020,
    ADD_REACTIONS = 0x0000000040,
    VIEW_AUDIT_LOG = 0x0000000080,
    PRIORITY_SPEAKER = 0x0000000100,
    STREAM = 0x0000000200,
    VIEW_CHANNEL = 0x0000000400,
    SEND_MESSAGES = 0x0000000800,
    SEND_TTS_MESSAGES = 0x0000001000,
    MANAGE_MESSAGES = 0x0000002000,
    EMBED_LINKS = 0x0000004000,
    ATTACH_FILES = 0x0000008000,
    READ_MESSAGE_HISTORY = 0x0000010000,
    MENTION_EVERYONE = 0x0000020000,
    USE_EXTERNAL_EMOJIS = 0x0000040000,
    VIEW_GUILD_INSIGHTS = 0x0000080000,
    CONNECT = 0x0000100000,
    SPEAK = 0x0000200000,
    MUTE_MEMBERS = 0x0000400000,
    DEAFEN_MEMBERS = 0x0000800000,
    MOVE_MEMBERS = 0x0001000000,
    USE_VAD = 0x0002000000,
    CHANGE_NICKNAME = 0x0004000000,
    MANAGE_NICKNAMES = 0x0008000000,
    MANAGE_ROLES = 0x0010000000,
    MANAGE_WEBHOOKS = 0x0020000000,
    MANAGE_EMOJIS_AND_STICKERS = 0x0040000000,
    USE_APPLICATION_COMMANDS = 0x0080000000,
    REQUEST_TO_SPEAK = 0x0100000000,
    MANAGE_EVENTS = 0x0200000000,
    MANAGE_THREADS = 0x0400000000,
    CREATE_PUBLIC_THREADS = 0x0800000000,
    CREATE_PRIVATE_THREADS = 0x1000000000,
    USE_EXTERNAL_STICKERS = 0x2000000000,
    SEND_MESSAGES_IN_THREADS = 0x4000000000,
    START_EMBEDDED_ACTIVITIES = 0x8000000000,
    MODERATE_MEMBERS = 0x10000000000
};

// Embed structures (defined before use)
struct EmbedFooter {
    std::string text;
    std::optional<std::string> icon_url;
    std::optional<std::string> proxy_icon_url;
};

struct EmbedImage {
    std::optional<std::string> url;
    std::optional<std::string> proxy_url;
    std::optional<int> height;
    std::optional<int> width;
};

struct EmbedThumbnail {
    std::optional<std::string> url;
    std::optional<std::string> proxy_url;
    std::optional<int> height;
    std::optional<int> width;
};

struct EmbedVideo {
    std::optional<std::string> url;
    std::optional<int> height;
    std::optional<int> width;
};

struct EmbedProvider {
    std::optional<std::string> name;
    std::optional<std::string> url;
};

struct EmbedAuthor {
    std::optional<std::string> name;
    std::optional<std::string> url;
    std::optional<std::string> icon_url;
    std::optional<std::string> proxy_icon_url;
};

struct EmbedField {
    std::string name;
    std::string value;
    bool is_inline;
};

// Channel types
enum class ChannelType {
    GUILD_TEXT = 0,
    DM = 1,
    GUILD_VOICE = 2,
    GROUP_DM = 3,
    GUILD_CATEGORY = 4,
    GUILD_ANNOUNCEMENT = 5,
    ANNOUNCEMENT_THREAD = 10,
    PUBLIC_THREAD = 11,
    PRIVATE_THREAD = 12,
    GUILD_STAGE_VOICE = 13,
    GUILD_DIRECTORY = 14,
    GUILD_FORUM = 15
};

// Message types
enum class MessageType {
    DEFAULT = 0,
    RECIPIENT_ADD = 1,
    RECIPIENT_REMOVE = 2,
    CALL = 3,
    CHANNEL_NAME_CHANGE = 4,
    CHANNEL_ICON_CHANGE = 5,
    CHANNEL_PINNED_MESSAGE = 6,
    GUILD_MEMBER_JOIN = 7,
    USER_PREMIUM_GUILD_SUBSCRIPTION = 8,
    USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1 = 9,
    USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2 = 10,
    USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3 = 11,
    CHANNEL_FOLLOW_ADD = 12,
    GUILD_DISCOVERY_DISQUALIFIED = 14,
    GUILD_DISCOVERY_REQUALIFIED = 15,
    GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING = 16,
    GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING = 17,
    THREAD_CREATED = 18,
    REPLY = 19,
    CHAT_INPUT_COMMAND = 20,
    THREAD_STARTER_MESSAGE = 21,
    GUILD_INVITE_REMINDER = 22,
    CONTEXT_MENU_COMMAND = 23,
    AUTO_MODERATION_ACTION = 24,
    ROLE_SUBSCRIPTION_PURCHASE = 25,
    INTERACTION_PREMIUM_UPSELL = 26,
    STAGE_START = 27,
    STAGE_END = 28,
    STAGE_SPEAKER = 29,
    STAGE_TOPIC = 30,
    GUILD_APPLICATION_PREMIUM_SUBSCRIPTION = 31
};

struct User {
    std::string id;
    std::string username;
    std::string discriminator;
    std::string global_name;
    std::string avatar;
    bool bot;
    bool system;
    bool mfa_enabled;
    std::string locale;
    bool verified;
    std::string email;
    int flags;
    int premium_type;
    int public_flags;
    std::string avatar_decoration;
};

struct Guild {
    std::string id;
    std::string name;
    std::string icon;
    std::string icon_hash;
    std::string splash;
    std::string discovery_splash;
    bool owner;
    std::string owner_id;
    int permissions;
    std::string region;
    std::string afk_channel_id;
    int afk_timeout;
    bool widget_enabled;
    std::string widget_channel_id;
    int verification_level;
    int default_message_notifications;
    int explicit_content_filter;
    std::vector<nlohmann::json> roles;
    std::vector<nlohmann::json> emojis;
    std::vector<std::string> features;
    int mfa_level;
    std::string application_id;
    bool system_channel_flags;
    std::string rules_channel_id;
    int max_members;
    int max_presences;
    std::string vanity_url_code;
    std::string description;
    std::string banner;
    int premium_tier;
    int premium_subscription_count;
    std::string preferred_locale;
    std::string public_updates_channel_id;
    int max_video_channel_users;
    int approximate_member_count;
    int approximate_presence_count;
};

struct Channel {
    std::string id;
    int type;
    std::string guild_id;
    int position;
    std::vector<nlohmann::json> permission_overwrites;
    std::string name;
    std::string topic;
    bool nsfw;
    std::string last_message_id;
    int bitrate;
    int user_limit;
    int rate_limit_per_user;
    std::vector<nlohmann::json> recipients;
    std::string icon;
    std::string owner_id;
    std::string application_id;
    std::string parent_id;
    std::string last_pin_timestamp;
    std::vector<nlohmann::json> messages;
};

struct Message {
    std::string id;
    std::string channel_id;
    std::optional<std::string> guild_id;
    User author;
    std::optional<std::string> member;
    std::string content;
    std::chrono::system_clock::time_point timestamp;
    std::optional<std::chrono::system_clock::time_point> edited_timestamp;
    bool tts;
    bool mention_everyone;
    std::vector<User> mentions;
    std::vector<std::string> mention_roles;
    std::vector<std::string> mention_channels;
    std::vector<nlohmann::json> attachments;
    std::vector<nlohmann::json> embeds;
    std::vector<nlohmann::json> reactions;
    std::string nonce;
    bool pinned;
    std::optional<int> webhook_id;
    MessageType type;
    std::optional<std::vector<nlohmann::json>> components;
    std::optional<std::string> message_reference;
    std::optional<int> flags;
    std::optional<nlohmann::json> interaction;
    std::optional<std::string> thread;
    std::optional<nlohmann::json> application;
    std::optional<nlohmann::json> application_id;
    std::optional<nlohmann::json> activity;
    std::optional<nlohmann::json> sticker_items;
};

struct Role {
    std::string id;
    std::string name;
    int color;
    bool hoist;
    std::string icon;
    std::string unicode_emoji;
    int position;
    std::string permissions;
    bool managed;
    bool mentionable;
    std::vector<std::string> tags;
};

struct Member {
    User user;
    std::string nick;
    std::string avatar;
    std::vector<std::string> roles;
    std::chrono::system_clock::time_point joined_at;
    std::optional<std::chrono::system_clock::time_point> premium_since;
    bool deaf;
    bool mute;
    std::string permissions;
    std::optional<std::chrono::system_clock::time_point> communication_disabled_until;
};

struct Embed {
    std::optional<std::string> title;
    std::optional<std::string> type;
    std::optional<std::string> description;
    std::optional<std::string> url;
    std::optional<std::chrono::system_clock::time_point> timestamp;
    std::optional<int> color;
    std::optional<EmbedFooter> footer;
    std::optional<EmbedImage> image;
    std::optional<EmbedThumbnail> thumbnail;
    std::optional<EmbedVideo> video;
    std::optional<EmbedProvider> provider;
    std::optional<EmbedAuthor> author;
    std::vector<EmbedField> fields;
};



void to_json(nlohmann::json& j, const User& user);
void from_json(const nlohmann::json& j, User& user);

void to_json(nlohmann::json& j, const Guild& guild);
void from_json(const nlohmann::json& j, Guild& guild);

void to_json(nlohmann::json& j, const Channel& channel);
void from_json(const nlohmann::json& j, Channel& channel);

}
=== END FILE ===

=== FILE: include/discord/utils/logger.h ===
#pragma once

#include "../core/interfaces.h"
#include <memory>
#include <string>
#include <fstream>
#include <mutex>
#include <vector>
#include <sstream>
#include <thread>
#include <iomanip>
#include <iostream>

namespace discord {

/**
 * @brief Logger implementation for Discord.cpp
 * 
 * Provides thread-safe logging with multiple output destinations
 * and configurable log levels. Implements the ILogger interface.
 * 
 * @todo TODO.md: Complete missing implementations: Logger
 */
class Logger : public ILogger {
public:
    /**
     * @brief Log output destination
     */
    enum class Output {
        Console,
        File,
        Both
    };

    /**
     * @brief Log entry structure
     */
    struct LogEntry {
        Level level;
        std::string message;
        std::chrono::system_clock::time_point timestamp;
        std::string thread_id;
    };

private:
    Level current_level_;
    Output output_;
    std::string log_file_;
    std::ofstream file_stream_;
    mutable std::mutex mutex_;
    std::vector<LogEntry> buffer_;
    size_t max_buffer_size_;
    bool colors_enabled_;

    /**
     * @brief Format log level to string
     * @param level Log level to format
     * @return Formatted string representation
     */
    std::string level_to_string(Level level) const;

    /**
     * @brief Format timestamp to string
     * @param timestamp Time point to format
     * @return Formatted timestamp string
     */
    std::string format_timestamp(std::chrono::system_clock::time_point timestamp) const;

    /**
     * @brief Get current thread ID as string
     * @return Thread ID string
     */
    std::string get_thread_id() const;

    /**
     * @brief Apply console colors to log message
     * @param level Log level for color determination
     * @param message Message to colorize
     * @return Colorized message
     */
    std::string apply_colors(Level level, const std::string& message) const;

    /**
     * @brief Write log entry to console
     * @param entry Log entry to write
     */
    void write_to_console(const LogEntry& entry) const;

    /**
     * @brief Write log entry to file
     * @param entry Log entry to write
     */
    void write_to_file(const LogEntry& entry);

    /**
     * @brief Initialize file output
     */
    void initialize_file();

public:
    /**
     * @brief Construct Logger
     * @param level Minimum log level (default: Info)
     * @param output Output destination (default: Console)
     * @param log_file Path to log file (required if output includes File)
     * @param max_buffer_size Maximum number of entries to buffer (default: 1000)
     */
    explicit Logger(
        Level level = Level::Info,
        Output output = Output::Console,
        const std::string& log_file = "",
        size_t max_buffer_size = 1000
    );

    /**
     * @brief Destructor - closes file stream if open
     */
    ~Logger() override;

    /**
     * @brief Log a message at specified level
     * @param level Log level
     * @param message Message to log
     */
    void log(Level level, const std::string& message) override;

    /**
     * @brief Set minimum log level
     * @param level New minimum log level
     */
    void set_level(Level level) override;

    /**
     * @brief Get current minimum log level
     * @return Current log level
     */
    Level get_level() const override;

    /**
     * @brief Set output destination
     * @param output New output destination
     * @param log_file Path to log file (required if output includes File)
     */
    void set_output(Output output, const std::string& log_file = "");

    /**
     * @brief Enable/disable console colors
     * @param enabled Whether to enable colors
     */
    void set_colors_enabled(bool enabled);

    /**
     * @brief Get buffered log entries
     * @return Vector of buffered log entries
     */
    std::vector<LogEntry> get_buffer() const;

    /**
     * @brief Clear log buffer
     */
    void clear_buffer();

    /**
     * @brief Flush all pending logs
     */
    void flush();

    // Convenience methods for different log levels
    void trace(const std::string& message);
    void debug(const std::string& message);
    void info(const std::string& message);
    void warn(const std::string& message);
    void error(const std::string& message);
    void critical(const std::string& message);
};

/**
 * @brief Global logger instance
 */
extern std::shared_ptr<Logger> g_logger;

/**
 * @brief Initialize global logger
 * @param level Log level
 * @param output Output destination
 * @param log_file Log file path
 */
void initialize_logger(
    Logger::Level level = Logger::Level::Info,
    Logger::Output output = Logger::Output::Console,
    const std::string& log_file = ""
);

/**
 * @brief Get global logger instance
 * @return Shared pointer to global logger
 */
std::shared_ptr<Logger> get_logger();

/**
 * @brief Convenience macros for logging
 */
#define LOG_TRACE(msg) discord::get_logger()->trace(msg)
#define LOG_DEBUG(msg) discord::get_logger()->debug(msg)
#define LOG_INFO(msg) discord::get_logger()->info(msg)
#define LOG_WARN(msg) discord::get_logger()->warn(msg)
#define LOG_ERROR(msg) discord::get_logger()->error(msg)
#define LOG_CRITICAL(msg) discord::get_logger()->critical(msg)

} // namespace discord
=== END FILE ===

=== FILE: include/discord/utils/thread_pool.h ===
#pragma once

#include "../core/interfaces.h"
#include <vector>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <future>
#include <functional>

namespace discord {

class ThreadPool : public IThreadPool {
private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    mutable std::mutex queue_mutex_;
    std::condition_variable condition_;
    std::atomic<bool> stop_;
    size_t thread_count_;
    
public:
    explicit ThreadPool(size_t threads = std::thread::hardware_concurrency());
    ~ThreadPool() override;
    
    std::future<void> submit(std::function<void()> task) override;
    void shutdown() override;
    size_t get_thread_count() const override;
    size_t get_pending_tasks() const override;
    
private:
    void worker_thread();
};

} // namespace discord
=== END FILE ===

=== FILE: include/discord/utils/config_manager.h ===
#pragma once

#include <string>
#include <chrono>
#include <nlohmann/json.hpp>

namespace discord {

struct Config {
    std::string token;
    std::string api_version = "10";
    std::string base_url = "https://discord.com/api";
    std::string gateway_url = "wss://gateway.discord.gg";
    
    int intents = 0;
    bool compress = false;
    bool large_threshold = 50;
    
    std::chrono::milliseconds heartbeat_interval{42500};
    std::chrono::milliseconds connection_timeout{5000};
    std::chrono::milliseconds request_timeout{30000};
    
    int max_retries = 3;
    std::chrono::milliseconds retry_delay{1000};
    
    std::string user_agent = "DiscordBot (https://github.com/yourusername/discord.cpp, 1.0.0)";
    
    struct RateLimit {
        int max_requests = 5;
        std::chrono::milliseconds window{5000};
    } rate_limit;
    
    struct Sharding {
        int shard_id = 0;
        int shard_count = 1;
    } sharding;
    
    static Config from_file(const std::string& filename);
    static Config from_env();
    nlohmann::json to_json() const;
    void from_json(const nlohmann::json& j);
};

class ConfigManager {
public:
    static ConfigManager& instance();
    
    void load_config(const Config& config);
    const Config& get_config() const;
    
    void set_token(const std::string& token);
    void set_intents(int intents);
    void set_sharding(int shard_id, int shard_count);

private:
    ConfigManager() = default;
    Config config_;
};

}
=== END FILE ===

=== FILE: include/discord/utils/auth.h ===
#pragma once

#include <string>
#include <nlohmann/json.hpp>

namespace discord {

class Auth {
public:
    static std::string bot_token(const std::string& token);
    static std::string bearer_token(const std::string& token);
    
    static bool validate_token(const std::string& token);
    static nlohmann::json get_current_user(const std::string& token);
    
private:
    Auth() = default;
};

}
=== END FILE ===

=== FILE: include/discord/utils/embed_builder.h ===
#pragma once

#include "types.h"
#include <nlohmann/json.hpp>
#include <string>
#include <vector>
#include <optional>

namespace discord {

class EmbedBuilder {
private:
    nlohmann::json embed_;
    
public:
    EmbedBuilder();
    ~EmbedBuilder() = default;
    
    EmbedBuilder& title(const std::string& title);
    EmbedBuilder& description(const std::string& description);
    EmbedBuilder& url(const std::string& url);
    EmbedBuilder& color(int color);
    EmbedBuilder& timestamp(const std::chrono::system_clock::time_point& timestamp);
    EmbedBuilder& footer(const std::string& text, const std::string& icon_url = std::string());
    EmbedBuilder& thumbnail(const std::string& url, int height = 0, int width = 0);
    EmbedBuilder& image(const std::string& url, int height = 0, int width = 0);
    EmbedBuilder& author(const std::string& name, const std::string& url = std::string(), const std::string& icon_url = std::string());
    EmbedBuilder& field(const std::string& name, const std::string& value, bool is_inline = false);
    
    nlohmann::json build() const;
    
    // Static helper methods
    static int color_from_rgb(int r, int g, int b);
    static int color_from_hex(const std::string& hex);
    
    // Predefined colors
    static const int DEFAULT_COLOR = 0x000000;
    static const int AQUA = 0x1ABC9C;
    static const int GREEN = 0x2ECC71;
    static const int BLUE = 0x3498DB;
    static const int PURPLE = 0x9B59B6;
    static const int LUMINOUS_VIVID_PINK = 0xE91E63;
    static const int GOLD = 0xF1C40F;
    static const int ORANGE = 0xE67E22;
    static const int RED = 0xE74C3C;
    static const int GREY = 0x95A5A6;
    static const int NAVY = 0x34495E;
    static const int DARK_AQUA = 0x11806A;
    static const int DARK_GREEN = 0x1F8B4C;
    static const int DARK_BLUE = 0x206694;
    static const int DARK_PURPLE = 0x71368A;
    static const int DARK_VIVID_PINK = 0xAD1457;
    static const int DARK_GOLD = 0xC27C0E;
    static const int DARK_ORANGE = 0xA84300;
    static const int DARK_RED = 0x992D22;
    static const int DARK_GREY = 0x979C9F;
    static const int DARKER_GREY = 0x7F8C8D;
    static const int LIGHT_GREY = 0xBCC0C0;
    static const int DARK_NAVY = 0x2C3E50;
    static const int BLURPLE = 0x5865F2;
    static const int GREYPLE = 0x99AAB5;
    static const int DARK_BUT_NOT_BLACK = 0x2C2F33;
    static const int NOT_QUITE_BLACK = 0x23272A;
};

} // namespace discord
=== END FILE ===

=== FILE: include/discord/api.h ===
#pragma once

/**
 * @file api.h
 * @brief HTTP API client module
 */

#include "config.h"
#include "api/http_client.h"
#include "api/rest_endpoints.h"
#include "api/rate_limiter.h"

namespace discord::api {
    // Re-export commonly used types
    using discord::HTTPClient;
    using discord::RestEndpoints;
    using discord::RateLimiter;
} // namespace discord::api

=== END FILE ===

=== FILE: include/discord/api/http_client.h ===
#pragma once

#include "../core/interfaces.h"
#include <curl/curl.h>
#include <future>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <thread>
#include <atomic>
#include <nlohmann/json.hpp>

namespace discord {

class HTTPClient : public IHttpClient {
private:
    struct Request {
        std::string method;
        std::string url;
        nlohmann::json data;
        IHttpClient::Headers headers;
        std::promise<nlohmann::json> promise;
    };
    
    CURL* curl_;
    std::queue<Request*> request_queue_;
    std::mutex queue_mutex_;
    std::condition_variable queue_cv_;
    std::thread worker_thread_;
    std::atomic<bool> running_;
    std::chrono::milliseconds timeout_;
    std::string base_url_;
    std::string token_;
    
    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* userp);
    static size_t HeaderCallback(void* contents, size_t size, size_t nmemb, std::string* userp);
    
    void worker_loop();
    std::string perform_request(const std::string& method, const std::string& url, 
                               const nlohmann::json& data, const IHttpClient::Headers& headers);
    IHttpClient::Headers get_default_headers() const;
    
public:
    explicit HTTPClient(const std::string& token, const std::string& base_url = "https://discord.com/api/v10");
    ~HTTPClient() override;
    
    std::future<nlohmann::json> get(const std::string& url, const IHttpClient::Headers& headers = {}) override;
    std::future<nlohmann::json> post(const std::string& url, const nlohmann::json& data, const IHttpClient::Headers& headers = {}) override;
    std::future<nlohmann::json> put(const std::string& url, const nlohmann::json& data, const IHttpClient::Headers& headers = {}) override;
    std::future<nlohmann::json> patch(const std::string& url, const nlohmann::json& data, const IHttpClient::Headers& headers = {}) override;
    std::future<nlohmann::json> delete_(const std::string& url, const IHttpClient::Headers& headers = {}) override;
    std::future<void> set_timeout(std::chrono::milliseconds timeout) override;
    
    void shutdown();
    void set_base_url(const std::string& url);
    void set_token(const std::string& token);
};

} // namespace discord
=== END FILE ===

=== FILE: include/discord/api/rate_limiter.h ===
#pragma once

#include <chrono>
#include <string>
#include <unordered_map>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <functional>
#include <thread>

namespace discord {

struct RateLimitInfo {
    int remaining = -1;
    int limit = -1;
    std::chrono::steady_clock::time_point reset_time;
    bool global = false;
};

class RateLimiter {
public:
    RateLimiter();
    ~RateLimiter();
    
    void update_limits(const std::string& endpoint, const RateLimitInfo& info);
    bool can_make_request(const std::string& endpoint);
    void wait_if_needed(const std::string& endpoint);
    
    void set_global_limit(std::chrono::milliseconds delay);
    void set_endpoint_limit(const std::string& endpoint, int max_requests, std::chrono::milliseconds window);

private:
    struct EndpointLimit {
        int max_requests;
        std::chrono::milliseconds window;
        std::queue<std::chrono::steady_clock::time_point> request_times;
    };
    
    std::unordered_map<std::string, RateLimitInfo> rate_limits_;
    std::unordered_map<std::string, EndpointLimit> endpoint_limits_;
    std::chrono::steady_clock::time_point global_reset_time_;
    
    mutable std::mutex mutex_;
    std::condition_variable cv_;
    
    void cleanup_old_requests(const std::string& endpoint);
    std::chrono::milliseconds get_wait_time(const std::string& endpoint);
};

class RequestQueue {
public:
    using RequestFunction = std::function<void()>;
    
    RequestQueue();
    ~RequestQueue();
    
    void enqueue(const std::string& endpoint, RequestFunction request);
    void start();
    void stop();
    
    void set_rate_limiter(std::shared_ptr<RateLimiter> rate_limiter);

private:
    struct QueuedRequest {
        std::string endpoint;
        RequestFunction function;
        std::chrono::steady_clock::time_point enqueue_time;
    };
    
    std::queue<QueuedRequest> requests_;
    std::shared_ptr<RateLimiter> rate_limiter_;
    
    std::thread worker_thread_;
    std::mutex mutex_;
    std::condition_variable cv_;
    bool running_ = false;
    
    void process_requests();
};

}
=== END FILE ===

=== FILE: include/discord/api/rest_endpoints.h ===
#pragma once

#include <string>
#include <vector>
#include <nlohmann/json.hpp>

namespace discord {

class APIEndpoints {
public:
    static nlohmann::json get_user(const std::string& user_id);
    static nlohmann::json get_current_user();
    static nlohmann::json modify_current_user(const nlohmann::json& data);
    static nlohmann::json get_current_user_guilds();
    static nlohmann::json leave_guild(const std::string& guild_id);
    
    static nlohmann::json get_guild(const std::string& guild_id);
    static nlohmann::json get_guild_channels(const std::string& guild_id);
    static nlohmann::json get_guild_members(const std::string& guild_id, int limit = 1, const std::string& after = "");
    static nlohmann::json get_guild_member(const std::string& guild_id, const std::string& user_id);
    
    static nlohmann::json get_channel(const std::string& channel_id);
    static nlohmann::json modify_channel(const std::string& channel_id, const nlohmann::json& data);
    static nlohmann::json delete_channel(const std::string& channel_id);
    
    static nlohmann::json get_channel_messages(const std::string& channel_id, int limit = 50, const std::string& before = "", const std::string& after = "", const std::string& around = "");
    static nlohmann::json get_channel_message(const std::string& channel_id, const std::string& message_id);
    static nlohmann::json send_message(const std::string& channel_id, const nlohmann::json& data);
    static nlohmann::json edit_message(const std::string& channel_id, const std::string& message_id, const nlohmann::json& data);
    static nlohmann::json delete_message(const std::string& channel_id, const std::string& message_id);
    
    static nlohmann::json create_interaction_response(const std::string& interaction_id, const std::string& interaction_token, const nlohmann::json& data);
    static nlohmann::json get_original_interaction_response(const std::string& interaction_id, const std::string& interaction_token);
    static nlohmann::json edit_original_interaction_response(const std::string& interaction_id, const std::string& interaction_token, const nlohmann::json& data);
    static nlohmann::json delete_original_interaction_response(const std::string& interaction_id, const std::string& interaction_token);
    
    static nlohmann::json get_gateway();
    static nlohmann::json get_gateway_bot();
    
    // Reactions
    static nlohmann::json add_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji);
    static nlohmann::json remove_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji, const std::string& user_id = "");
    
    // Webhooks (for followup messages)
    static nlohmann::json edit_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id, const nlohmann::json& message);
    static nlohmann::json delete_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id);
    
    // Guild roles
    static nlohmann::json create_guild_role(const std::string& guild_id, const nlohmann::json& role_data);
    static nlohmann::json delete_guild_role(const std::string& guild_id, const std::string& role_id);
    static nlohmann::json add_guild_member_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id);
    static nlohmann::json remove_guild_member_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id);
    
    // Channel creation
    static nlohmann::json create_channel(const std::string& guild_id, const nlohmann::json& data);

private:
    APIEndpoints() = default;
};

}
=== END FILE ===

=== FILE: include/discord/cache.h ===
#pragma once

/**
 * @file cache.h
 * @brief Caching layer module
 */

#include "config.h"
#include "cache/cache_manager.h"
#include "cache/memory_cache.h"
#include "cache/redis_cache.h"

namespace discord::cache {
    // Re-export commonly used types
    using discord::CacheManager;
    using discord::MemoryCache;
    using discord::RedisCache;
} // namespace discord::cache

=== END FILE ===

=== FILE: include/discord/cache/cache_manager.h ===
#pragma once

#include "../core/interfaces.h"
#include <memory>
#include <string>
#include <unordered_map>
#include <mutex>
#include <chrono>
#include <vector>
#include <functional>
#include <nlohmann/json.hpp>

namespace discord {

/**
 * @brief Cache entry with TTL support
 */
struct CacheEntry {
    nlohmann::json value;
    std::chrono::system_clock::time_point created_at;
    std::chrono::system_clock::time_point expires_at;
    bool is_persistent;
    
    CacheEntry(
        const nlohmann::json& val,
        std::chrono::seconds ttl = std::chrono::seconds::zero(),
        bool persistent = false
    ) : value(val)
      , created_at(std::chrono::system_clock::now())
      , is_persistent(persistent) {
        
        if (ttl.count() > 0) {
            expires_at = created_at + ttl;
        } else {
            expires_at = std::chrono::system_clock::time_point::max();
        }
    }
    
    bool is_expired() const {
        return !is_persistent && std::chrono::system_clock::now() > expires_at;
    }
};

/**
 * @brief Cache statistics
 */
struct CacheStats {
    size_t total_entries;
    size_t expired_entries;
    size_t persistent_entries;
    size_t memory_usage_bytes;
    std::chrono::system_clock::time_point last_cleanup;
    
    CacheStats() : total_entries(0), expired_entries(0), persistent_entries(0), 
                   memory_usage_bytes(0), last_cleanup(std::chrono::system_clock::now()) {}
};

/**
 * @brief Cache configuration
 */
struct CacheConfig {
    size_t max_entries;
    std::chrono::seconds default_ttl;
    std::chrono::seconds cleanup_interval;
    bool enable_persistence;
    bool enable_compression;
    float cleanup_threshold;
    
    CacheConfig() : max_entries(10000),
                   default_ttl(std::chrono::seconds(3600)),
                   cleanup_interval(std::chrono::seconds(300)),
                   enable_persistence(false),
                   enable_compression(false),
                   cleanup_threshold(0.8f) {}
};

/**
 * @brief Cache Manager implementation for Discord.cpp
 * 
 * Provides thread-safe caching with TTL support, automatic cleanup,
 * and configurable storage strategies. Implements the ICache interface.
 * 
 * @todo TODO.md: Complete missing implementations: CacheManager
 */
class CacheManager : public ICache {
private:
    mutable std::mutex mutex_;
    std::unordered_map<std::string, CacheEntry> cache_;
    CacheConfig config_;
    CacheStats stats_;
    std::vector<std::function<void(const std::string&, const nlohmann::json&)>> eviction_callbacks_;
    std::chrono::system_clock::time_point last_cleanup_;
    bool cleanup_running_;

    /**
     * @brief Estimate memory usage of a JSON value
     * @param value JSON value to estimate
     * @return Estimated memory usage in bytes
     */
    size_t estimate_memory_usage(const nlohmann::json& value) const;

    /**
     * @brief Perform cleanup of expired entries
     * @param force Force cleanup even if not scheduled
     */
    void cleanup_expired(bool force = false);

    /**
     * @brief Evict entries based on LRU policy when cache is full
     * @param required_space Required space to free up
     */
    void evict_lru(size_t required_space = 0);

    /**
     * @brief Check if cleanup should run
     * @return True if cleanup should run
     */
    bool should_cleanup() const;

    /**
     * @brief Update cache statistics
     */
    void update_stats();

    /**
     * @brief Notify eviction callbacks
     * @param key Key being evicted
     * @param value Value being evicted
     */
    void notify_eviction(const std::string& key, const nlohmann::json& value);

    /**
     * @brief Convert wildcard pattern to regex
     * @param pattern Pattern to convert
     * @return Regex string
     */
    std::string pattern_to_regex(const std::string& pattern) const;

public:
    /**
     * @brief Construct CacheManager
     * @param config Cache configuration
     */
    explicit CacheManager(const CacheConfig& config = CacheConfig{});

    /**
     * @brief Destructor - performs final cleanup
     */
    ~CacheManager() override;

    // ICache interface implementation
    void set(const std::string& key, const nlohmann::json& value, std::chrono::seconds ttl = {}) override;
    std::optional<nlohmann::json> get(const std::string& key) override;
    void remove(const std::string& key) override;
    void clear() override;
    bool exists(const std::string& key) override;
    std::vector<std::string> keys(const std::string& pattern = "*") override;

    /**
     * @brief Set cache configuration
     * @param config New configuration
     */
    void set_config(const CacheConfig& config);

    /**
     * @brief Get current cache configuration
     * @return Current configuration
     */
    const CacheConfig& get_config() const;

    /**
     * @brief Get cache statistics
     * @return Current statistics
     */
    CacheStats get_stats() const;

    /**
     * @brief Force cleanup of expired entries
     */
    void force_cleanup();

    /**
     * @brief Add eviction callback
     * @param callback Function to call when entry is evicted
     */
    void add_eviction_callback(std::function<void(const std::string&, const nlohmann::json&)> callback);

    /**
     * @brief Remove eviction callback
     * @param callback Callback to remove
     */
    void remove_eviction_callback(const std::function<void(const std::string&, const nlohmann::json&)>& callback);

    /**
     * @brief Set persistent entry (never expires)
     * @param key Entry key
     * @param value Entry value
     */
    void set_persistent(const std::string& key, const nlohmann::json& value);

    /**
     * @brief Get multiple entries
     * @param keys Vector of keys to retrieve
     * @return Map of found entries
     */
    std::unordered_map<std::string, nlohmann::json> get_multiple(const std::vector<std::string>& keys);

    /**
     * @brief Set multiple entries
     * @param entries Map of key-value pairs to set
     * @param ttl TTL for all entries
     */
    void set_multiple(const std::unordered_map<std::string, nlohmann::json>& entries, 
                     std::chrono::seconds ttl = {});

    /**
     * @brief Remove multiple entries
     * @param keys Vector of keys to remove
     */
    void remove_multiple(const std::vector<std::string>& keys);

    /**
     * @brief Get entries matching pattern
     * @param pattern Pattern to match (supports * wildcards)
     * @return Vector of matching key-value pairs
     */
    std::vector<std::pair<std::string, nlohmann::json>> get_matching(const std::string& pattern);

    /**
     * @brief Get cache size in bytes
     * @return Estimated memory usage
     */
    size_t get_memory_usage() const;

    /**
     * @brief Get number of entries
     * @return Total number of entries
     */
    size_t size() const;

    /**
     * @brief Check if cache is empty
     * @return True if cache is empty
     */
    bool empty() const;

    /**
     * @brief Get TTL for a key
     * @param key Key to check
     * @return TTL in seconds, or 0 if no TTL
     */
    std::chrono::seconds get_ttl(const std::string& key) const;

    /**
     * @brief Update TTL for a key
     * @param key Key to update
     * @param ttl New TTL
     */
    void update_ttl(const std::string& key, std::chrono::seconds ttl);

    /**
     * @brief Export cache to JSON
     * @return JSON representation of cache
     */
    nlohmann::json export_cache() const;

    /**
     * @brief Import cache from JSON
     * @param data JSON data to import
     * @param overwrite Whether to overwrite existing entries
     */
    void import_cache(const nlohmann::json& data, bool overwrite = false);
};

/**
 * @brief Cache factory for creating specialized cache instances
 */
class CacheFactory {
public:
    /**
     * @brief Create memory cache
     * @param config Cache configuration
     * @return Shared pointer to cache instance
     */
    static std::shared_ptr<ICache> create_memory_cache(const CacheConfig& config = CacheConfig{});

    /**
     * @brief Create Redis cache (placeholder for future implementation)
     * @param config Cache configuration
     * @param connection_string Redis connection string
     * @return Shared pointer to cache instance
     */
    static std::shared_ptr<ICache> create_redis_cache(
        const CacheConfig& config = CacheConfig{},
        const std::string& connection_string = ""
    );
};

} // namespace discord
=== END FILE ===

=== FILE: include/discord/cache/memory_cache.h ===
#pragma once

#include "../core/interfaces.h"
#include <unordered_map>
#include <shared_mutex>
#include <chrono>
#include <optional>
#include <vector>
#include <nlohmann/json.hpp>

namespace discord {

struct CacheEntry {
    nlohmann::json value;
    std::chrono::system_clock::time_point expiry;
    
    CacheEntry(const nlohmann::json& val, std::chrono::seconds ttl)
        : value(val), expiry(std::chrono::system_clock::now() + ttl) {}
    
    bool is_expired() const {
        return std::chrono::system_clock::now() > expiry;
    }
};

class MemoryCache : public ICache {
private:
    std::unordered_map<std::string, CacheEntry> cache_;
    mutable std::shared_mutex mutex_;
    
public:
    MemoryCache() = default;
    ~MemoryCache() override = default;
    
    void set(const std::string& key, const nlohmann::json& value, std::chrono::seconds ttl = {}) override;
    std::optional<nlohmann::json> get(const std::string& key) override;
    void remove(const std::string& key) override;
    void clear() override;
    bool exists(const std::string& key) override;
    std::vector<std::string> keys(const std::string& pattern = "*") override;
    
private:
    void cleanup_expired();
    std::vector<std::string> pattern_match(const std::string& pattern) const;
};

} // namespace discord
=== END FILE ===

=== FILE: include/discord/cache/redis_cache.h ===

=== END FILE ===

=== FILE: include/discord/gateway.h ===
#pragma once

/**
 * @file gateway.h
 * @brief WebSocket gateway and real-time events module
 */

#include "config.h"
#include "gateway/websocket_client.h"
#include "gateway/gateway_events.h"
#include "gateway/reconnection.h"
#include "gateway/shard_manager.h"

namespace discord::gateway {
    // Re-export commonly used types
    using discord::WebSocketClient;
    using discord::GatewayOpcode;
    using discord::GatewayCloseEvent;
    using discord::ReconnectionManager;
    using discord::ShardManager;
} // namespace discord::gateway

=== END FILE ===

=== FILE: include/discord/gateway/websocket_client.h ===
#pragma once

#include <string>
#include <functional>
#include <nlohmann/json.hpp>
#include "reconnection.h"

namespace discord {

enum class GatewayOpcode {
    DISPATCH = 0,
    HEARTBEAT = 1,
    IDENTIFY = 2,
    PRESENCE_UPDATE = 3,
    VOICE_STATE_UPDATE = 4,
    RESUME = 6,
    RECONNECT = 7,
    REQUEST_GUILD_MEMBERS = 8,
    INVALID_SESSION = 9,
    HELLO = 10,
    HEARTBEAT_ACK = 11
};

enum class GatewayCloseEvent {
    UNKNOWN_ERROR = 4000,
    UNKNOWN_OPCODE = 4001,
    DECODE_ERROR = 4002,
    NOT_AUTHENTICATED = 4003,
    AUTHENTICATION_FAILED = 4004,
    ALREADY_AUTHENTICATED = 4005,
    INVALID_SEQ = 4007,
    RATE_LIMITED = 4008,
    SESSION_TIMED_OUT = 4009,
    INVALID_SHARD = 4010,
    SHARDING_REQUIRED = 4011,
    INVALID_API_VERSION = 4012,
    INVALID_INTENTS = 4013,
    DISALLOWED_INTENTS = 4014
};

class WebSocketClient {
public:
    using EventCallback = std::function<void(const nlohmann::json&)>;
    using CloseCallback = std::function<void(int, const std::string&)>;

    WebSocketClient();
    ~WebSocketClient();

    bool connect(const std::string& url);
    void disconnect();
    bool is_connected() const;

    void send(const nlohmann::json& payload);
    
    void on_event(EventCallback callback);
    void on_close(CloseCallback callback);

    void set_token(const std::string& token);
    void set_intents(int intents);
    void identify();
    
    // Reconnection management
    void enable_auto_reconnect(bool enabled);
    void set_reconnection_config(int max_retries = 5, 
                               std::chrono::milliseconds base_delay = std::chrono::milliseconds(1000),
                               std::chrono::milliseconds max_delay = std::chrono::milliseconds(30000));
    bool is_reconnecting() const;
    void stop_reconnecting();
    
    // Compression support
    void enable_compression(bool enabled);
    bool is_compression_enabled() const;

private:
    class Impl;
    std::unique_ptr<Impl> pImpl;
};

}
=== END FILE ===

=== FILE: include/discord/gateway/shard_manager.h ===
#pragma once

#include <memory>
#include <vector>
#include <unordered_map>
#include <string>
#include <functional>
#include <thread>
#include <mutex>
#include <atomic>
#include <chrono>
#include <nlohmann/json.hpp>
#include "websocket_client.h"
#include "reconnection.h"

namespace discord {

/**
 * @brief Shard information and state
 */
struct ShardInfo {
    int shard_id;
    int shard_count;
    std::string session_id;
    int sequence_number;
    bool is_connected;
    bool is_resumable;
    std::chrono::steady_clock::time_point last_heartbeat;
    std::chrono::steady_clock::time_point connect_time;
    int reconnect_attempts;
    
    ShardInfo(int id, int total) 
        : shard_id(id), shard_count(total), sequence_number(0), 
          is_connected(false), is_resumable(false), reconnect_attempts(0) {}
};

/**
 * @brief Shard configuration
 */
struct ShardConfig {
    int shard_count;
    int max_concurrency;
    std::chrono::milliseconds connection_delay;
    std::chrono::milliseconds heartbeat_interval;
    bool auto_sharding;
    bool compress;
    
    ShardConfig() 
        : shard_count(1), max_concurrency(1), 
          connection_delay(std::chrono::milliseconds(5000)),
          heartbeat_interval(std::chrono::milliseconds(41250)),
          auto_sharding(true), compress(true) {}
};

/**
 * @brief Gateway session information
 */
struct GatewaySession {
    std::string url;
    int shards;
    int session_start_limit_total;
    int session_start_limit_remaining;
    int session_start_limit_reset_after;
    std::chrono::steady_clock::time_point last_reset;
    
    bool can_start_session() const {
        return session_start_limit_remaining > 0;
    }
};

/**
 * @brief Shard Manager for Discord.cpp
 * 
 * Manages multiple WebSocket connections (shards) for large bots,
 * handling auto-sharding, load balancing, and session management.
 * 
 * @todo TODO.md: Implement Shard Manager with auto-sharding and load balancing
 */
class ShardManager {
public:
    using EventCallback = std::function<void(int, const nlohmann::json&)>;
    using ShardStateCallback = std::function<void(int, bool)>;
    using ReadyCallback = std::function<void(int, const nlohmann::json&)>;

private:
    ShardConfig config_;
    std::unordered_map<int, std::unique_ptr<WebSocketClient>> shards_;
    std::unordered_map<int, ShardInfo> shard_info_;
    std::string gateway_url_;
    std::string bot_token_;
    
    // Callbacks
    EventCallback event_callback_;
    ShardStateCallback shard_state_callback_;
    ReadyCallback ready_callback_;
    
    // Threading and synchronization
    mutable std::mutex mutex_;
    std::vector<std::thread> connection_threads_;
    std::atomic<bool> is_running_{false};
    std::atomic<bool> is_shutting_down_{false};
    
    // Session management
    GatewaySession session_info_;
    std::chrono::steady_clock::time_point last_session_update_;
    
    // Rate limiting
    std::atomic<int> sessions_started_recently_{0};
    std::chrono::steady_clock::time_point last_session_reset_;

    /**
     * @brief Initialize a single shard
     * @param shard_id Shard ID to initialize
     * @return True if initialization was successful
     */
    bool initialize_shard(int shard_id);

    /**
     * @brief Connect a single shard
     * @param shard_id Shard ID to connect
     */
    void connect_shard(int shard_id);

    /**
     * @brief Disconnect a single shard
     * @param shard_id Shard ID to disconnect
     */
    void disconnect_shard(int shard_id);

    /**
     * @brief Handle shard connection events
     * @param shard_id Shard ID
     * @param event Event data
     */
    void handle_shard_event(int shard_id, const nlohmann::json& event);

    /**
     * @brief Handle shard disconnection
     * @param shard_id Shard ID
     * @param close_code Close code
     * @param reason Close reason
     */
    void handle_shard_disconnect(int shard_id, int close_code, const std::string& reason);

    /**
     * @brief Handle shard ready event
     * @param shard_id Shard ID
     * @param ready_data Ready event data
     */
    void handle_shard_ready(int shard_id, const nlohmann::json& ready_data);

    /**
     * @brief Handle shard resume
     * @param shard_id Shard ID
     * @param resume_data Resume event data
     */
    void handle_shard_resume(int shard_id, const nlohmann::json& resume_data);

    /**
     * @brief Get gateway information from Discord
     * @return Gateway session information
     */
    GatewaySession get_gateway_info();

    /**
     * @brief Calculate optimal shard count
     * @return Recommended shard count
     */
    int calculate_shard_count();

    /**
     * @brief Check if we can start a new session
     * @return True if session can be started
     */
    bool can_start_session();

    /**
     * @brief Wait for session slot
     */
    void wait_for_session_slot();

    /**
     * @brief Update session start limits
     */
    void update_session_limits();

    /**
     * @brief Get shard for guild ID
     * @param guild_id Guild ID
     * @return Shard ID that should handle this guild
     */
    int get_shard_for_guild(const std::string& guild_id);

    /**
     * @brief Validate shard configuration
     * @return True if configuration is valid
     */
    bool validate_config() const;

    /**
     * @brief Get gateway URL with parameters
     * @return Formatted gateway URL
     */
    std::string get_gateway_url() const;

    /**
     * @brief Send identify payload for specific shard
     * @param shard_id Shard ID to identify
     */
    void identify_shard(int shard_id);

    /**
     * @brief Send resume payload for specific shard
     * @param shard_id Shard ID to resume
     * @param resume_data Resume data (optional)
     */
    void resume_shard(int shard_id, const nlohmann::json& resume_data);

public:
    /**
     * @brief Construct ShardManager
     * @param token Bot token
     * @param config Shard configuration
     */
    explicit ShardManager(const std::string& token, const ShardConfig& config = ShardConfig{});

    /**
     * @brief Destructor - ensures clean shutdown
     */
    ~ShardManager();

    /**
     * @brief Start all shards
     * @return True if all shards started successfully
     */
    bool start();

    /**
     * @brief Stop all shards
     */
    void stop();

    /**
     * @brief Connect specific shard
     * @param shard_id Shard ID to connect
     * @return True if connection initiated successfully
     */
    bool connect_shard_by_id(int shard_id);

    /**
     * @brief Disconnect specific shard
     * @param shard_id Shard ID to disconnect
     */
    void disconnect_shard_by_id(int shard_id);

    /**
     * @brief Reconnect specific shard
     * @param shard_id Shard ID to reconnect
     * @param resume Whether to attempt resume
     */
    void reconnect_shard(int shard_id, bool resume = true);

    /**
     * @brief Reconnect all shards
     * @param resume Whether to attempt resume for all shards
     */
    void reconnect_all(bool resume = true);

    /**
     * @brief Send event to specific shard
     * @param shard_id Target shard ID
     * @param event Event to send
     * @return True if sent successfully
     */
    bool send_to_shard(int shard_id, const nlohmann::json& event);

    /**
     * @brief Send event to all shards
     * @param event Event to send
     * @return Number of shards event was sent to
     */
    int send_to_all_shards(const nlohmann::json& event);

    /**
     * @brief Get shard information
     * @param shard_id Shard ID
     * @return Shard information or nullptr if not found
     */
    const ShardInfo* get_shard_info(int shard_id) const;

    /**
     * @brief Get all shard information
     * @return Map of shard ID to shard information
     */
    std::unordered_map<int, ShardInfo> get_all_shard_info() const;

    /**
     * @brief Get number of connected shards
     * @return Number of connected shards
     */
    int get_connected_shard_count() const;

    /**
     * @brief Get total number of shards
     * @return Total shard count
     */
    int get_total_shard_count() const;

    /**
     * @brief Check if shard manager is running
     * @return True if running
     */
    bool is_running() const;

    /**
     * @brief Check if specific shard is connected
     * @param shard_id Shard ID
     * @return True if connected
     */
    bool is_shard_connected(int shard_id) const;

    /**
     * @brief Set event callback
     * @param callback Function to call for events
     */
    void set_event_callback(EventCallback callback);

    /**
     * @brief Set shard state callback
     * @param callback Function to call when shard state changes
     */
    void set_shard_state_callback(ShardStateCallback callback);

    /**
     * @brief Set ready callback
     * @param callback Function to call when shard becomes ready
     */
    void set_ready_callback(ReadyCallback callback);

    /**
     * @brief Update shard configuration
     * @param config New configuration
     */
    void set_config(const ShardConfig& config);

    /**
     * @brief Get current configuration
     * @return Current shard configuration
     */
    const ShardConfig& get_config() const;

    /**
     * @brief Get gateway session information
     * @return Current session information
     */
    const GatewaySession& get_session_info() const;

    /**
     * @brief Force identify all shards
     */
    void identify_all();

    /**
     * @brief Force resume all shards
     */
    void resume_all();

    /**
     * @brief Get shard statistics
     * @return JSON object with shard statistics
     */
    nlohmann::json get_statistics() const;

    /**
     * @brief Enable/disable auto-reconnect for all shards
     * @param enabled Whether to enable auto-reconnect
     */
    void set_auto_reconnect(bool enabled);

    /**
     * @brief Set reconnection configuration for all shards
     * @param max_retries Maximum reconnection attempts
     * @param base_delay Base delay between attempts
     * @param max_delay Maximum delay between attempts
     */
    void set_reconnection_config(int max_retries = 5,
                               std::chrono::milliseconds base_delay = std::chrono::milliseconds(1000),
                               std::chrono::milliseconds max_delay = std::chrono::milliseconds(30000));
};

/**
 * @brief Shard factory for creating optimized shard configurations
 */
class ShardFactory {
public:
    /**
     * @brief Create configuration for small bots
     * @return Configuration optimized for small bots
     */
    static ShardConfig create_small_bot_config();

    /**
     * @brief Create configuration for medium bots
     * @return Configuration optimized for medium bots
     */
    static ShardConfig create_medium_bot_config();

    /**
     * @brief Create configuration for large bots
     * @return Configuration optimized for large bots
     */
    static ShardConfig create_large_bot_config();

    /**
     * @brief Calculate optimal shard count based on guild count
     * @param guild_count Number of guilds bot is in
     * @return Recommended shard count
     */
    static int calculate_optimal_shards(int guild_count);

    /**
     * @brief Create configuration based on guild count
     * @param guild_count Number of guilds bot is in
     * @return Optimized configuration
     */
    static ShardConfig create_config_for_guild_count(int guild_count);
};

} // namespace discord
=== END FILE ===

=== FILE: include/discord/gateway/gateway_events.h ===

=== END FILE ===

=== FILE: include/discord/gateway/reconnection.h ===
#pragma once

#include <string>
#include <chrono>
#include <functional>
#include <thread>
#include <atomic>
#include <mutex>
#include <condition_variable>

namespace discord {

class ReconnectionManager {
public:
    using ReconnectCallback = std::function<void(bool)>;
    using ResumeCallback = std::function<void()>;
    
    ReconnectionManager();
    ~ReconnectionManager();
    
    void set_callbacks(ReconnectCallback reconnect_cb, ResumeCallback resume_cb);
    
    void handle_disconnect(int close_code, const std::string& reason);
    void handle_invalid_session(bool can_resume);
    void handle_connection_restored();
    
    void enable_auto_reconnect(bool enabled);
    void set_max_retries(int max_retries);
    void set_base_delay(std::chrono::milliseconds delay);
    void set_max_delay(std::chrono::milliseconds delay);
    
    bool should_resume() const;
    bool is_reconnecting() const;
    void stop_reconnecting();
    
    void reset_session();

private:
    struct SessionInfo {
        std::string session_id;
        int sequence_number = 0;
        bool can_resume = false;
        std::chrono::steady_clock::time_point last_heartbeat;
    };
    
    ReconnectCallback reconnect_callback_;
    ResumeCallback resume_callback_;
    
    SessionInfo session_info_;
    
    std::atomic<bool> auto_reconnect_enabled_{true};
    std::atomic<int> max_retries_{5};
    std::atomic<std::chrono::milliseconds> base_delay_{std::chrono::milliseconds(1000)};
    std::atomic<std::chrono::milliseconds> max_delay_{std::chrono::milliseconds(30000)};
    
    std::atomic<bool> is_reconnecting_{false};
    std::atomic<int> current_retry_count_{0};
    
    std::thread reconnect_thread_;
    std::mutex mutex_;
    std::condition_variable cv_;
    std::atomic<bool> should_stop_{false};
    
    void attempt_reconnection();
    std::chrono::milliseconds calculate_backoff_delay(int attempt) const;
    void exponential_backoff_reconnect();
    
    bool is_resumable_close_code(int close_code) const;
    void start_reconnect_sequence();
};

}
=== END FILE ===

=== FILE: include/discord/events.h ===
#pragma once

/**
 * @file events.h
 * @brief Event handling and dispatch module
 */

#include "config.h"
#include "events/event_dispatcher.h"
#include "events/event_handlers.h"
#include "events/middleware.h"

namespace discord::events {
    // Re-export commonly used types
    using discord::EventDispatcher;
    using discord::EventHandler;
    using discord::Middleware;
} // namespace discord::events

=== END FILE ===

=== FILE: include/discord/events/event_dispatcher.h ===
#pragma once

#include <string>
#include <functional>
#include <unordered_map>
#include <vector>
#include <memory>
#include <shared_mutex>
#include <chrono>
#include <variant>
#include <nlohmann/json.hpp>
#include "../core/interfaces.h"

namespace discord {

/**
 * @brief Event filter function type
 */
using EventFilter = std::function<bool(const nlohmann::json&)>;

/**
 * @brief Event handler function type
 */
using EventCallback = std::function<void(const nlohmann::json&)>;

/**
 * @brief Event handler with priority
 */
struct EventHandlerInfo {
    EventCallback callback;
    int priority;
    std::string id;
    bool once;
    std::chrono::steady_clock::time_point created_at;
    
    EventHandlerInfo(EventCallback cb, int prio = 0, const std::string& handler_id = "", bool is_once = false)
        : callback(std::move(cb)), priority(prio), id(handler_id), once(is_once)
        , created_at(std::chrono::steady_clock::now()) {}
};

/**
 * @brief Event collector configuration
 */
struct CollectorConfig {
    std::chrono::milliseconds timeout;
    int max_matches;
    bool dispose_on_timeout;
    
    CollectorConfig(std::chrono::milliseconds to = std::chrono::milliseconds(30000), 
                   int max = 1, bool dispose = true)
        : timeout(to), max_matches(max), dispose_on_timeout(dispose) {}
};

/**
 * @brief Event collector for waiting for specific events
 */
template<typename T>
class EventCollector {
public:
    using FilterFunction = std::function<bool(const T&)>;
    using CollectorCallback = std::function<void(const T&)>;
    
private:
    std::vector<T> collected_items_;
    FilterFunction filter_;
    CollectorConfig config_;
    std::string handler_id_;
    bool is_active_;
    std::chrono::steady_clock::time_point start_time_;
    mutable std::shared_mutex mutex_;
    
    /**
     * @brief Check if collector should stop
     * @return True if max matches reached
     */
    bool should_stop_collecting() const {
        return config_.max_matches > 0 && 
               collected_items_.size() >= static_cast<size_t>(config_.max_matches);
    }
    
    /**
     * @brief Check if collector has timed out
     * @return True if timeout exceeded
     */
    bool is_timed_out() const {
        if (config_.timeout.count() == 0) {
            return false;
        }
        
        auto now = std::chrono::steady_clock::now();
        return (now - start_time_) > config_.timeout;
    }

public:
    /**
     * @brief Construct EventCollector
     * @param filter Filter function for events
     * @param config Collector configuration
     */
    explicit EventCollector(FilterFunction filter = nullptr, 
                        const CollectorConfig& config = CollectorConfig{})
        : filter_(std::move(filter)), config_(config), is_active_(false) {}
    
    /**
     * @brief Destructor - cleans up handler
     */
    ~EventCollector() {
        stop();
    }
    
    /**
     * @brief Start collecting events
     * @param dispatcher Event dispatcher to register with
     * @param event_name Event name to listen for
     * @return Handler ID for cleanup
     */
    std::string start(class EventDispatcher* dispatcher, const std::string& event_name);
    
    /**
     * @brief Stop collecting events
     */
    void stop();
    
    /**
     * @brief Process incoming event
     * @param event Event to process
     * @return True if event was collected
     */
    bool process_event(const nlohmann::json& event);
    
    /**
     * @brief Get collected items
     * @return Vector of collected items
     */
    std::vector<T> get_collected() const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        return collected_items_;
    }
    
    /**
     * @brief Get first collected item
     * @return First item or empty optional
     */
    std::optional<T> first() const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        return collected_items_.empty() ? std::nullopt : std::optional<T>(collected_items_.front());
    }
    
    /**
     * @brief Wait for first match
     * @param timeout Maximum time to wait
     * @return First matching item or empty optional
     */
    std::optional<T> wait_for_first(std::chrono::milliseconds timeout = std::chrono::milliseconds(30000));
    
    /**
     * @brief Wait for all matches
     * @param timeout Maximum time to wait
     * @return All matching items or empty vector
     */
    std::vector<T> wait_for_all(std::chrono::milliseconds timeout = std::chrono::milliseconds(30000));
    
    /**
     * @brief Check if collector is active
     * @return True if actively collecting
     */
    bool is_active() const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        return is_active_;
    }
    
    /**
     * @brief Get number of collected items
     * @return Number of items collected
     */
    size_t count() const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        return collected_items_.size();
    }
    
    /**
     * @brief Clear collected items
     */
    void clear() {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        collected_items_.clear();
    }
};

/**
 * @brief Event middleware interface
 */
class IEventMiddleware {
public:
    virtual ~IEventMiddleware() = default;
    
    /**
     * @brief Process event before handlers
     * @param event_name Event name
     * @param event_data Event data
     * @param next Next middleware in chain
     * @return True if event should continue processing
     */
    virtual bool process(const std::string& event_name, 
                      const nlohmann::json& event_data, 
                      std::function<void()> next) = 0;
    
    /**
     * @brief Get middleware priority
     * @return Priority value (higher = earlier execution)
     */
    virtual int get_priority() const { return 0; }
    
    /**
     * @brief Get middleware name
     * @return Middleware identifier
     */
    virtual std::string get_name() const = 0;
};

/**
 * @brief Comprehensive Event Dispatcher for Discord.cpp
 * 
 * Provides advanced event handling with filters, collectors, middleware,
 * priority ordering, and performance monitoring.
 * 
 * @todo TODO.md: Implement comprehensive event system with collectors and filters
 */
class EventDispatcher {
public:
    using EventMap = std::unordered_map<std::string, std::vector<EventHandlerInfo>>;
    using MiddlewareList = std::vector<std::shared_ptr<IEventMiddleware>>;

private:
    EventMap handlers_;
    MiddlewareList middleware_;
    mutable std::shared_mutex handlers_mutex_;
    mutable std::shared_mutex middleware_mutex_;
    
    // Performance tracking
    std::atomic<uint64_t> events_dispatched_{0};
    std::atomic<uint64_t> handlers_executed_{0};
    std::chrono::steady_clock::time_point start_time_;
    
    // Active collectors tracking
    std::unordered_map<std::string, std::shared_ptr<void>> active_collectors_;
    mutable std::shared_mutex collectors_mutex_;

    /**
     * @brief Sort handlers by priority
     * @param handlers Vector of handlers to sort
     */
    void sort_handlers(std::vector<EventHandlerInfo>& handlers) const;

    /**
     * @brief Execute middleware chain
     * @param event_name Event name
     * @param event_data Event data
     * @param final_handler Final handler to execute
     */
    void execute_middleware_chain(const std::string& event_name,
                               const nlohmann::json& event_data,
                               std::function<void()> final_handler);

    /**
     * @brief Update performance statistics
     */
    void update_stats();

public:
    /**
     * @brief Construct EventDispatcher
     */
    EventDispatcher();

    /**
     * @brief Destructor - cleans up all handlers
     */
    ~EventDispatcher();

    /**
     * @brief Register event handler
     * @param event_name Event name to listen for
     * @param callback Handler function
     * @param priority Handler priority (higher = earlier)
     * @param handler_id Unique handler identifier
     * @param once Whether to remove after first execution
     * @return Handler ID for removal
     */
    std::string on(const std::string& event_name, 
                   EventCallback callback,
                   int priority = 0,
                   const std::string& handler_id = "",
                   bool once = false);

    /**
     * @brief Remove event handler
     * @param event_name Event name
     * @param handler_id Handler ID to remove
     * @return True if handler was removed
     */
    bool off(const std::string& event_name, const std::string& handler_id);

    /**
     * @brief Remove all handlers for event
     * @param event_name Event name
     * @return Number of handlers removed
     */
    size_t off_all(const std::string& event_name);

    /**
     * @brief Emit event to all handlers
     * @param event_name Event name
     * @param event_data Event data
     */
    void emit(const std::string& event_name, const nlohmann::json& event_data);

    /**
     * @brief Emit event with filters
     * @param event_name Event name
     * @param event_data Event data
     * @param filters Vector of filter functions
     */
    void emit_filtered(const std::string& event_name,
                     const nlohmann::json& event_data,
                     const std::vector<EventFilter>& filters);

    /**
     * @brief Wait for specific event
     * @param event_name Event name to wait for
     * @param filter Filter function
     * @param timeout Maximum wait time
     * @return Matching event data or empty optional
     */
    std::optional<nlohmann::json> wait_for(const std::string& event_name,
                                           EventFilter filter = nullptr,
                                           std::chrono::milliseconds timeout = std::chrono::milliseconds(30000));

    /**
     * @brief Create event collector
     * @tparam T Type to collect
     * @param event_name Event name to collect
     * @param filter Filter function
     * @param config Collector configuration
     * @return Shared pointer to collector
     */
    template<typename T>
    std::shared_ptr<EventCollector<T>> create_collector(const std::string& event_name,
                                                    typename EventCollector<T>::FilterFunction filter = nullptr,
                                                    const CollectorConfig& config = CollectorConfig{});

    /**
     * @brief Add middleware
     * @param middleware Middleware to add
     */
    void add_middleware(std::shared_ptr<IEventMiddleware> middleware);

    /**
     * @brief Remove middleware
     * @param middleware_name Name of middleware to remove
     * @return True if middleware was removed
     */
    bool remove_middleware(const std::string& middleware_name);

    /**
     * @brief Get all handlers for event
     * @param event_name Event name
     * @return Vector of handler information
     */
    std::vector<EventHandlerInfo> get_handlers(const std::string& event_name) const;

    /**
     * @brief Get performance statistics
     * @return JSON object with statistics
     */
    nlohmann::json get_statistics() const;

    /**
     * @brief Reset performance statistics
     */
    void reset_statistics();

    /**
     * @brief Handle Discord gateway dispatch
     * @param payload Gateway payload
     */
    void handle_dispatch(const nlohmann::json& payload);

    /**
     * @brief Get number of registered handlers
     * @return Total handler count
     */
    size_t get_handler_count() const;

    /**
     * @brief Get number of active collectors
     * @return Active collector count
     */
    size_t get_active_collector_count() const;

    /**
     * @brief Clear all handlers and collectors
     */
    void clear();
};

/**
 * @brief Built-in event filters
 */
namespace EventFilters {
    /**
     * @brief Filter by user ID
     * @param user_id User ID to match
     * @return Filter function
     */
    EventFilter by_user_id(const std::string& user_id);
    
    /**
     * @brief Filter by channel ID
     * @param channel_id Channel ID to match
     * @return Filter function
     */
    EventFilter by_channel_id(const std::string& channel_id);
    
    /**
     * @brief Filter by guild ID
     * @param guild_id Guild ID to match
     * @return Filter function
     */
    EventFilter by_guild_id(const std::string& guild_id);
    
    /**
     * @brief Filter by message content
     * @param content Content to match (supports wildcards)
     * @return Filter function
     */
    EventFilter by_content(const std::string& content);
    
    /**
     * @brief Filter by author bot status
     * @param is_bot Whether author should be a bot
     * @return Filter function
     */
    EventFilter by_bot(bool is_bot);
    
    /**
     * @brief Combine multiple filters with AND logic
     * @param filters Vector of filters to combine
     * @return Combined filter function
     */
    EventFilter and_filter(const std::vector<EventFilter>& filters);
    
    /**
     * @brief Combine multiple filters with OR logic
     * @param filters Vector of filters to combine
     * @return Combined filter function
     */
    EventFilter or_filter(const std::vector<EventFilter>& filters);
    
    /**
     * @brief Negate a filter
     * @param filter Filter to negate
     * @return Negated filter function
     */
    EventFilter not_filter(EventFilter filter);
}

/**
 * @brief Built-in middleware implementations
 */
namespace EventMiddleware {
    /**
     * @brief Rate limiting middleware
     */
    class RateLimiter : public IEventMiddleware {
    private:
        std::unordered_map<std::string, std::pair<int, std::chrono::steady_clock::time_point>> counters_;
        int max_events_per_window_;
        std::chrono::milliseconds window_size_;
        mutable std::shared_mutex mutex_;
        
    public:
        RateLimiter(int max_events = 100, std::chrono::milliseconds window = std::chrono::minutes(1));
        
        bool process(const std::string& event_name,
                   const nlohmann::json& event_data,
                   std::function<void()> next) override;
        
        int get_priority() const override { return 100; }
        std::string get_name() const override { return "RateLimiter"; }
    };
    
    /**
     * @brief Logging middleware
     */
    class Logger : public IEventMiddleware {
    private:
        std::vector<std::string> logged_events_;
        bool log_all_events_;
        
    public:
        explicit Logger(bool log_all = false);
        
        bool process(const std::string& event_name,
                   const nlohmann::json& event_data,
                   std::function<void()> next) override;
        
        int get_priority() const override { return -100; }
        std::string get_name() const override { return "Logger"; }
    };
    
    /**
     * @brief Event validation middleware
     */
    class Validator : public IEventMiddleware {
    private:
        std::unordered_map<std::string, std::function<bool(const nlohmann::json&)>> validators_;
        
    public:
        void add_validator(const std::string& event_name, std::function<bool(const nlohmann::json&)> validator);
        
        bool process(const std::string& event_name,
                   const nlohmann::json& event_data,
                   std::function<void()> next) override;
        
        int get_priority() const override { return 50; }
        std::string get_name() const override { return "Validator"; }
    };
}

} // namespace discord
=== END FILE ===

=== FILE: include/discord/events/event_handlers.h ===
#pragma once

#include <string>
#include <functional>
#include <unordered_map>
#include <vector>
#include <memory>
#include <nlohmann/json.hpp>
#include "event_dispatcher.h"

namespace discord {

/**
 * @brief Specific event handlers for Discord events
 * 
 * Provides typed handlers for common Discord events with proper
 * data structures and validation.
 * 
 * @todo TODO.md: Implement comprehensive event system with collectors and filters
 */
class EventHandlers {
public:
    // Message event handlers
    using MessageCallback = std::function<void(const nlohmann::json&)>;
    using MessageFilter = std::function<bool(const nlohmann::json&)>;
    
    // Reaction event handlers
    using ReactionCallback = std::function<void(const nlohmann::json&)>;
    
    // Guild event handlers
    using GuildCallback = std::function<void(const nlohmann::json&)>;
    
    // Member event handlers
    using MemberCallback = std::function<void(const nlohmann::json&)>;
    
    // Channel event handlers
    using ChannelCallback = std::function<void(const nlohmann::json&)>;
    
    // Voice event handlers
    using VoiceCallback = std::function<void(const nlohmann::json&)>;
    
    // Interaction event handlers
    using InteractionCallback = std::function<void(const nlohmann::json&)>;

private:
    EventDispatcher* dispatcher_;
    
    // Handler storage for cleanup
    std::vector<std::string> registered_handler_ids_;

    /**
     * @brief Register handler and store ID for cleanup
     * @param event_name Event name
     * @param callback Handler function
     * @param handler_id Handler ID
     * @return Registered handler ID
     */
    std::string register_handler(const std::string& event_name, 
                              std::function<void(const nlohmann::json&)> callback,
                              const std::string& handler_id = "");

public:
    /**
     * @brief Construct EventHandlers
     * @param dispatcher Event dispatcher to use
     */
    explicit EventHandlers(EventDispatcher* dispatcher);

    /**
     * @brief Destructor - cleans up all registered handlers
     */
    ~EventHandlers();

    // Message events
    /**
     * @brief Handle message creation
     * @param callback Handler function
     * @param filter Optional filter function
     * @return Handler ID
     */
    std::string on_message(MessageCallback callback, MessageFilter filter = nullptr);
    
    /**
     * @brief Handle message update
     * @param callback Handler function
     * @param filter Optional filter function
     * @return Handler ID
     */
    std::string on_message_update(MessageCallback callback, MessageFilter filter = nullptr);
    
    /**
     * @brief Handle message deletion
     * @param callback Handler function
     * @param filter Optional filter function
     * @return Handler ID
     */
    std::string on_message_delete(MessageCallback callback, MessageFilter filter = nullptr);
    
    /**
     * @brief Handle message bulk delete
     * @param callback Handler function
     * @return Handler ID
     */
    std::string on_message_bulk_delete(MessageCallback callback);

    // Reaction events
    /**
     * @brief Handle reaction addition
     * @param callback Handler function
     * @param filter Optional filter function
     * @return Handler ID
     */
    std::string on_reaction_add(ReactionCallback callback, MessageFilter filter = nullptr);
    
    /**
     * @brief Handle reaction removal
     * @param callback Handler function
     * @param filter Optional filter function
     * @return Handler ID
     */
    std::string on_reaction_remove(ReactionCallback callback, MessageFilter filter = nullptr);
    
    /**
     * @brief Handle reaction clear
     * @param callback Handler function
     * @param filter Optional filter function
     * @return Handler ID
     */
    std::string on_reaction_clear(ReactionCallback callback, MessageFilter filter = nullptr);

    // Guild events
    /**
     * @brief Handle guild creation
     * @param callback Handler function
     * @return Handler ID
     */
    std::string on_guild_create(GuildCallback callback);
    
    /**
     * @brief Handle guild update
     * @param callback Handler function
     * @return Handler ID
     */
    std::string on_guild_update(GuildCallback callback);
    
    /**
     * @brief Handle guild deletion
     * @param callback Handler function
     * @return Handler ID
     */
    std::string on_guild_delete(GuildCallback callback);

    // Member events
    /**
     * @brief Handle member join
     * @param callback Handler function
     * @param filter Optional filter function
     * @return Handler ID
     */
    std::string on_member_join(MemberCallback callback, MessageFilter filter = nullptr);
    
    /**
     * @brief Handle member leave
     * @param callback Handler function
     * @param filter Optional filter function
     * @return Handler ID
     */
    std::string on_member_remove(MemberCallback callback, MessageFilter filter = nullptr);
    
    /**
     * @brief Handle member update
     * @param callback Handler function
     * @return Handler ID
     */
    std::string on_member_update(MemberCallback callback);

    // Channel events
    /**
     * @brief Handle channel creation
     * @param callback Handler function
     * @return Handler ID
     */
    std::string on_channel_create(ChannelCallback callback);
    
    /**
     * @brief Handle channel update
     * @param callback Handler function
     * @return Handler ID
     */
    std::string on_channel_update(ChannelCallback callback);
    
    /**
     * @brief Handle channel deletion
     * @param callback Handler function
     * @return Handler ID
     */
    std::string on_channel_delete(ChannelCallback callback);

    // Voice events
    /**
     * @brief Handle voice state update
     * @param callback Handler function
     * @return Handler ID
     */
    std::string on_voice_state_update(VoiceCallback callback);

    // Interaction events
    /**
     * @brief Handle interaction creation
     * @param callback Handler function
     * @param filter Optional filter function
     * @return Handler ID
     */
    std::string on_interaction_create(InteractionCallback callback, MessageFilter filter = nullptr);

    /**
     * @brief Remove all registered handlers
     */
    void clear_all();

    /**
     * @brief Get number of registered handlers
     * @return Total handler count
     */
    size_t get_handler_count() const;

    /**
     * @brief Create message collector
     * @param filter Filter function
     * @param config Collector configuration
     * @return Shared pointer to message collector
     */
    std::shared_ptr<EventCollector<nlohmann::json>> create_message_collector(
        EventFilter filter = nullptr,
        const CollectorConfig& config = CollectorConfig{});

    /**
     * @brief Create reaction collector
     * @param filter Filter function
     * @param config Collector configuration
     * @return Shared pointer to reaction collector
     */
    std::shared_ptr<EventCollector<nlohmann::json>> create_reaction_collector(
        EventFilter filter = nullptr,
        const CollectorConfig& config = CollectorConfig{});
};

/**
 * @brief Event handler utilities
 */
namespace EventUtils {
    /**
     * @brief Extract message ID from event
     * @param event Event data
     * @return Message ID or empty string
     */
    std::string extract_message_id(const nlohmann::json& event);
    
    /**
     * @brief Extract channel ID from event
     * @param event Event data
     * @return Channel ID or empty string
     */
    std::string extract_channel_id(const nlohmann::json& event);
    
    /**
     * @brief Extract guild ID from event
     * @param event Event data
     * @return Guild ID or empty string
     */
    std::string extract_guild_id(const nlohmann::json& event);
    
    /**
     * @brief Extract user ID from event
     * @param event Event data
     * @return User ID or empty string
     */
    std::string extract_user_id(const nlohmann::json& event);
    
    /**
     * @brief Check if event is from a bot
     * @param event Event data
     * @return True if author is a bot
     */
    bool is_bot_message(const nlohmann::json& event);
    
    /**
     * @brief Check if message mentions user
     * @param event Message event
     * @param user_id User ID to check
     * @return True if user is mentioned
     */
    bool mentions_user(const nlohmann::json& event, const std::string& user_id);
    
    /**
     * @brief Check if message is in specified channel
     * @param event Message event
     * @param channel_id Channel ID to check
     * @return True if message is in channel
     */
    bool is_in_channel(const nlohmann::json& event, const std::string& channel_id);
    
    /**
     * @brief Check if message is in specified guild
     * @param event Message event
     * @param guild_id Guild ID to check
     * @return True if message is in guild
     */
    bool is_in_guild(const nlohmann::json& event, const std::string& guild_id);
}

} // namespace discord
=== END FILE ===

=== FILE: include/discord/events/middleware.h ===
#pragma once

#include <string>
#include <functional>
#include <vector>
#include <memory>
#include <nlohmann/json.hpp>
#include "event_dispatcher.h"

namespace discord {

/**
 * @brief Event middleware for processing events before handlers
 * 
 * Provides a chain of middleware that can modify, validate,
 * or block events before they reach the main handlers.
 * 
 * @todo TODO.md: Implement comprehensive event system with collectors and filters
 */
class EventMiddleware {
public:
    /**
     * @brief Middleware processing function
     * @param event_name Event name
     * @param event_data Event data
     * @param next Next middleware in chain
     * @return True if event should continue processing
     */
    using MiddlewareFunction = std::function<bool(const std::string&,
                                                   const nlohmann::json&,
                                                   std::function<void()>)>;

private:
    std::vector<std::shared_ptr<IEventMiddleware>> middleware_;
    mutable std::shared_mutex mutex_;

    /**
     * @brief Sort middleware by priority
     */
    void sort_middleware();

public:
    /**
     * @brief Construct EventMiddleware
     */
    EventMiddleware();

    /**
     * @brief Destructor
     */
    ~EventMiddleware();

    /**
     * @brief Add middleware to chain
     * @param middleware Middleware to add
     */
    void add_middleware(std::shared_ptr<IEventMiddleware> middleware);

    /**
     * @brief Remove middleware from chain
     * @param middleware_name Name of middleware to remove
     * @return True if middleware was removed
     */
    bool remove_middleware(const std::string& middleware_name);

    /**
     * @brief Process event through middleware chain
     * @param event_name Event name
     * @param event_data Event data
     * @param final_handler Final handler to execute
     */
    void process_event(const std::string& event_name,
                     const nlohmann::json& event_data,
                     std::function<void()> final_handler);

    /**
     * @brief Get all middleware
     * @return Vector of middleware
     */
    std::vector<std::shared_ptr<IEventMiddleware>> get_middleware() const;

    /**
     * @brief Clear all middleware
     */
    void clear();
};

/**
 * @brief Built-in middleware implementations
 */
namespace BuiltInMiddleware {

    /**
     * @brief Authentication middleware
     * 
     * Validates that events contain proper authentication data
     * and filters out unauthorized events.
     */
    class Authentication : public IEventMiddleware {
    private:
        std::string bot_token_;
        bool require_user_id_;
        
    public:
        explicit Authentication(const std::string& token, bool require_user_id = false);
        
        bool process(const std::string& event_name,
                   const nlohmann::json& event_data,
                   std::function<void()> next) override;
        
        int get_priority() const override { return 90; }
        std::string get_name() const override { return "Authentication"; }
    };

    /**
     * @brief Permission checking middleware
     * 
     * Validates that events have required permissions
     * and filters out unauthorized actions.
     */
    class PermissionChecker : public IEventMiddleware {
    private:
        std::unordered_map<std::string, uint64_t> required_permissions_;
        
    public:
        explicit PermissionChecker(const std::unordered_map<std::string, uint64_t>& permissions);
        
        bool process(const std::string& event_name,
                   const nlohmann::json& event_data,
                   std::function<void()> next) override;
        
        int get_priority() const override { return 80; }
        std::string get_name() const override { return "PermissionChecker"; }
    };

    /**
     * @brief Event transformation middleware
     * 
     * Transforms event data before it reaches handlers.
     * Useful for data normalization or enrichment.
     */
    class Transformer : public IEventMiddleware {
    private:
        std::unordered_map<std::string, std::function<nlohmann::json(nlohmann::json)>> transformers_;
        
    public:
        explicit Transformer(const std::unordered_map<std::string, 
                                             std::function<nlohmann::json(nlohmann::json)>>& transformers);
        
        bool process(const std::string& event_name,
                   const nlohmann::json& event_data,
                   std::function<void()> next) override;
        
        int get_priority() const override { return 60; }
        std::string get_name() const override { return "Transformer"; }
    };

    /**
     * @brief Event filtering middleware
     * 
     * Filters events based on configurable criteria.
     * Can filter by user, channel, guild, content, etc.
     */
    class Filter : public IEventMiddleware {
    private:
        std::vector<EventFilter> filters_;
        std::string filter_mode_; // "any" or "all"
        
    public:
        explicit Filter(const std::vector<EventFilter>& filters, const std::string& mode = "all");
        
        bool process(const std::string& event_name,
                   const nlohmann::json& event_data,
                   std::function<void()> next) override;
        
        int get_priority() const override { return 70; }
        std::string get_name() const override { return "Filter"; }
    };

    /**
     * @brief Event caching middleware
     * 
     * Caches events to prevent duplicate processing
     * and provides event replay capabilities.
     */
    class Cache : public IEventMiddleware {
    private:
        std::unordered_map<std::string, std::vector<nlohmann::json>> event_cache_;
        size_t max_cache_size_;
        std::chrono::milliseconds cache_ttl_;
        mutable std::shared_mutex mutex_;
        
        /**
         * @brief Clean expired cache entries
         */
        void cleanup_cache();
        
    public:
        explicit Cache(size_t max_size = 1000, 
                     std::chrono::milliseconds ttl = std::chrono::minutes(5));
        
        bool process(const std::string& event_name,
                   const nlohmann::json& event_data,
                   std::function<void()> next) override;
        
        int get_priority() const override { return 40; }
        std::string get_name() const override { return "Cache"; }
        
        /**
         * @brief Get cached events for event type
         * @param event_name Event name
         * @return Cached events
         */
        std::vector<nlohmann::json> get_cached_events(const std::string& event_name) const;
        
        /**
         * @brief Clear cache for event type
         * @param event_name Event name
         */
        void clear_cache(const std::string& event_name);
    };

    /**
     * @brief Event metrics middleware
     * 
     * Collects metrics about events passing through
     * including counts, timing, and error tracking.
     */
    class Metrics : public IEventMiddleware {
    private:
        std::unordered_map<std::string, uint64_t> event_counts_;
        std::unordered_map<std::string, std::chrono::steady_clock::time_point> last_event_times_;
        std::unordered_map<std::string, uint64_t> error_counts_;
        mutable std::shared_mutex mutex_;
        
    public:
        Metrics() = default;
        
        bool process(const std::string& event_name,
                   const nlohmann::json& event_data,
                   std::function<void()> next) override;
        
        int get_priority() const override { return -50; } // Low priority to run last
        std::string get_name() const override { return "Metrics"; }
        
        /**
         * @brief Get event statistics
         * @return JSON object with metrics
         */
        nlohmann::json get_metrics() const;
        
        /**
         * @brief Reset metrics
         */
        void reset_metrics();
    };

    /**
     * @brief Event debugging middleware
     * 
     * Logs detailed information about events for debugging.
     * Can be configured to log only specific event types.
     */
    class Debugger : public IEventMiddleware {
    private:
        std::vector<std::string> debug_events_;
        bool log_all_events_;
        bool include_stack_trace_;
        
    public:
        explicit Debugger(const std::vector<std::string>& events = {}, 
                        bool log_all = false,
                        bool include_stack = false);
        
        bool process(const std::string& event_name,
                   const nlohmann::json& event_data,
                   std::function<void()> next) override;
        
        int get_priority() const override { return -100; } // Very low priority
        std::string get_name() const override { return "Debugger"; }
    };
};

/**
 * @brief Middleware factory for creating common middleware
 */
class MiddlewareFactory {
public:
    /**
     * @brief Create authentication middleware
     * @param token Bot token
     * @param require_user_id Whether to require user ID validation
     * @return Shared pointer to authentication middleware
     */
    static std::shared_ptr<BuiltInMiddleware::Authentication> create_authentication(
        const std::string& token,
        bool require_user_id = false);

    /**
     * @brief Create permission checker middleware
     * @param permissions Required permissions map
     * @return Shared pointer to permission middleware
     */
    static std::shared_ptr<BuiltInMiddleware::PermissionChecker> create_permission_checker(
        const std::unordered_map<std::string, uint64_t>& permissions);

    /**
     * @brief Create transformer middleware
     * @param transformers Event transformation functions
     * @return Shared pointer to transformer middleware
     */
    static std::shared_ptr<BuiltInMiddleware::Transformer> create_transformer(
        const std::unordered_map<std::string, std::function<nlohmann::json(nlohmann::json)>>& transformers);

    /**
     * @brief Create filter middleware
     * @param filters Filter functions
     * @param mode Filter mode ("any" or "all")
     * @return Shared pointer to filter middleware
     */
    static std::shared_ptr<BuiltInMiddleware::Filter> create_filter(
        const std::vector<EventFilter>& filters,
        const std::string& mode = "all");

    /**
     * @brief Create cache middleware
     * @param max_size Maximum cache size
     * @param ttl Cache TTL
     * @return Shared pointer to cache middleware
     */
    static std::shared_ptr<BuiltInMiddleware::Cache> create_cache(
        size_t max_size = 1000,
        std::chrono::milliseconds ttl = std::chrono::minutes(5));

    /**
     * @brief Create metrics middleware
     * @return Shared pointer to metrics middleware
     */
    static std::shared_ptr<BuiltInMiddleware::Metrics> create_metrics();

    /**
     * @brief Create debugger middleware
     * @param events Events to debug
     * @param log_all Whether to log all events
     * @param include_stack Whether to include stack traces
     * @return Shared pointer to debugger middleware
     */
    static std::shared_ptr<BuiltInMiddleware::Debugger> create_debugger(
        const std::vector<std::string>& events = {},
        bool log_all = false,
        bool include_stack = false);
};

} // namespace discord
=== END FILE ===

=== FILE: include/discord/commands.h ===
#pragma once

/**
 * @file commands.h
 * @brief Commands module for command handling and management
 */

#include "config.h"
#include "commands/command_manager.h"

namespace discord::commands {
    // Re-export commonly used types
    using discord::CommandManager;
} // namespace discord::commands

=== END FILE ===

=== FILE: include/discord/commands/command_manager.h ===
#pragma once

#include "../utils/types.h"
#include <functional>
#include <vector>
#include <string>
#include <memory>
#include <future>
#include <unordered_map>
#include <mutex>
#include <chrono>
#include <nlohmann/json.hpp>

namespace discord {

// Forward declarations
class DiscordClient;
class ILogger;

// Command context for execution
struct CommandContext {
    User author;
    Channel channel;
    std::optional<Guild> guild;
    std::string content;
    std::vector<std::string> args;
    std::string message_id;
    DiscordClient* client;
    
    CommandContext(DiscordClient* client) : client(client) {}
};

// Command option types for slash commands
enum class CommandOptionType {
    SUB_COMMAND = 1,
    SUB_COMMAND_GROUP = 2,
    STRING = 3,
    INTEGER = 4,
    BOOLEAN = 5,
    USER = 6,
    CHANNEL = 7,
    ROLE = 8,
    MENTIONABLE = 9,
    NUMBER = 10,
    ATTACHMENT = 11
};

// Command option structure
struct CommandOption {
    CommandOptionType type;
    std::string name;
    std::string description;
    bool required;
    std::vector<CommandOption> choices;
    std::vector<CommandOption> options;
    
    CommandOption(CommandOptionType t, const std::string& n, const std::string& desc, bool req = false)
        : type(t), name(n), description(desc), required(req) {}
};

// Command interface
class ICommand {
public:
    virtual ~ICommand() = default;
    virtual void execute(const CommandContext& ctx) = 0;
    virtual std::string get_name() const = 0;
    virtual std::string get_description() const = 0;
    virtual std::vector<std::string> get_aliases() const = 0;
    virtual std::vector<CommandOption> get_options() const = 0;
    virtual int get_permissions() const { return 0; }
    virtual bool is_nsfw() const { return false; }
    virtual bool can_use_in_dm() const { return true; }
};

// Middleware interface
class IMiddleware {
public:
    virtual ~IMiddleware() = default;
    virtual std::future<bool> before(const CommandContext& ctx) = 0;
    virtual std::future<void> after(const CommandContext& ctx, bool success) = 0;
    virtual int get_priority() const { return 0; }
};

// Command manager
class CommandManager {
private:
    std::unordered_map<std::string, std::unique_ptr<ICommand>> commands_;
    std::vector<std::unique_ptr<IMiddleware>> middleware_;
    std::string prefix_;
    DiscordClient* client_;
    
public:
    explicit CommandManager(DiscordClient* client, const std::string& prefix = "!");
    ~CommandManager() = default;
    
    void register_command(std::unique_ptr<ICommand> command);
    void unregister_command(const std::string& name);
    void add_middleware(std::unique_ptr<IMiddleware> middleware);
    
    void handle_message(const Message& message);
    void handle_interaction(const nlohmann::json& interaction);
    
    ICommand* get_command(const std::string& name) const;
    std::vector<std::string> get_command_names() const;
    
    void set_prefix(const std::string& prefix);
    const std::string& get_prefix() const;
    
    // Slash command registration
    std::future<void> register_slash_commands(const std::string& guild_id = "");
    nlohmann::json create_slash_command_json(const ICommand& command) const;
    
private:
    std::vector<std::string> parse_args(const std::string& content, const std::string& prefix) const;
    std::string find_command(const std::string& name) const;
    std::future<bool> execute_middleware_before(const CommandContext& ctx);
    std::future<void> execute_middleware_after(const CommandContext& ctx, bool success);
};

// Built-in middleware classes
class CooldownMiddleware : public IMiddleware {
private:
    std::unordered_map<std::string, std::chrono::system_clock::time_point> cooldowns_;
    std::chrono::seconds cooldown_duration_;
    mutable std::mutex mutex_;
    
public:
    explicit CooldownMiddleware(std::chrono::seconds duration);
    std::future<bool> before(const CommandContext& ctx) override;
    std::future<void> after(const CommandContext& ctx, bool success) override;
};

class PermissionMiddleware : public IMiddleware {
public:
    std::future<bool> before(const CommandContext& ctx) override;
    std::future<void> after(const CommandContext& ctx, bool success) override;
};

class LoggingMiddleware : public IMiddleware {
private:
    ILogger* logger_;
    
public:
    explicit LoggingMiddleware(ILogger* logger);
    std::future<bool> before(const CommandContext& ctx) override;
    std::future<void> after(const CommandContext& ctx, bool success) override;
};

} // namespace discord
=== END FILE ===

=== FILE: include/discord/components/component_base.h ===
/**
 * @file component_base.h
 * @brief Base interfaces and abstract classes for Discord components
 * 
 * This file defines the fundamental interfaces that all components must implement,
 * providing a consistent API across all component types.
 */

#pragma once

#include <string>
#include <vector>
#include <memory>
#include <map>
#include <variant>
#include <functional>
#include <nlohmann/json.hpp>

namespace discord::components {

    /**
     * @brief Component type enumeration
     */
    enum class ComponentType {
        ACTION_ROW = 1,
        BUTTON = 2,
        STRING_SELECT = 3,
        TEXT_INPUT = 4,
        USER_SELECT = 5,
        ROLE_SELECT = 6,
        MENTIONABLE_SELECT = 7,
        CHANNEL_SELECT = 8,
        SECTION = 9,
        CONTAINER = 10,
        TEXT_DISPLAY = 11,
        THUMBNAIL = 12,
        MEDIA_GALLERY = 13,
        FILE = 14,
        SEPARATOR = 15,
        LABEL = 16
    };

    /**
     * @brief Button style enumeration
     */
    enum class ButtonStyle {
        PRIMARY = 1,      // Blue
        SECONDARY = 2,    // Gray
        SUCCESS = 3,      // Green
        DANGER = 4,       // Red
        LINK = 5,         // Gray, navigates to URL
        PREMIUM = 6       // Requires premium subscription
    };

    /**
     * @brief Text input style enumeration
     */
    enum class TextInputStyle {
        SHORT = 1,        // Single line
        PARAGRAPH = 2     // Multi-line
    };

    /**
     * @brief Base interface for all components
     */
    class IComponent {
    public:
        virtual ~IComponent() = default;
        
        /**
         * @brief Get the component type
         */
        virtual ComponentType get_type() const = 0;
        
        /**
         * @brief Convert component to JSON
         */
        virtual nlohmann::json to_json() const = 0;
        
        /**
         * @brief Validate component configuration
         */
        virtual bool validate() const = 0;
        
        /**
         * @brief Get component's custom ID (if applicable)
         */
        virtual std::string get_custom_id() const { return ""; }
        
        /**
         * @brief Check if component is disabled
         */
        virtual bool is_disabled() const { return false; }
        
        /**
         * @brief Clone component
         */
        virtual std::unique_ptr<IComponent> clone() const = 0;
    };

    /**
     * @brief Base class for interactive components (buttons, select menus, text inputs)
     */
    class InteractiveComponent : public IComponent {
    protected:
        std::string custom_id_;
        bool disabled_ = false;
        
    public:
        InteractiveComponent(const std::string& custom_id, bool disabled = false)
            : custom_id_(custom_id), disabled_(disabled) {}
        
        virtual ~InteractiveComponent() = default;
        
        std::string get_custom_id() const override { return custom_id_; }
        bool is_disabled() const override { return disabled_; }
        
        void set_custom_id(const std::string& custom_id) { custom_id_ = custom_id; }
        void set_disabled(bool disabled) { disabled_ = disabled; }
    };

    /**
     * @brief Base class for container components (action rows, sections, containers)
     */
    class ContainerComponent : public IComponent {
    protected:
        std::vector<std::shared_ptr<IComponent>> components_;
        
    public:
        ContainerComponent(const std::vector<std::shared_ptr<IComponent>>& components = {})
            : components_(components) {}
        
        virtual ~ContainerComponent() = default;
        
        void add_component(std::shared_ptr<IComponent> component) {
            components_.push_back(component);
        }
        
        void remove_component(size_t index) {
            if (index < components_.size()) {
                components_.erase(components_.begin() + index);
            }
        }
        
        const std::vector<std::shared_ptr<IComponent>>& get_components() const {
            return components_;
        }
        
        size_t component_count() const { return components_.size(); }
        
        bool empty() const { return components_.empty(); }
    };

    /**
     * @brief Component validation result
     */
    struct ValidationResult {
        bool valid;
        std::vector<std::string> errors;
        std::vector<std::string> warnings;
        
        ValidationResult() : valid(true) {}
        
        void add_error(const std::string& error) {
            errors.push_back(error);
            valid = false;
        }
        
        void add_warning(const std::string& warning) {
            warnings.push_back(warning);
        }
    };

    /**
     * @brief Component event handler types
     */
    using ComponentHandler = std::function<void(const nlohmann::json&)>;
    using ButtonHandler = std::function<void(const std::string& custom_id, const nlohmann::json& interaction)>;
    using SelectHandler = std::function<void(const std::string& custom_id, const std::vector<std::string>& values, const nlohmann::json& interaction)>;
    using TextInputHandler = std::function<void(const std::string& custom_id, const std::string& value, const nlohmann::json& interaction)>;

} // namespace discord::components
=== END FILE ===

=== FILE: include/discord/components/action_row.h ===
/**
 * @file action_row.h
 * @brief Action row container component
 * 
 * Provides action row containers for organizing interactive components.
 */

#pragma once

#include "component_base.h"
#include "button.h"
#include "select_menu.h"
#include "text_input.h"

namespace discord::components {

    /**
     * @brief Action row container component
     * 
     * Action rows are containers that can hold up to 5 components.
     * For buttons, action rows can only contain buttons.
     * For other components, action rows can contain any mix of components.
     */
    class ActionRow : public ContainerComponent {
    public:
        /**
         * @brief Constructor
         */
        ActionRow(const std::vector<std::shared_ptr<IComponent>>& components = {});

        ~ActionRow() override = default;

        // IComponent interface
        ComponentType get_type() const override { return ComponentType::ACTION_ROW; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        // ActionRow specific methods
        bool can_add_component(std::shared_ptr<IComponent> component) const;
        bool is_button_only() const;
        bool is_full() const { return components_.size() >= 5; }

        // Static factory method
        static std::unique_ptr<ActionRow> create(const std::vector<std::shared_ptr<IComponent>>& components = {});

        // Convenience factory methods
        static std::unique_ptr<ActionRow> with_buttons(const std::vector<std::shared_ptr<Button>>& buttons);
        static std::unique_ptr<ActionRow> with_selects(const std::vector<std::shared_ptr<SelectMenu>>& selects);
        static std::unique_ptr<ActionRow> with_text_inputs(const std::vector<std::shared_ptr<TextInput>>& text_inputs);
    };

} // namespace discord::components
=== END FILE ===

=== FILE: include/discord/components/button.h ===
/**
 * @file button.h
 * @brief Button component implementation
 * 
 * Provides button components with various styles and behaviors.
 */

#pragma once

#include "component_base.h"
#include <optional>

namespace discord::components {

    /**
     * @brief Button component class
     */
    class Button : public InteractiveComponent {
    private:
        ButtonStyle style_;
        std::string label_;
        std::optional<std::string> emoji_;
        std::optional<std::string> url_;
        bool disabled_ = false;

    public:
        /**
         * @brief Constructor for interactive button
         */
        Button(const std::string& label,
               ButtonStyle style = ButtonStyle::PRIMARY,
               const std::string& custom_id = "",
               const std::optional<std::string>& emoji = std::nullopt,
               bool disabled = false);

        /**
         * @brief Constructor for link button
         */
        Button(const std::string& label,
               const std::string& url,
               const std::optional<std::string>& emoji = std::nullopt,
               bool disabled = false);

        ~Button() override = default;

        // IComponent interface
        ComponentType get_type() const override { return ComponentType::BUTTON; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        // Button-specific methods
        void set_style(ButtonStyle style) { style_ = style; }
        ButtonStyle get_style() const { return style_; }

        void set_label(const std::string& label) { label_ = label; }
        const std::string& get_label() const { return label_; }

        void set_emoji(const std::optional<std::string>& emoji) { emoji_ = emoji; }
        const std::optional<std::string>& get_emoji() const { return emoji_; }

        void set_url(const std::optional<std::string>& url) { url_ = url; }
        const std::optional<std::string>& get_url() const { return url_; }

        bool is_link_button() const { return url_.has_value(); }

        // Static factory methods
        static std::unique_ptr<Button> primary(const std::string& label, 
                                              const std::string& custom_id = "",
                                              const std::optional<std::string>& emoji = std::nullopt);

        static std::unique_ptr<Button> secondary(const std::string& label,
                                                const std::string& custom_id = "",
                                                const std::optional<std::string>& emoji = std::nullopt);

        static std::unique_ptr<Button> success(const std::string& label,
                                              const std::string& custom_id = "",
                                              const std::optional<std::string>& emoji = std::nullopt);

        static std::unique_ptr<Button> danger(const std::string& label,
                                             const std::string& custom_id = "",
                                             const std::optional<std::string>& emoji = std::nullopt);

        static std::unique_ptr<Button> link(const std::string& label,
                                           const std::string& url,
                                           const std::optional<std::string>& emoji = std::nullopt);

        static std::unique_ptr<Button> premium(const std::string& label,
                                              const std::string& sku_id,
                                              const std::optional<std::string>& emoji = std::nullopt);
    };

} // namespace discord::components
=== END FILE ===

=== FILE: include/discord/components/select_menu.h ===
/**
 * @file select_menu.h
 * @brief Select menu component implementations
 * 
 * Provides various select menu types including string, user, role, channel, and mentionable selects.
 */

#pragma once

#include "component_base.h"
#include <optional>
#include <vector>

namespace discord::components {

    /**
     * @brief Select menu option for string selects
     */
    struct SelectOption {
        std::string label;
        std::string value;
        std::optional<std::string> description;
        std::optional<std::string> emoji;
        bool default_ = false;

        SelectOption(const std::string& label, const std::string& value,
                    const std::optional<std::string>& description = std::nullopt,
                    const std::optional<std::string>& emoji = std::nullopt,
                    bool default_ = false)
            : label(label), value(value), description(description), emoji(emoji), default_(default_) {}

        nlohmann::json to_json() const;
    };

    /**
     * @brief Base class for select menu components
     */
    class SelectMenu : public InteractiveComponent {
    protected:
        std::string placeholder_;
        std::vector<std::string> default_values_;
        int min_values_ = 1;
        int max_values_ = 1;

    public:
        SelectMenu(const std::string& custom_id,
                  const std::string& placeholder = "",
                  int min_values = 1,
                  int max_values = 1,
                  bool disabled = false);

        virtual ~SelectMenu() = default;

        // Common methods
        void set_placeholder(const std::string& placeholder) { placeholder_ = placeholder; }
        const std::string& get_placeholder() const { return placeholder_; }

        void set_min_values(int min_values) { min_values_ = min_values; }
        int get_min_values() const { return min_values_; }

        void set_max_values(int max_values) { max_values_ = max_values; }
        int get_max_values() const { return max_values_; }

        void set_default_values(const std::vector<std::string>& values) { default_values_ = values; }
        const std::vector<std::string>& get_default_values() const { return default_values_; }

        void add_default_value(const std::string& value) { default_values_.push_back(value); }
        void clear_default_values() { default_values_.clear(); }
    };

    /**
     * @brief String select menu component
     */
    class StringSelect : public SelectMenu {
    private:
        std::vector<SelectOption> options_;

    public:
        StringSelect(const std::string& custom_id,
                    const std::vector<SelectOption>& options = {},
                    const std::string& placeholder = "",
                    int min_values = 1,
                    int max_values = 25,
                    bool disabled = false);

        ~StringSelect() override = default;

        // IComponent interface
        ComponentType get_type() const override { return ComponentType::STRING_SELECT; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        // String select specific methods
        void add_option(const SelectOption& option);
        void remove_option(size_t index);
        void clear_options();
        
        const std::vector<SelectOption>& get_options() const { return options_; }
        size_t option_count() const { return options_.size(); }

        // Static factory method
        static std::unique_ptr<StringSelect> create(const std::string& custom_id,
                                                   const std::vector<SelectOption>& options = {},
                                                   const std::string& placeholder = "",
                                                   int min_values = 1,
                                                   int max_values = 25);
    };

    /**
     * @brief User select menu component
     */
    class UserSelect : public SelectMenu {
    public:
        UserSelect(const std::string& custom_id,
                  const std::string& placeholder = "",
                  int min_values = 1,
                  int max_values = 25,
                  bool disabled = false);

        ~UserSelect() override = default;

        // IComponent interface
        ComponentType get_type() const override { return ComponentType::USER_SELECT; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        // Static factory method
        static std::unique_ptr<UserSelect> create(const std::string& custom_id,
                                                 const std::string& placeholder = "",
                                                 int min_values = 1,
                                                 int max_values = 25);
    };

    /**
     * @brief Role select menu component
     */
    class RoleSelect : public SelectMenu {
    public:
        RoleSelect(const std::string& custom_id,
                  const std::string& placeholder = "",
                  int min_values = 1,
                  int max_values = 25,
                  bool disabled = false);

        ~RoleSelect() override = default;

        // IComponent interface
        ComponentType get_type() const override { return ComponentType::ROLE_SELECT; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        // Static factory method
        static std::unique_ptr<RoleSelect> create(const std::string& custom_id,
                                                 const std::string& placeholder = "",
                                                 int min_values = 1,
                                                 int max_values = 25);
    };

    /**
     * @brief Channel select menu component
     */
    class ChannelSelect : public SelectMenu {
    private:
        std::vector<std::string> channel_types_;

    public:
        ChannelSelect(const std::string& custom_id,
                     const std::vector<std::string>& channel_types = {},
                     const std::string& placeholder = "",
                     int min_values = 1,
                     int max_values = 25,
                     bool disabled = false);

        ~ChannelSelect() override = default;

        // IComponent interface
        ComponentType get_type() const override { return ComponentType::CHANNEL_SELECT; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        // Channel select specific methods
        void add_channel_type(const std::string& type);
        void remove_channel_type(const std::string& type);
        void clear_channel_types();
        
        const std::vector<std::string>& get_channel_types() const { return channel_types_; }

        // Static factory method
        static std::unique_ptr<ChannelSelect> create(const std::string& custom_id,
                                                   const std::vector<std::string>& channel_types = {},
                                                   const std::string& placeholder = "",
                                                   int min_values = 1,
                                                   int max_values = 25);
    };

    /**
     * @brief Mentionable select menu component (users and roles)
     */
    class MentionableSelect : public SelectMenu {
    public:
        MentionableSelect(const std::string& custom_id,
                         const std::string& placeholder = "",
                         int min_values = 1,
                         int max_values = 25,
                         bool disabled = false);

        ~MentionableSelect() override = default;

        // IComponent interface
        ComponentType get_type() const override { return ComponentType::MENTIONABLE_SELECT; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        // Static factory method
        static std::unique_ptr<MentionableSelect> create(const std::string& custom_id,
                                                        const std::string& placeholder = "",
                                                        int min_values = 1,
                                                        int max_values = 25);
    };

} // namespace discord::components
=== END FILE ===

=== FILE: include/discord/components/text_input.h ===
/**
 * @file text_input.h
 * @brief Text input component for modals
 * 
 * Provides text input components used in modal dialogs.
 */

#pragma once

#include "component_base.h"
#include <optional>

namespace discord::components {

    /**
     * @brief Text input component for modals
     */
    class TextInput : public InteractiveComponent {
    private:
        TextInputStyle style_;
        std::string label_;
        std::optional<std::string> value_;
        std::optional<std::string> placeholder_;
        bool required_ = false;
        int min_length_ = 0;
        int max_length_ = 4000;

    public:
        TextInput(const std::string& custom_id,
                 const std::string& label,
                 TextInputStyle style = TextInputStyle::SHORT,
                 const std::optional<std::string>& value = std::nullopt,
                 const std::optional<std::string>& placeholder = std::nullopt,
                 bool required = false,
                 int min_length = 0,
                 int max_length = 4000);

        ~TextInput() override = default;

        // IComponent interface
        ComponentType get_type() const override { return ComponentType::TEXT_INPUT; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        // TextInput specific methods
        void set_style(TextInputStyle style) { style_ = style; }
        TextInputStyle get_style() const { return style_; }

        void set_label(const std::string& label) { label_ = label; }
        const std::string& get_label() const { return label_; }

        void set_value(const std::optional<std::string>& value) { value_ = value; }
        const std::optional<std::string>& get_value() const { return value_; }

        void set_placeholder(const std::optional<std::string>& placeholder) { placeholder_ = placeholder; }
        const std::optional<std::string>& get_placeholder() const { return placeholder_; }

        void set_required(bool required) { required_ = required; }
        bool is_required() const { return required_; }

        void set_min_length(int min_length) { min_length_ = min_length; }
        int get_min_length() const { return min_length_; }

        void set_max_length(int max_length) { max_length_ = max_length; }
        int get_max_length() const { return max_length_; }

        // Static factory methods
        static std::unique_ptr<TextInput> short_text(const std::string& custom_id,
                                                    const std::string& label,
                                                    const std::optional<std::string>& value = std::nullopt,
                                                    const std::optional<std::string>& placeholder = std::nullopt,
                                                    bool required = false,
                                                    int min_length = 0,
                                                    int max_length = 4000);

        static std::unique_ptr<TextInput> paragraph(const std::string& custom_id,
                                                   const std::string& label,
                                                   const std::optional<std::string>& value = std::nullopt,
                                                   const std::optional<std::string>& placeholder = std::nullopt,
                                                   bool required = false,
                                                   int min_length = 0,
                                                   int max_length = 4000);

        static std::unique_ptr<TextInput> create(const std::string& custom_id,
                                                const std::string& label,
                                                TextInputStyle style = TextInputStyle::SHORT,
                                                const std::optional<std::string>& value = std::nullopt,
                                                const std::optional<std::string>& placeholder = std::nullopt,
                                                bool required = false,
                                                int min_length = 0,
                                                int max_length = 4000);
    };

} // namespace discord::components
=== END FILE ===

=== FILE: include/discord/components/component_builder.h ===
/**
 * @file component_builder.h
 * @brief Fluent builder pattern for creating components
 * 
 * Provides a fluent interface for building complex component layouts.
 */

#pragma once

#include "component_base.h"
#include "button.h"
#include "select_menu.h"
#include "text_input.h"
#include "action_row.h"
#include "section.h"
#include "container.h"
#include "content_display.h"
#include <memory>
#include <vector>
#include <functional>

namespace discord::components {

    /**
     * @brief Builder class for creating components with fluent interface
     */
    class ComponentBuilder {
    private:
        std::vector<std::shared_ptr<IComponent>> components_;
        std::shared_ptr<IComponent> current_component_;

    public:
        ComponentBuilder() = default;
        ~ComponentBuilder() = default;

        // Button builders
        ComponentBuilder& button(const std::string& label,
                                 const std::string& custom_id = "",
                                 const std::string& style = "primary");

        ComponentBuilder& primary_button(const std::string& label,
                                         const std::string& custom_id = "");

        ComponentBuilder& secondary_button(const std::string& label,
                                           const std::string& custom_id = "");

        ComponentBuilder& success_button(const std::string& label,
                                        const std::string& custom_id = "");

        ComponentBuilder& danger_button(const std::string& label,
                                       const std::string& custom_id = "");

        ComponentBuilder& link_button(const std::string& label,
                                      const std::string& url);

        ComponentBuilder& button_emoji(const std::string& emoji);
        ComponentBuilder& button_disabled(bool disabled = true);

        // Select menu builders
        ComponentBuilder& string_select(const std::string& custom_id,
                                       const std::vector<SelectOption>& options = {},
                                       const std::string& placeholder = "",
                                       int min_values = 1,
                                       int max_values = 25);

        ComponentBuilder& user_select(const std::string& custom_id,
                                       const std::string& placeholder = "",
                                       int min_values = 1,
                                       int max_values = 25);

        ComponentBuilder& role_select(const std::string& custom_id,
                                       const std::string& placeholder = "",
                                       int min_values = 1,
                                       int max_values = 25);

        ComponentBuilder& channel_select(const std::string& custom_id,
                                         const std::vector<std::string>& channel_types = {},
                                         const std::string& placeholder = "",
                                         int min_values = 1,
                                         int max_values = 25);

        ComponentBuilder& mentionable_select(const std::string& custom_id,
                                            const std::string& placeholder = "",
                                            int min_values = 1,
                                            int max_values = 25);

        ComponentBuilder& select_placeholder(const std::string& placeholder);
        ComponentBuilder& select_min_values(int min_values);
        ComponentBuilder& select_max_values(int max_values);
        ComponentBuilder& select_option(const std::string& label,
                                       const std::string& value,
                                       const std::string& description = "",
                                       const std::string& emoji = "",
                                       bool default_ = false);

        // Text input builders
        ComponentBuilder& text_input(const std::string& custom_id,
                                     const std::string& label,
                                     const std::string& style = "short",
                                     const std::string& value = "",
                                     const std::string& placeholder = "",
                                     bool required = false,
                                     int min_length = 0,
                                     int max_length = 4000);

        ComponentBuilder& short_text(const std::string& custom_id,
                                     const std::string& label,
                                     const std::string& value = "",
                                     const std::string& placeholder = "",
                                     bool required = false,
                                     int min_length = 0,
                                     int max_length = 4000);

        ComponentBuilder& paragraph_text(const std::string& custom_id,
                                        const std::string& label,
                                        const std::string& value = "",
                                        const std::string& placeholder = "",
                                        bool required = false,
                                        int min_length = 0,
                                        int max_length = 4000);

        ComponentBuilder& text_input_style(const std::string& style);
        ComponentBuilder& text_input_value(const std::string& value);
        ComponentBuilder& text_input_placeholder(const std::string& placeholder);
        ComponentBuilder& text_input_required(bool required = true);
        ComponentBuilder& text_input_min_length(int min_length);
        ComponentBuilder& text_input_max_length(int max_length);

        // Content display builders
        ComponentBuilder& text(const std::string& content);
        ComponentBuilder& thumbnail(const std::string& url,
                                    const std::string& alt_text = "",
                                    int width = 0,
                                    int height = 0);

        ComponentBuilder& media_gallery(const std::vector<std::string>& items,
                                        const std::string& alt_text = "");

        ComponentBuilder& file(const std::string& url,
                               const std::string& filename,
                               int size_bytes = 0);

        ComponentBuilder& separator(bool decorative = true, int spacing = 0);
        ComponentBuilder& label(const std::string& text,
                                 const std::string& for_component = "");

        // Container builders
        ComponentBuilder& action_row();
        ComponentBuilder& section(const std::string& text);
        ComponentBuilder& container();

        ComponentBuilder& add_to_current(std::shared_ptr<IComponent> component);
        ComponentBuilder& finish_current();

        // Layout operations
        ComponentBuilder& new_row();
        ComponentBuilder& new_section(const std::string& text = "");
        ComponentBuilder& new_container();

        // Building
        std::shared_ptr<IComponent> build();
        std::vector<std::shared_ptr<IComponent>> build_all();
        nlohmann::json build_json();

        // Utility methods
        ComponentBuilder& clear();
        ComponentBuilder& reset_current();

        // Static factory methods
        static ComponentBuilder create();
        static ComponentBuilder from_component(std::shared_ptr<IComponent> component);
        static ComponentBuilder from_components(const std::vector<std::shared_ptr<IComponent>>& components);

        // Callback-based building
        ComponentBuilder& with_button(const std::function<ComponentBuilder&(ComponentBuilder&)>& builder);
        ComponentBuilder& with_select(const std::function<ComponentBuilder&(ComponentBuilder&)>& builder);
        ComponentBuilder& with_text_input(const std::function<ComponentBuilder&(ComponentBuilder&)>& builder);
        ComponentBuilder& with_row(const std::function<ComponentBuilder&(ComponentBuilder&)>& builder);
        ComponentBuilder& with_section(const std::function<ComponentBuilder&(ComponentBuilder&)>& builder);
    };

    // Convenience functions
    ComponentBuilder buttons();
    ComponentBuilder selects();
    ComponentBuilder text_inputs();
    ComponentBuilder content();
    ComponentBuilder layout();

} // namespace discord::components
=== END FILE ===

=== FILE: include/discord/components/component_json.h ===
#pragma once

#include <memory>
#include <vector>
#include <string>
#include <nlohmann/json.hpp>
#include "../utils/types.h"

namespace discord::components {

    // Forward declarations
    class IComponent;
    class Button;
    class StringSelect;
    class UserSelect;
    class RoleSelect;
    class ChannelSelect;
    class MentionableSelect;
    class TextInput;
    class ActionRow;
    class Section;
    class Container;
    class TextDisplay;
    class Thumbnail;
    class MediaGallery;
    class File;
    class Separator;
    class Label;

    /**
     * @brief JSON serialization and deserialization utilities for Discord components
     */
    class ComponentJson {
    public:
        // Serialization methods
        static nlohmann::json serialize_component(const IComponent& component);
        static nlohmann::json serialize_components(const std::vector<std::shared_ptr<IComponent>>& components);

        // Deserialization methods
        static std::unique_ptr<IComponent> deserialize_component(const nlohmann::json& json);
        static std::vector<std::shared_ptr<IComponent>> deserialize_components(const nlohmann::json& json_array);

        // Type detection and validation
        static ComponentType detect_component_type(const nlohmann::json& json);
        static bool is_valid_component_json(const nlohmann::json& json);
        static ValidationResult validate_component_json(const nlohmann::json& json);

        // Error handling
        static std::string get_serialization_error(const nlohmann::json& json);
        static std::string get_deserialization_error(const nlohmann::json& json);

        // Pretty printing
        static std::string to_pretty_string(const IComponent& component);
        static std::string to_pretty_string(const std::vector<std::shared_ptr<IComponent>>& components);
        static std::string to_pretty_string(const nlohmann::json& json);

        // File I/O
        static bool save_component_to_file(const IComponent& component, const std::string& filepath);
        static bool save_components_to_file(const std::vector<std::shared_ptr<IComponent>>& components, const std::string& filepath);
        static std::unique_ptr<IComponent> load_component_from_file(const std::string& filepath);
        static std::vector<std::shared_ptr<IComponent>> load_components_from_file(const std::string& filepath);

    private:
        // Component-specific deserializers
        static std::unique_ptr<Button> deserialize_button(const nlohmann::json& json);
        static std::unique_ptr<StringSelect> deserialize_string_select(const nlohmann::json& json);
        static std::unique_ptr<UserSelect> deserialize_user_select(const nlohmann::json& json);
        static std::unique_ptr<RoleSelect> deserialize_role_select(const nlohmann::json& json);
        static std::unique_ptr<ChannelSelect> deserialize_channel_select(const nlohmann::json& json);
        static std::unique_ptr<MentionableSelect> deserialize_mentionable_select(const nlohmann::json& json);
        static std::unique_ptr<TextInput> deserialize_text_input(const nlohmann::json& json);
        static std::unique_ptr<ActionRow> deserialize_action_row(const nlohmann::json& json);
        static std::unique_ptr<Section> deserialize_section(const nlohmann::json& json);
        static std::unique_ptr<Container> deserialize_container(const nlohmann::json& json);
        static std::unique_ptr<TextDisplay> deserialize_text_display(const nlohmann::json& json);
        static std::unique_ptr<Thumbnail> deserialize_thumbnail(const nlohmann::json& json);
        static std::unique_ptr<MediaGallery> deserialize_media_gallery(const nlohmann::json& json);
        static std::unique_ptr<File> deserialize_file(const nlohmann::json& json);
        static std::unique_ptr<Separator> deserialize_separator(const nlohmann::json& json);
        static std::unique_ptr<Label> deserialize_label(const nlohmann::json& json);
    };

} // namespace discord::components
=== END FILE ===

=== FILE: include/discord/components/component_utils.h ===
/**
 * @file component_utils.h
 * @brief Utility functions and helpers for components
 * 
 * Provides various utility functions for working with components.
 */

#pragma once

#include "component_base.h"
#include "button.h"
#include "select_menu.h"
#include "text_input.h"
#include "action_row.h"
#include "section.h"
#include "container.h"
#include "content_display.h"
#include <vector>
#include <string>
#include <optional>
#include <functional>
#include <map>

namespace discord::components {

    /**
     * @brief Utility functions for component operations
     */
    class ComponentUtils {
    public:
        // Component type utilities
        static std::string component_type_to_string(ComponentType type);
        static ComponentType string_to_component_type(const std::string& type_str);
        static std::vector<ComponentType> get_all_component_types();
        static bool is_interactive_type(ComponentType type);
        static bool is_container_type(ComponentType type);
        static bool is_content_type(ComponentType type);
        
        // Button style utilities
        static std::string button_style_to_string(ButtonStyle style);
        static ButtonStyle string_to_button_style(const std::string& style_str);
        static std::vector<ButtonStyle> get_all_button_styles();
        
        // Text input style utilities
        static std::string text_input_style_to_string(TextInputStyle style);
        static TextInputStyle string_to_text_input_style(const std::string& style_str);
        static std::vector<TextInputStyle> get_all_text_input_styles();
        
        // Component search and filtering
        static std::vector<std::shared_ptr<IComponent>> find_components_by_type(
            const std::vector<std::shared_ptr<IComponent>>& components,
            ComponentType type);
        
        static std::vector<std::shared_ptr<IComponent>> find_components_by_custom_id(
            const std::vector<std::shared_ptr<IComponent>>& components,
            const std::string& custom_id);
        
        static std::shared_ptr<IComponent> find_component_by_custom_id(
            const std::vector<std::shared_ptr<IComponent>>& components,
            const std::string& custom_id);
        
        static std::vector<std::shared_ptr<IComponent>> filter_components(
            const std::vector<std::shared_ptr<IComponent>>& components,
            const std::function<bool(const IComponent&)>& predicate);
        
        // Component validation utilities
        static ValidationResult validate_component_tree(const IComponent& component);
        static ValidationResult validate_component_list(
            const std::vector<std::shared_ptr<IComponent>>& components);
        
        static bool has_valid_custom_ids(const std::vector<std::shared_ptr<IComponent>>& components);
        static std::vector<std::string> get_duplicate_custom_ids(
            const std::vector<std::shared_ptr<IComponent>>& components);
        
        // Component counting and statistics
        static size_t count_components_by_type(const IComponent& component, ComponentType type);
        static size_t count_components_by_type(
            const std::vector<std::shared_ptr<IComponent>>& components,
            ComponentType type);
        
        static std::map<ComponentType, size_t> get_component_type_counts(const IComponent& component);
        static std::map<ComponentType, size_t> get_component_type_counts(
            const std::vector<std::shared_ptr<IComponent>>& components);
        
        static size_t get_max_depth(const IComponent& component);
        static size_t get_total_component_count(const IComponent& component);
        
        // Component transformation utilities
        static std::vector<std::shared_ptr<IComponent>> flatten_component_tree(const IComponent& component);
        static std::vector<std::shared_ptr<IComponent>> flatten_component_list(
            const std::vector<std::shared_ptr<IComponent>>& components);
        
        static std::shared_ptr<IComponent> clone_component(const IComponent& component);
        static std::vector<std::shared_ptr<IComponent>> clone_components(
            const std::vector<std::shared_ptr<IComponent>>& components);
        
        // Component conversion utilities
        static nlohmann::json components_to_json_array(
            const std::vector<std::shared_ptr<IComponent>>& components);
        
        static std::vector<std::shared_ptr<IComponent>> json_array_to_components(
            const nlohmann::json& json_array);
        
        // String utilities
        static std::string escape_custom_id(const std::string& custom_id);
        static std::string unescape_custom_id(const std::string& escaped_custom_id);
        static bool is_valid_custom_id(const std::string& custom_id);
        static std::string generate_custom_id(const std::string& prefix = "");
        
        static std::string sanitize_label(const std::string& label);
        static std::string sanitize_placeholder(const std::string& placeholder);
        static bool is_valid_label(const std::string& label);
        static bool is_valid_placeholder(const std::string& placeholder);
        
        // URL and emoji utilities
        static bool is_valid_url(const std::string& url);
        static bool is_valid_emoji(const std::string& emoji);
        static std::string normalize_emoji(const std::string& emoji);
        
        // Layout utilities
        static std::vector<std::shared_ptr<ActionRow>> auto_layout_buttons(
            const std::vector<std::shared_ptr<Button>>& buttons,
            int max_per_row = 5);
        
        static std::vector<std::shared_ptr<ActionRow>> auto_layout_components(
            const std::vector<std::shared_ptr<IComponent>>& components,
            int max_per_row = 5);
        
        static std::shared_ptr<Container> create_balanced_layout(
            const std::vector<std::shared_ptr<IComponent>>& components);
        
        // Component creation helpers
        static std::shared_ptr<Button> create_confirmation_button(
            const std::string& custom_id_prefix = "");
        
        static std::shared_ptr<Button> create_cancellation_button(
            const std::string& custom_id_prefix = "");
        
        static std::shared_ptr<StringSelect> create_pagination_select(
            const std::string& custom_id,
            int current_page,
            int total_pages,
            const std::string& placeholder = "");
        
        static std::shared_ptr<TextInput> create_required_text_input(
            const std::string& custom_id,
            const std::string& label,
            TextInputStyle style = TextInputStyle::SHORT);
        
        // Component testing utilities
        static std::shared_ptr<IComponent> create_test_component(ComponentType type);
        static std::vector<std::shared_ptr<IComponent>> create_test_components();
        static std::shared_ptr<ActionRow> create_test_action_row();
        static std::shared_ptr<Section> create_test_section();
        static std::shared_ptr<Container> create_test_container();
        
        // Debug utilities
        static std::string component_to_debug_string(const IComponent& component);
        static std::string components_to_debug_string(
            const std::vector<std::shared_ptr<IComponent>>& components);
        
        static void print_component_tree(const IComponent& component, int indent = 0);
        static void print_component_list(
            const std::vector<std::shared_ptr<IComponent>>& components);
        
        // Performance utilities
        static bool is_component_tree_optimized(const IComponent& component);
        static std::shared_ptr<IComponent> optimize_component_tree(const IComponent& component);
        static std::vector<std::shared_ptr<IComponent>> optimize_component_list(
            const std::vector<std::shared_ptr<IComponent>>& components);
    };

    /**
     * @brief Component registry for type-safe component creation
     */
    class ComponentRegistry {
    private:
        static std::map<ComponentType, std::function<std::unique_ptr<IComponent>()>> creators_;
        
    public:
        template<typename T>
        static void register_component(ComponentType type) {
            creators_[type] = []() { return std::make_unique<T>(); };
        }
        
        static std::unique_ptr<IComponent> create(ComponentType type);
        static bool is_registered(ComponentType type);
        static std::vector<ComponentType> get_registered_types();
        static void initialize_defaults();
    };

    /**
     * @brief Component cache for performance optimization
     */
    class ComponentCache {
    private:
        static std::map<std::string, std::shared_ptr<IComponent>> cache_;
        static std::map<std::string, nlohmann::json> json_cache_;
        
    public:
        static void cache_component(const std::string& key, std::shared_ptr<IComponent> component);
        static std::shared_ptr<IComponent> get_cached_component(const std::string& key);
        static void remove_cached_component(const std::string& key);
        static void clear_component_cache();
        
        static void cache_json(const std::string& key, const nlohmann::json& json);
        static nlohmann::json get_cached_json(const std::string& key);
        static void remove_cached_json(const std::string& key);
        static void clear_json_cache();
        
        static void clear_all_caches();
        static size_t get_cache_size();
    };

} // namespace discord::components
=== END FILE ===

=== FILE: include/discord/components/container.h ===
/**
 * @file container.h
 * @brief Container component for organizing other components
 * 
 * Provides flexible container components for organizing layouts.
 */

#pragma once

#include "component_base.h"
#include "section.h"
#include "action_row.h"

namespace discord::components {

    /**
     * @brief Container component for organizing other components
     * 
     * Containers can hold any type of component and provide flexible layout options.
     */
    class Container : public ContainerComponent {
    public:
        /**
         * @brief Constructor
         */
        Container(const std::vector<std::shared_ptr<IComponent>>& components = {});

        ~Container() override = default;

        // IComponent interface
        ComponentType get_type() const override { return ComponentType::CONTAINER; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        // Container specific methods
        bool can_add_component(std::shared_ptr<IComponent> component) const;
        size_t max_components() const { return 10; } // Discord limit for containers
        bool is_full() const { return components_.size() >= max_components(); }

        // Static factory method
        static std::unique_ptr<Container> create(const std::vector<std::shared_ptr<IComponent>>& components = {});

        // Convenience factory methods
        static std::unique_ptr<Container> with_sections(const std::vector<std::shared_ptr<Section>>& sections);
        static std::unique_ptr<Container> with_action_rows(const std::vector<std::shared_ptr<ActionRow>>& action_rows);
        static std::unique_ptr<Container> mixed(const std::vector<std::shared_ptr<IComponent>>& components);
    };

} // namespace discord::components
=== END FILE ===

=== FILE: include/discord/components/section.h ===
/**
 * @file section.h
 * @brief Section container component
 * 
 * Provides section containers for organizing content with optional accessories.
 */

#pragma once

#include "component_base.h"
#include "button.h"
#include "select_menu.h"
#include "text_input.h"
#include <optional>

namespace discord::components {

    /**
     * @brief Section container component
     * 
     * Sections can contain text content and optionally one accessory component
     * (button, select menu, or text input).
     */
    class Section : public ContainerComponent {
    private:
        std::string text_;
        std::optional<std::shared_ptr<IComponent>> accessory_;

    public:
        /**
         * @brief Constructor
         */
        Section(const std::string& text,
               const std::optional<std::shared_ptr<IComponent>>& accessory = std::nullopt);

        ~Section() override = default;

        // IComponent interface
        ComponentType get_type() const override { return ComponentType::SECTION; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        // Section specific methods
        void set_text(const std::string& text) { text_ = text; }
        const std::string& get_text() const { return text_; }

        void set_accessory(const std::optional<std::shared_ptr<IComponent>>& accessory);
        const std::optional<std::shared_ptr<IComponent>>& get_accessory() const { return accessory_; }
        bool has_accessory() const { return accessory_.has_value(); }

        void clear_accessory() { accessory_ = std::nullopt; }

        // Static factory method
        static std::unique_ptr<Section> create(const std::string& text,
                                             const std::optional<std::shared_ptr<IComponent>>& accessory = std::nullopt);

        // Convenience factory methods
        static std::unique_ptr<Section> with_button(const std::string& text,
                                                   std::shared_ptr<Button> button);
        
        static std::unique_ptr<Section> with_select(const std::string& text,
                                                    std::shared_ptr<SelectMenu> select);
        
        static std::unique_ptr<Section> with_text_input(const std::string& text,
                                                       std::shared_ptr<TextInput> text_input);
    };

} // namespace discord::components
=== END FILE ===

=== FILE: include/discord/components/content_display.h ===
/**
 * @file content_display.h
 * @brief Content display components (text, thumbnails, media, files, separators, labels)
 * 
 * Provides non-interactive content display components for rich message layouts.
 */

#pragma once

#include "component_base.h"
#include <optional>

namespace discord::components {

    /**
     * @brief Text display component
     */
    class TextDisplay : public IComponent {
    private:
        std::string content_;

    public:
        explicit TextDisplay(const std::string& content);
        ~TextDisplay() override = default;

        ComponentType get_type() const override { return ComponentType::TEXT_DISPLAY; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        void set_content(const std::string& content) { content_ = content; }
        const std::string& get_content() const { return content_; }

        static std::unique_ptr<TextDisplay> create(const std::string& content);
    };

    /**
     * @brief Thumbnail component
     */
    class Thumbnail : public IComponent {
    private:
        std::string url_;
        std::optional<std::string> alt_text_;
        std::optional<int> width_;
        std::optional<int> height_;

    public:
        Thumbnail(const std::string& url,
                 const std::optional<std::string>& alt_text = std::nullopt,
                 const std::optional<int>& width = std::nullopt,
                 const std::optional<int>& height = std::nullopt);

        ~Thumbnail() override = default;

        ComponentType get_type() const override { return ComponentType::THUMBNAIL; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        void set_url(const std::string& url) { url_ = url; }
        const std::string& get_url() const { return url_; }

        void set_alt_text(const std::optional<std::string>& alt_text) { alt_text_ = alt_text; }
        const std::optional<std::string>& get_alt_text() const { return alt_text_; }

        void set_width(const std::optional<int>& width) { width_ = width; }
        const std::optional<int>& get_width() const { return width_; }

        void set_height(const std::optional<int>& height) { height_ = height; }
        const std::optional<int>& get_height() const { return height_; }

        static std::unique_ptr<Thumbnail> create(const std::string& url,
                                                const std::optional<std::string>& alt_text = std::nullopt,
                                                const std::optional<int>& width = std::nullopt,
                                                const std::optional<int>& height = std::nullopt);
    };

    /**
     * @brief Media gallery component
     */
    class MediaGallery : public IComponent {
    private:
        std::vector<std::string> items_;
        std::optional<std::string> alt_text_;

    public:
        MediaGallery(const std::vector<std::string>& items,
                    const std::optional<std::string>& alt_text = std::nullopt);

        ~MediaGallery() override = default;

        ComponentType get_type() const override { return ComponentType::MEDIA_GALLERY; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        void add_item(const std::string& item);
        void remove_item(size_t index);
        void clear_items();

        const std::vector<std::string>& get_items() const { return items_; }
        size_t item_count() const { return items_.size(); }

        void set_alt_text(const std::optional<std::string>& alt_text) { alt_text_ = alt_text; }
        const std::optional<std::string>& get_alt_text() const { return alt_text_; }

        static std::unique_ptr<MediaGallery> create(const std::vector<std::string>& items,
                                                   const std::optional<std::string>& alt_text = std::nullopt);
    };

    /**
     * @brief File component
     */
    class File : public IComponent {
    private:
        std::string url_;
        std::string filename_;
        std::optional<int> size_bytes_;

    public:
        File(const std::string& url,
             const std::string& filename,
             const std::optional<int>& size_bytes = std::nullopt);

        ~File() override = default;

        ComponentType get_type() const override { return ComponentType::FILE; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        void set_url(const std::string& url) { url_ = url; }
        const std::string& get_url() const { return url_; }

        void set_filename(const std::string& filename) { filename_ = filename; }
        const std::string& get_filename() const { return filename_; }

        void set_size_bytes(const std::optional<int>& size_bytes) { size_bytes_ = size_bytes; }
        const std::optional<int>& get_size_bytes() const { return size_bytes_; }

        static std::unique_ptr<File> create(const std::string& url,
                                           const std::string& filename,
                                           const std::optional<int>& size_bytes = std::nullopt);
    };

    /**
     * @brief Separator component
     */
    class Separator : public IComponent {
    private:
        bool decorative_ = true;
        std::optional<int> spacing_;

    public:
        Separator(bool decorative = true, const std::optional<int>& spacing = std::nullopt);
        ~Separator() override = default;

        ComponentType get_type() const override { return ComponentType::SEPARATOR; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        void set_decorative(bool decorative) { decorative_ = decorative; }
        bool is_decorative() const { return decorative_; }

        void set_spacing(const std::optional<int>& spacing) { spacing_ = spacing; }
        const std::optional<int>& get_spacing() const { return spacing_; }

        static std::unique_ptr<Separator> create(bool decorative = true,
                                                const std::optional<int>& spacing = std::nullopt);
    };

    /**
     * @brief Label component
     */
    class Label : public IComponent {
    private:
        std::string text_;
        std::optional<std::string> for_component_;

    public:
        Label(const std::string& text, const std::optional<std::string>& for_component = std::nullopt);
        ~Label() override = default;

        ComponentType get_type() const override { return ComponentType::LABEL; }
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        void set_text(const std::string& text) { text_ = text; }
        const std::string& get_text() const { return text_; }

        void set_for_component(const std::optional<std::string>& for_component) { for_component_ = for_component; }
        const std::optional<std::string>& get_for_component() const { return for_component_; }

        static std::unique_ptr<Label> create(const std::string& text,
                                            const std::optional<std::string>& for_component = std::nullopt);
    };

} // namespace discord::components
=== END FILE ===

=== FILE: include/discord/components/embed_components.h ===
/**
 * @file embed_components.h
 * @brief Embed-specific components and utilities
 * 
 * Provides components specifically designed for embed integration.
 */

#pragma once

#include "component_base.h"
#include "button.h"
#include "select_menu.h"
#include "text_input.h"
#include "action_row.h"
#include "section.h"
#include <optional>

namespace discord::components {

    /**
     * @brief Embed component wrapper for integrating components with embeds
     */
    class EmbedComponent : public IComponent {
    private:
        std::shared_ptr<IComponent> component_;
        std::optional<std::string> embed_id_;

    public:
        EmbedComponent(std::shared_ptr<IComponent> component,
                      const std::optional<std::string>& embed_id = std::nullopt);

        ~EmbedComponent() override = default;

        ComponentType get_type() const override;
        nlohmann::json to_json() const override;
        bool validate() const override;
        std::unique_ptr<IComponent> clone() const override;

        void set_component(std::shared_ptr<IComponent> component) { component_ = component; }
        std::shared_ptr<IComponent> get_component() const { return component_; }

        void set_embed_id(const std::optional<std::string>& embed_id) { embed_id_ = embed_id; }
        const std::optional<std::string>& get_embed_id() const { return embed_id_; }

        static std::unique_ptr<EmbedComponent> create(std::shared_ptr<IComponent> component,
                                                       const std::optional<std::string>& embed_id = std::nullopt);
    };

    /**
     * @brief Embed layout manager for organizing components within embeds
     */
    class EmbedLayoutManager {
    private:
        std::vector<std::shared_ptr<EmbedComponent>> components_;
        std::string embed_id_;

    public:
        explicit EmbedLayoutManager(const std::string& embed_id);

        void add_component(std::shared_ptr<IComponent> component,
                           const std::optional<std::string>& component_embed_id = std::nullopt);

        void remove_component(size_t index);
        void clear_components();

        const std::vector<std::shared_ptr<EmbedComponent>>& get_components() const { return components_; }
        size_t component_count() const { return components_.size(); }

        nlohmann::json to_json() const;
        bool validate() const;

        const std::string& get_embed_id() const { return embed_id_; }
        void set_embed_id(const std::string& embed_id) { embed_id_ = embed_id; }

        // Convenience methods
        void add_button_to_embed(std::shared_ptr<Button> button,
                                 const std::optional<std::string>& component_embed_id = std::nullopt);

        void add_select_to_embed(std::shared_ptr<SelectMenu> select,
                                 const std::optional<std::string>& component_embed_id = std::nullopt);

        void add_text_input_to_embed(std::shared_ptr<TextInput> text_input,
                                     const std::optional<std::string>& component_embed_id = std::nullopt);

        static std::unique_ptr<EmbedLayoutManager> create(const std::string& embed_id);
    };

    /**
     * @brief Embed component factory for creating embed-compatible components
     */
    class EmbedComponentFactory {
    public:
        static std::unique_ptr<EmbedComponent> wrap_button(std::shared_ptr<Button> button,
                                                           const std::optional<std::string>& embed_id = std::nullopt);

        static std::unique_ptr<EmbedComponent> wrap_select(std::shared_ptr<SelectMenu> select,
                                                           const std::optional<std::string>& embed_id = std::nullopt);

        static std::unique_ptr<EmbedComponent> wrap_text_input(std::shared_ptr<TextInput> text_input,
                                                               const std::optional<std::string>& embed_id = std::nullopt);

        static std::unique_ptr<EmbedComponent> wrap_action_row(std::shared_ptr<ActionRow> action_row,
                                                               const std::optional<std::string>& embed_id = std::nullopt);

        static std::unique_ptr<EmbedComponent> wrap_section(std::shared_ptr<Section> section,
                                                           const std::optional<std::string>& embed_id = std::nullopt);
    };

} // namespace discord::components
=== END FILE ===

=== FILE: src/core/client.cpp ===
#include <discord/core/client.h>
#include <discord/api/http_client.h>
#include <discord/gateway/websocket_client.h>
#include <discord/utils/auth.h>
#include <discord/api/rest_endpoints.h>
#include <discord/events/event_dispatcher.h>
#include <discord/utils/types.h>

#include <thread>
#include <chrono>

namespace discord {

class DiscordClient::Impl {
public:
    explicit Impl(std::string token) 
        : token_(std::move(token))
        , http_client_(token_)
        , websocket_client_()
        , event_handler_()
    {
        websocket_client_.set_token(token_);
        websocket_client_.set_intents(
            static_cast<int>(GatewayIntent::GUILDS) |
            static_cast<int>(GatewayIntent::GUILD_MESSAGES) |
            static_cast<int>(GatewayIntent::MESSAGE_CONTENT)
        );
        
        setup_event_handlers();
    }
    
    bool connect() {
        auto gateway_info = APIEndpoints::get_gateway();
        if (gateway_info.contains("url")) {
            std::string gateway_url = gateway_info["url"];
            gateway_url += "?v=10&encoding=json";
            
            if (websocket_client_.connect(gateway_url)) {
                websocket_client_.identify();
                return true;
            }
        }
        return false;
    }
    
    void disconnect() {
        websocket_client_.disconnect();
    }
    
    void on_ready(std::function<void()> callback) {
        ready_callback_ = std::move(callback);
    }
    
    void on_message(std::function<void(const nlohmann::json&)> callback) {
        message_callback_ = std::move(callback);
    }
    
    void on_interaction(std::function<void(const nlohmann::json&)> callback) {
        interaction_callback_ = std::move(callback);
    }
    
    nlohmann::json get_user(const std::string& user_id) {
        return APIEndpoints::get_user(user_id);
    }
    
    nlohmann::json get_guild(const std::string& guild_id) {
        return APIEndpoints::get_guild(guild_id);
    }
    
    nlohmann::json get_channel(const std::string& channel_id) {
        return APIEndpoints::get_channel(channel_id);
    }
    
    bool send_message(const std::string& channel_id, const std::string& content) {
        nlohmann::json data;
        data["content"] = content;
        auto response = APIEndpoints::send_message(channel_id, data);
        return !response.is_null();
    }
    
    bool create_interaction_response(const std::string& interaction_id, const nlohmann::json& response) {
        std::string token = response["token"];
        return !APIEndpoints::create_interaction_response(interaction_id, token, response).is_null();
    }

private:
    void setup_event_handlers() {
        websocket_client_.on_event([this](const nlohmann::json& event) {
            handle_gateway_event(event);
        });
    }
    
    void handle_gateway_event(const nlohmann::json& event) {
        if (!event.contains("op")) return;
        
        int opcode = event["op"];
        
        switch (opcode) {
            case static_cast<int>(GatewayOpcode::DISPATCH):
                handle_dispatch(event);
                break;
            case static_cast<int>(GatewayOpcode::HELLO):
                handle_hello(event);
                break;
            case static_cast<int>(GatewayOpcode::HEARTBEAT_ACK):
                break;
            default:
                break;
        }
    }
    
    void handle_dispatch(const nlohmann::json& event) {
        if (!event.contains("t")) return;
        
        std::string event_type = event["t"];
        nlohmann::json event_data = event["d"];
        
        if (event_type == "READY") {
            if (ready_callback_) {
                ready_callback_();
            }
        } else if (event_type == "MESSAGE_CREATE") {
            if (message_callback_) {
                message_callback_(event_data);
            }
        } else if (event_type == "INTERACTION_CREATE") {
            if (interaction_callback_) {
                interaction_callback_(event_data);
            }
        }
        
        event_handler_.handle_dispatch(event);
    }
    
    void handle_hello(const nlohmann::json& event) {
        if (event.contains("d") && event["d"].contains("heartbeat_interval")) {
            int heartbeat_interval = event["d"]["heartbeat_interval"];
            std::thread([this, heartbeat_interval]() {
                while (websocket_client_.is_connected()) {
                    std::this_thread::sleep_for(std::chrono::milliseconds(heartbeat_interval));
                    if (websocket_client_.is_connected()) {
                        nlohmann::json heartbeat;
                        heartbeat["op"] = static_cast<int>(GatewayOpcode::HEARTBEAT);
                        websocket_client_.send(heartbeat);
                    }
                }
            }).detach();
        }
    }
    
    std::string token_;
    HTTPClient http_client_;
    WebSocketClient websocket_client_;
    EventHandler event_handler_;
    
    std::function<void()> ready_callback_;
    std::function<void(const nlohmann::json&)> message_callback_;
    std::function<void(const nlohmann::json&)> interaction_callback_;
    std::function<void(const std::string&, const std::string&)> message_deleted_callback_;
    std::function<void(const nlohmann::json&, const nlohmann::json&)> message_updated_callback_;
    std::function<void(const nlohmann::json&)> guild_join_callback_;
    std::function<void(const std::string&)> guild_leave_callback_;
    std::function<void(const nlohmann::json&)> member_join_callback_;
    std::function<void(const nlohmann::json&)> member_leave_callback_;
    
    // Additional methods
    nlohmann::json get_channel_messages(const std::string& channel_id, int limit, const std::string& before, const std::string& after) {
        return APIEndpoints::get_channel_messages(channel_id, limit, before, after);
    }
    
    nlohmann::json send_embed(const std::string& channel_id, const nlohmann::json& embed) {
        nlohmann::json data;
        data["embed"] = embed;
        return APIEndpoints::send_message(channel_id, data);
    }
    
    void delete_message(const std::string& channel_id, const std::string& message_id) {
        APIEndpoints::delete_message(channel_id, message_id);
    }
    
    void edit_message(const std::string& channel_id, const std::string& message_id, const std::string& new_content) {
        nlohmann::json data;
        data["content"] = new_content;
        APIEndpoints::edit_message(channel_id, message_id, data);
    }
    
    void add_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji) {
        APIEndpoints::add_reaction(channel_id, message_id, emoji);
    }
    
    void remove_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji, const std::string& user_id) {
        APIEndpoints::remove_reaction(channel_id, message_id, emoji, user_id);
    }
    
    void edit_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id, const nlohmann::json& message) {
        APIEndpoints::edit_followup_message(application_id, interaction_token, message_id, message);
    }
    
    void delete_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id) {
        APIEndpoints::delete_followup_message(application_id, interaction_token, message_id);
    }
    
    void create_role(const std::string& guild_id, const nlohmann::json& role_data) {
        APIEndpoints::create_guild_role(guild_id, role_data);
    }
    
    void delete_role(const std::string& guild_id, const std::string& role_id) {
        APIEndpoints::delete_guild_role(guild_id, role_id);
    }
    
    void add_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id) {
        APIEndpoints::add_guild_member_role(guild_id, user_id, role_id);
    }
    
    void remove_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id) {
        APIEndpoints::remove_guild_member_role(guild_id, user_id, role_id);
    }
    
    nlohmann::json create_text_channel(const std::string& guild_id, const std::string& name, const std::string& parent_id, int position) {
        nlohmann::json data;
        data["name"] = name;
        data["type"] = 0; // Text channel
        if (!parent_id.empty()) data["parent_id"] = parent_id;
        if (position > 0) data["position"] = position;
        return APIEndpoints::create_channel(guild_id, data);
    }
    
    nlohmann::json create_voice_channel(const std::string& guild_id, const std::string& name, int bitrate, int user_limit) {
        nlohmann::json data;
        data["name"] = name;
        data["type"] = 2; // Voice channel
        data["bitrate"] = bitrate;
        data["user_limit"] = user_limit;
        return APIEndpoints::create_channel(guild_id, data);
    }
    
    void delete_channel(const std::string& channel_id) {
        APIEndpoints::delete_channel(channel_id);
    }
    
    void edit_channel(const std::string& channel_id, const nlohmann::json& data) {
        APIEndpoints::modify_channel(channel_id, data);
    }
    
    void set_token(const std::string& token) {
        token_ = token;
        websocket_client_.set_token(token);
    }
    
    const std::string& get_token() const {
        return token_;
    }
    
    void set_intents(int intents) {
        websocket_client_.set_intents(intents);
    }
    
    int get_intents() const {
        return static_cast<int>(GatewayIntent::GUILDS) | 
               static_cast<int>(GatewayIntent::GUILD_MESSAGES) | 
               static_cast<int>(GatewayIntent::MESSAGE_CONTENT);
    }
    
    bool is_connected() const {
        return websocket_client_.is_connected();
    }
    
    bool is_ready() const {
        return websocket_client_.is_connected();
    }
    
    void on_message_deleted(std::function<void(const std::string&, const std::string&)> callback) {
        message_deleted_callback_ = std::move(callback);
    }
    
    void on_message_updated(std::function<void(const nlohmann::json&, const nlohmann::json&)> callback) {
        message_updated_callback_ = std::move(callback);
    }
    
    void on_guild_join(std::function<void(const nlohmann::json&)> callback) {
        guild_join_callback_ = std::move(callback);
    }
    
    void on_guild_leave(std::function<void(const std::string&)> callback) {
        guild_leave_callback_ = std::move(callback);
    }
    
    void on_member_join(std::function<void(const nlohmann::json&)> callback) {
        member_join_callback_ = std::move(callback);
    }
    
    void on_member_leave(std::function<void(const nlohmann::json&)> callback) {
        member_leave_callback_ = std::move(callback);
    }
    
    nlohmann::json send_embed(const std::string& channel_id, const nlohmann::json& embed) {
        nlohmann::json data;
        data["embed"] = embed;
        return APIEndpoints::send_message(channel_id, data);
    }
    
    void delete_message(const std::string& channel_id, const std::string& message_id) {
        APIEndpoints::delete_message(channel_id, message_id);
    }
    
    void edit_message(const std::string& channel_id, const std::string& message_id, const std::string& new_content) {
        nlohmann::json data;
        data["content"] = new_content;
        APIEndpoints::edit_message(channel_id, message_id, data);
    }
    
    void add_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji) {
        APIEndpoints::add_reaction(channel_id, message_id, emoji);
    }
    
    void remove_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji, const std::string& user_id) {
        APIEndpoints::remove_reaction(channel_id, message_id, emoji, user_id);
    }
    
    void edit_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id, const nlohmann::json& message) {
        APIEndpoints::edit_followup_message(application_id, interaction_token, message_id, message);
    }
    
    void delete_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id) {
        APIEndpoints::delete_followup_message(application_id, interaction_token, message_id);
    }
    
    void create_role(const std::string& guild_id, const nlohmann::json& role_data) {
        APIEndpoints::create_guild_role(guild_id, role_data);
    }
    
    void delete_role(const std::string& guild_id, const std::string& role_id) {
        APIEndpoints::delete_guild_role(guild_id, role_id);
    }
    
    void add_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id) {
        APIEndpoints::add_guild_member_role(guild_id, user_id, role_id);
    }
    
    void remove_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id) {
        APIEndpoints::remove_guild_member_role(guild_id, user_id, role_id);
    }
    
    nlohmann::json create_text_channel(const std::string& guild_id, const std::string& name, const std::string& parent_id, int position) {
        nlohmann::json data;
        data["name"] = name;
        data["type"] = 0; // Text channel
        if (!parent_id.empty()) data["parent_id"] = parent_id;
        if (position > 0) data["position"] = position;
        return APIEndpoints::create_channel(guild_id, data);
    }
    
    nlohmann::json create_voice_channel(const std::string& guild_id, const std::string& name, int bitrate, int user_limit) {
        nlohmann::json data;
        data["name"] = name;
        data["type"] = 2; // Voice channel
        data["bitrate"] = bitrate;
        data["user_limit"] = user_limit;
        return APIEndpoints::create_channel(guild_id, data);
    }
    
    void delete_channel(const std::string& channel_id) {
        APIEndpoints::delete_channel(channel_id);
    }
    
    void edit_channel(const std::string& channel_id, const nlohmann::json& data) {
        APIEndpoints::modify_channel(channel_id, data);
    }
    
    void set_token(const std::string& token) {
        token_ = token;
        websocket_client_.set_token(token);
    }
    
    const std::string& get_token() const {
        return token_;
    }
    
    void set_intents(int intents) {
        websocket_client_.set_intents(intents);
    }
    
    int get_intents() const {
        return static_cast<int>(GatewayIntent::GUILDS) | 
               static_cast<int>(GatewayIntent::GUILD_MESSAGES) | 
               static_cast<int>(GatewayIntent::MESSAGE_CONTENT);
    }
    
    bool is_connected() const {
        return websocket_client_.is_connected();
    }
    
    bool is_ready() const {
        return websocket_client_.is_connected();
    }
    
    void on_message_updated(std::function<void(const nlohmann::json&, const nlohmann::json&)> callback) {
        message_updated_callback_ = std::move(callback);
    }
    
    void on_guild_join(std::function<void(const nlohmann::json&)> callback) {
        guild_join_callback_ = std::move(callback);
    }
    
    void on_guild_leave(std::function<void(const std::string&)> callback) {
        guild_leave_callback_ = std::move(callback);
    }
    
    void on_member_join(std::function<void(const nlohmann::json&)> callback) {
        member_join_callback_ = std::move(callback);
    }
    
    void on_member_leave(std::function<void(const nlohmann::json&)> callback) {
        member_leave_callback_ = std::move(callback);
    }
    
    nlohmann::json get_channel_messages(const std::string& channel_id, int limit, const std::string& before, const std::string& after) {
        return APIEndpoints::get_channel_messages(channel_id, limit, before, after);
    }
    
    nlohmann::json send_embed(const std::string& channel_id, const nlohmann::json& embed) {
        nlohmann::json data;
        data["embed"] = embed;
        return APIEndpoints::send_message(channel_id, data);
    }
    
    void delete_message(const std::string& channel_id, const std::string& message_id) {
        APIEndpoints::delete_message(channel_id, message_id);
    }
    
    void edit_message(const std::string& channel_id, const std::string& message_id, const std::string& new_content) {
        nlohmann::json data;
        data["content"] = new_content;
        APIEndpoints::edit_message(channel_id, message_id, data);
    }
    
    void add_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji) {
        APIEndpoints::add_reaction(channel_id, message_id, emoji);
    }
    
    void remove_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji, const std::string& user_id) {
        APIEndpoints::remove_reaction(channel_id, message_id, emoji, user_id);
    }
    
    void edit_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id, const nlohmann::json& message) {
        APIEndpoints::edit_followup_message(application_id, interaction_token, message_id, message);
    }
    
    void delete_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id) {
        APIEndpoints::delete_followup_message(application_id, interaction_token, message_id);
    }
    
    void create_role(const std::string& guild_id, const nlohmann::json& role_data) {
        APIEndpoints::create_guild_role(guild_id, role_data);
    }
    
    void delete_role(const std::string& guild_id, const std::string& role_id) {
        APIEndpoints::delete_guild_role(guild_id, role_id);
    }
    
    void add_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id) {
        APIEndpoints::add_guild_member_role(guild_id, user_id, role_id);
    }
    
    void remove_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id) {
        APIEndpoints::remove_guild_member_role(guild_id, user_id, role_id);
    }
    
    nlohmann::json create_text_channel(const std::string& guild_id, const std::string& name, const std::string& parent_id, int position) {
        nlohmann::json data;
        data["name"] = name;
        data["type"] = 0; // Text channel
        if (!parent_id.empty()) data["parent_id"] = parent_id;
        if (position > 0) data["position"] = position;
        return APIEndpoints::create_channel(guild_id, data);
    }
    
    nlohmann::json create_voice_channel(const std::string& guild_id, const std::string& name, int bitrate, int user_limit) {
        nlohmann::json data;
        data["name"] = name;
        data["type"] = 2; // Voice channel
        data["bitrate"] = bitrate;
        data["user_limit"] = user_limit;
        return APIEndpoints::create_channel(guild_id, data);
    }
    
    void delete_channel(const std::string& channel_id) {
        APIEndpoints::delete_channel(channel_id);
    }
    
    void edit_channel(const std::string& channel_id, const nlohmann::json& data) {
        APIEndpoints::modify_channel(channel_id, data);
    }
    
    void remove_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji, const std::string& user_id) {
        APIEndpoints::remove_reaction(channel_id, message_id, emoji, user_id);
    }
    
    void edit_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id, const nlohmann::json& message) {
        APIEndpoints::edit_webhook_message(application_id, interaction_token, message_id, message);
    }
    
    void delete_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id) {
        APIEndpoints::delete_webhook_message(application_id, interaction_token, message_id);
    }
    
    void create_role(const std::string& guild_id, const nlohmann::json& role_data) {
        APIEndpoints::create_guild_role(guild_id, role_data);
    }
    
    void delete_role(const std::string& guild_id, const std::string& role_id) {
        APIEndpoints::delete_guild_role(guild_id, role_id);
    }
    
    void add_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id) {
        APIEndpoints::add_guild_member_role(guild_id, user_id, role_id);
    }
    
    void remove_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id) {
        APIEndpoints::remove_guild_member_role(guild_id, user_id, role_id);
    }
    
    nlohmann::json create_text_channel(const std::string& guild_id, const std::string& name, const std::string& parent_id, int position) {
        nlohmann::json data;
        data["name"] = name;
        data["type"] = 0; // Text channel
        if (!parent_id.empty()) data["parent_id"] = parent_id;
        if (position > 0) data["position"] = position;
        return APIEndpoints::create_channel(guild_id, data);
    }
    
    nlohmann::json create_voice_channel(const std::string& guild_id, const std::string& name, int bitrate, int user_limit) {
        nlohmann::json data;
        data["name"] = name;
        data["type"] = 2; // Voice channel
        data["bitrate"] = bitrate;
        data["user_limit"] = user_limit;
        return APIEndpoints::create_channel(guild_id, data);
    }
    
    void delete_channel(const std::string& channel_id) {
        APIEndpoints::delete_channel(channel_id);
    }
    
    void edit_channel(const std::string& channel_id, const nlohmann::json& data) {
        APIEndpoints::modify_channel(channel_id, data);
    }
    
    void set_token(const std::string& token) {
        token_ = token;
        websocket_client_.set_token(token);
    }
    
    const std::string& get_token() const {
        return token_;
    }
    
    void set_intents(int intents) {
        websocket_client_.set_intents(intents);
    }
    
    int get_intents() const {
        return static_cast<int>(GatewayIntent::GUILDS) | 
               static_cast<int>(GatewayIntent::GUILD_MESSAGES) | 
               static_cast<int>(GatewayIntent::MESSAGE_CONTENT);
    }
    
    bool is_connected() const {
        return websocket_client_.is_connected();
    }
    
    bool is_ready() const {
        return websocket_client_.is_connected();
    }
};

DiscordClient::DiscordClient(std::string token) 
    : pImpl(std::make_unique<Impl>(std::move(token))) {}

DiscordClient::~DiscordClient() = default;

bool DiscordClient::connect() {
    return pImpl->connect();
}

void DiscordClient::disconnect() {
    pImpl->disconnect();
}

void DiscordClient::on_ready(std::function<void()> callback) {
    pImpl->on_ready(std::move(callback));
}

void DiscordClient::on_message(std::function<void(const nlohmann::json&)> callback) {
    pImpl->on_message(std::move(callback));
}

void DiscordClient::on_interaction(std::function<void(const nlohmann::json&)> callback) {
    pImpl->on_interaction(std::move(callback));
}

nlohmann::json DiscordClient::get_user(const std::string& user_id) {
    return pImpl->get_user(user_id);
}

nlohmann::json DiscordClient::get_guild(const std::string& guild_id) {
    return pImpl->get_guild(guild_id);
}

nlohmann::json DiscordClient::get_channel(const std::string& channel_id) {
    return pImpl->get_channel(channel_id);
}

bool DiscordClient::send_message(const std::string& channel_id, const std::string& content) {
    return pImpl->send_message(channel_id, content);
}

bool DiscordClient::create_interaction_response(const std::string& interaction_id, const nlohmann::json& response) {
    return pImpl->create_interaction_response(interaction_id, response);
}

void DiscordClient::on_message_deleted(std::function<void(const std::string&, const std::string&)> callback) {
    pImpl->on_message_deleted(std::move(callback));
}

void DiscordClient::on_message_updated(std::function<void(const nlohmann::json&, const nlohmann::json&)> callback) {
    pImpl->on_message_updated(std::move(callback));
}

void DiscordClient::on_guild_join(std::function<void(const nlohmann::json&)> callback) {
    pImpl->on_guild_join(std::move(callback));
}

void DiscordClient::on_guild_leave(std::function<void(const std::string&)> callback) {
    pImpl->on_guild_leave(std::move(callback));
}

void DiscordClient::on_member_join(std::function<void(const nlohmann::json&)> callback) {
    pImpl->on_member_join(std::move(callback));
}

void DiscordClient::on_member_leave(std::function<void(const nlohmann::json&)> callback) {
    pImpl->on_member_leave(std::move(callback));
}

nlohmann::json DiscordClient::get_channel_messages(const std::string& channel_id, int limit, const std::string& before, const std::string& after) {
    return pImpl->get_channel_messages(channel_id, limit, before, after);
}

nlohmann::json DiscordClient::send_embed(const std::string& channel_id, const nlohmann::json& embed) {
    return pImpl->send_embed(channel_id, embed);
}

void DiscordClient::delete_message(const std::string& channel_id, const std::string& message_id) {
    pImpl->delete_message(channel_id, message_id);
}

void DiscordClient::edit_message(const std::string& channel_id, const std::string& message_id, const std::string& new_content) {
    pImpl->edit_message(channel_id, message_id, new_content);
}

void DiscordClient::add_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji) {
    pImpl->add_reaction(channel_id, message_id, emoji);
}

void DiscordClient::remove_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji, const std::string& user_id) {
    pImpl->remove_reaction(channel_id, message_id, emoji, user_id);
}

void DiscordClient::edit_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id, const nlohmann::json& message) {
    pImpl->edit_followup_message(application_id, interaction_token, message_id, message);
}

void DiscordClient::delete_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id) {
    pImpl->delete_followup_message(application_id, interaction_token, message_id);
}

void DiscordClient::create_role(const std::string& guild_id, const nlohmann::json& role_data) {
    pImpl->create_role(guild_id, role_data);
}

void DiscordClient::delete_role(const std::string& guild_id, const std::string& role_id) {
    pImpl->delete_role(guild_id, role_id);
}

void DiscordClient::add_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id) {
    pImpl->add_role(guild_id, user_id, role_id);
}

void DiscordClient::remove_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id) {
    pImpl->remove_role(guild_id, user_id, role_id);
}

nlohmann::json DiscordClient::create_text_channel(const std::string& guild_id, const std::string& name, const std::string& parent_id, int position) {
    return pImpl->create_text_channel(guild_id, name, parent_id, position);
}

nlohmann::json DiscordClient::create_voice_channel(const std::string& guild_id, const std::string& name, int bitrate, int user_limit) {
    return pImpl->create_voice_channel(guild_id, name, bitrate, user_limit);
}

void DiscordClient::delete_channel(const std::string& channel_id) {
    pImpl->delete_channel(channel_id);
}

void DiscordClient::edit_channel(const std::string& channel_id, const nlohmann::json& data) {
    pImpl->edit_channel(channel_id, data);
}

void DiscordClient::set_token(const std::string& token) {
    pImpl->set_token(token);
}

const std::string& DiscordClient::get_token() const {
    return pImpl->get_token();
}

void DiscordClient::set_intents(int intents) {
    pImpl->set_intents(intents);
}

int DiscordClient::get_intents() const {
    return pImpl->get_intents();
}

bool DiscordClient::is_connected() const {
    return pImpl->is_connected();
}

bool DiscordClient::is_ready() const {
    return pImpl->is_ready();
}

}
=== END FILE ===

=== FILE: src/core/exceptions.cpp ===
#include <discord/core/exceptions.h>
#include <sstream>

namespace discord {

DiscordException::DiscordException(int code, const std::string& message, const nlohmann::json& response)
    : code_(code), message_(message), response_(response) {
    std::ostringstream oss;
    oss << "Discord Error " << code << ": " << message;
    full_message_ = oss.str();
}

const char* DiscordException::what() const noexcept {
    return full_message_.c_str();
}

int DiscordException::get_code() const {
    return code_;
}

const std::string& DiscordException::get_message() const {
    return message_;
}

const nlohmann::json& DiscordException::get_response() const {
    return response_;
}

DiscordException DiscordException::from_response(const nlohmann::json& response) {
    int code = 0;
    std::string message = "Unknown error";
    
    if (response.contains("code")) {
        code = response["code"];
    }
    
    if (response.contains("message")) {
        message = response["message"];
    }
    
    if (code == 0 && response.contains("retry_after")) {
        return RateLimitException(response["retry_after"], message);
    }
    
    return DiscordException(code, message, response);
}

RateLimitException::RateLimitException(int retry_after, const std::string& message)
    : DiscordException(static_cast<int>(ErrorCode::RATE_LIMITED), message), retry_after_(retry_after) {
}

int RateLimitException::get_retry_after() const {
    return retry_after_;
}

WebSocketException::WebSocketException(int close_code, const std::string& message)
    : DiscordException(close_code, message), close_code_(close_code) {
}

int WebSocketException::get_close_code() const {
    return close_code_;
}

AuthenticationException::AuthenticationException(const std::string& message)
    : DiscordException(static_cast<int>(ErrorCode::UNAUTHORIZED), message) {
}

PermissionException::PermissionException(const std::string& message)
    : DiscordException(static_cast<int>(ErrorCode::MISSING_PERMISSIONS), message) {
}

ValidationException::ValidationException(const std::string& message)
    : DiscordException(static_cast<int>(ErrorCode::INVALID_ACCOUNT_TYPE), message) {
}

}
=== END FILE ===

=== FILE: src/utils/types.cpp ===
#include <discord/utils/types.h>

namespace discord {

void to_json(nlohmann::json& j, const User& user) {
    j = nlohmann::json{
        {"id", user.id},
        {"username", user.username},
        {"discriminator", user.discriminator},
        {"global_name", user.global_name},
        {"avatar", user.avatar},
        {"bot", user.bot},
        {"system", user.system},
        {"mfa_enabled", user.mfa_enabled},
        {"locale", user.locale},
        {"verified", user.verified},
        {"email", user.email},
        {"flags", user.flags},
        {"premium_type", user.premium_type},
        {"public_flags", user.public_flags},
        {"avatar_decoration", user.avatar_decoration}
    };
}

void from_json(const nlohmann::json& j, User& user) {
    j.at("id").get_to(user.id);
    j.at("username").get_to(user.username);
    j.at("discriminator").get_to(user.discriminator);
    if (j.contains("global_name")) j.at("global_name").get_to(user.global_name);
    if (j.contains("avatar")) j.at("avatar").get_to(user.avatar);
    if (j.contains("bot")) j.at("bot").get_to(user.bot);
    if (j.contains("system")) j.at("system").get_to(user.system);
    if (j.contains("mfa_enabled")) j.at("mfa_enabled").get_to(user.mfa_enabled);
    if (j.contains("locale")) j.at("locale").get_to(user.locale);
    if (j.contains("verified")) j.at("verified").get_to(user.verified);
    if (j.contains("email")) j.at("email").get_to(user.email);
    if (j.contains("flags")) j.at("flags").get_to(user.flags);
    if (j.contains("premium_type")) j.at("premium_type").get_to(user.premium_type);
    if (j.contains("public_flags")) j.at("public_flags").get_to(user.public_flags);
    if (j.contains("avatar_decoration")) j.at("avatar_decoration").get_to(user.avatar_decoration);
}

void to_json(nlohmann::json& j, const Guild& guild) {
    j = nlohmann::json{
        {"id", guild.id},
        {"name", guild.name},
        {"icon", guild.icon},
        {"icon_hash", guild.icon_hash},
        {"splash", guild.splash},
        {"discovery_splash", guild.discovery_splash},
        {"owner", guild.owner},
        {"owner_id", guild.owner_id},
        {"permissions", guild.permissions},
        {"region", guild.region},
        {"afk_channel_id", guild.afk_channel_id},
        {"afk_timeout", guild.afk_timeout},
        {"widget_enabled", guild.widget_enabled},
        {"widget_channel_id", guild.widget_channel_id},
        {"verification_level", guild.verification_level},
        {"default_message_notifications", guild.default_message_notifications},
        {"explicit_content_filter", guild.explicit_content_filter},
        {"roles", guild.roles},
        {"emojis", guild.emojis},
        {"features", guild.features},
        {"mfa_level", guild.mfa_level},
        {"application_id", guild.application_id},
        {"system_channel_flags", guild.system_channel_flags},
        {"rules_channel_id", guild.rules_channel_id},
        {"max_members", guild.max_members},
        {"max_presences", guild.max_presences},
        {"vanity_url_code", guild.vanity_url_code},
        {"description", guild.description},
        {"banner", guild.banner},
        {"premium_tier", guild.premium_tier},
        {"premium_subscription_count", guild.premium_subscription_count},
        {"preferred_locale", guild.preferred_locale},
        {"public_updates_channel_id", guild.public_updates_channel_id},
        {"max_video_channel_users", guild.max_video_channel_users},
        {"approximate_member_count", guild.approximate_member_count},
        {"approximate_presence_count", guild.approximate_presence_count}
    };
}

void from_json(const nlohmann::json& j, Guild& guild) {
    j.at("id").get_to(guild.id);
    j.at("name").get_to(guild.name);
    if (j.contains("icon")) j.at("icon").get_to(guild.icon);
    if (j.contains("icon_hash")) j.at("icon_hash").get_to(guild.icon_hash);
    if (j.contains("splash")) j.at("splash").get_to(guild.splash);
    if (j.contains("discovery_splash")) j.at("discovery_splash").get_to(guild.discovery_splash);
    if (j.contains("owner")) j.at("owner").get_to(guild.owner);
    if (j.contains("owner_id")) j.at("owner_id").get_to(guild.owner_id);
    if (j.contains("permissions")) j.at("permissions").get_to(guild.permissions);
    if (j.contains("region")) j.at("region").get_to(guild.region);
    if (j.contains("afk_channel_id")) j.at("afk_channel_id").get_to(guild.afk_channel_id);
    if (j.contains("afk_timeout")) j.at("afk_timeout").get_to(guild.afk_timeout);
    if (j.contains("widget_enabled")) j.at("widget_enabled").get_to(guild.widget_enabled);
    if (j.contains("widget_channel_id")) j.at("widget_channel_id").get_to(guild.widget_channel_id);
    if (j.contains("verification_level")) j.at("verification_level").get_to(guild.verification_level);
    if (j.contains("default_message_notifications")) j.at("default_message_notifications").get_to(guild.default_message_notifications);
    if (j.contains("explicit_content_filter")) j.at("explicit_content_filter").get_to(guild.explicit_content_filter);
    if (j.contains("roles")) j.at("roles").get_to(guild.roles);
    if (j.contains("emojis")) j.at("emojis").get_to(guild.emojis);
    if (j.contains("features")) j.at("features").get_to(guild.features);
    if (j.contains("mfa_level")) j.at("mfa_level").get_to(guild.mfa_level);
    if (j.contains("application_id")) j.at("application_id").get_to(guild.application_id);
    if (j.contains("system_channel_flags")) j.at("system_channel_flags").get_to(guild.system_channel_flags);
    if (j.contains("rules_channel_id")) j.at("rules_channel_id").get_to(guild.rules_channel_id);
    if (j.contains("max_members")) j.at("max_members").get_to(guild.max_members);
    if (j.contains("max_presences")) j.at("max_presences").get_to(guild.max_presences);
    if (j.contains("vanity_url_code")) j.at("vanity_url_code").get_to(guild.vanity_url_code);
    if (j.contains("description")) j.at("description").get_to(guild.description);
    if (j.contains("banner")) j.at("banner").get_to(guild.banner);
    if (j.contains("premium_tier")) j.at("premium_tier").get_to(guild.premium_tier);
    if (j.contains("premium_subscription_count")) j.at("premium_subscription_count").get_to(guild.premium_subscription_count);
    if (j.contains("preferred_locale")) j.at("preferred_locale").get_to(guild.preferred_locale);
    if (j.contains("public_updates_channel_id")) j.at("public_updates_channel_id").get_to(guild.public_updates_channel_id);
    if (j.contains("max_video_channel_users")) j.at("max_video_channel_users").get_to(guild.max_video_channel_users);
    if (j.contains("approximate_member_count")) j.at("approximate_member_count").get_to(guild.approximate_member_count);
    if (j.contains("approximate_presence_count")) j.at("approximate_presence_count").get_to(guild.approximate_presence_count);
}

void to_json(nlohmann::json& j, const Channel& channel) {
    j = nlohmann::json{
        {"id", channel.id},
        {"type", channel.type},
        {"guild_id", channel.guild_id},
        {"position", channel.position},
        {"permission_overwrites", channel.permission_overwrites},
        {"name", channel.name},
        {"topic", channel.topic},
        {"nsfw", channel.nsfw},
        {"last_message_id", channel.last_message_id},
        {"bitrate", channel.bitrate},
        {"user_limit", channel.user_limit},
        {"rate_limit_per_user", channel.rate_limit_per_user},
        {"recipients", channel.recipients},
        {"icon", channel.icon},
        {"owner_id", channel.owner_id},
        {"application_id", channel.application_id},
        {"parent_id", channel.parent_id},
        {"last_pin_timestamp", channel.last_pin_timestamp},
        {"messages", channel.messages}
    };
}

void from_json(const nlohmann::json& j, Channel& channel) {
    j.at("id").get_to(channel.id);
    j.at("type").get_to(channel.type);
    if (j.contains("guild_id")) j.at("guild_id").get_to(channel.guild_id);
    if (j.contains("position")) j.at("position").get_to(channel.position);
    if (j.contains("permission_overwrites")) j.at("permission_overwrites").get_to(channel.permission_overwrites);
    if (j.contains("name")) j.at("name").get_to(channel.name);
    if (j.contains("topic")) j.at("topic").get_to(channel.topic);
    if (j.contains("nsfw")) j.at("nsfw").get_to(channel.nsfw);
    if (j.contains("last_message_id")) j.at("last_message_id").get_to(channel.last_message_id);
    if (j.contains("bitrate")) j.at("bitrate").get_to(channel.bitrate);
    if (j.contains("user_limit")) j.at("user_limit").get_to(channel.user_limit);
    if (j.contains("rate_limit_per_user")) j.at("rate_limit_per_user").get_to(channel.rate_limit_per_user);
    if (j.contains("recipients")) j.at("recipients").get_to(channel.recipients);
    if (j.contains("icon")) j.at("icon").get_to(channel.icon);
    if (j.contains("owner_id")) j.at("owner_id").get_to(channel.owner_id);
    if (j.contains("application_id")) j.at("application_id").get_to(channel.application_id);
    if (j.contains("parent_id")) j.at("parent_id").get_to(channel.parent_id);
    if (j.contains("last_pin_timestamp")) j.at("last_pin_timestamp").get_to(channel.last_pin_timestamp);
    if (j.contains("messages")) j.at("messages").get_to(channel.messages);
}

}
=== END FILE ===

=== FILE: src/utils/logger.cpp ===
#include <discord/utils/logger.h>
#include <discord/core/exceptions.h>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <chrono>
#include <thread>

namespace discord {

// Global logger instance
std::shared_ptr<Logger> g_logger = nullptr;

Logger::Logger(
    Level level,
    Output output,
    const std::string& log_file,
    size_t max_buffer_size
) : current_level_(level)
  , output_(output)
  , log_file_(log_file)
  , max_buffer_size_(max_buffer_size)
  , colors_enabled_(true) {
    
    if (output_ == Output::File || output_ == Output::Both) {
        if (log_file_.empty()) {
            throw DiscordException("Log file path required when output includes File");
        }
        initialize_file();
    }
}

Logger::~Logger() {
    flush();
    if (file_stream_.is_open()) {
        file_stream_.close();
    }
}

void Logger::log(Level level, const std::string& message) {
    if (level < current_level_) {
        return;
    }

    LogEntry entry{
        level,
        message,
        std::chrono::system_clock::now(),
        get_thread_id()
    };

    std::lock_guard<std::mutex> lock(mutex_);

    // Add to buffer
    if (buffer_.size() >= max_buffer_size_) {
        buffer_.erase(buffer_.begin());
    }
    buffer_.push_back(entry);

    // Write to outputs
    if (output_ == Output::Console || output_ == Output::Both) {
        write_to_console(entry);
    }
    
    if (output_ == Output::File || output_ == Output::Both) {
        write_to_file(entry);
    }
}

void Logger::set_level(Level level) {
    std::lock_guard<std::mutex> lock(mutex_);
    current_level_ = level;
}

Logger::Level Logger::get_level() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return current_level_;
}

void Logger::set_output(Output output, const std::string& log_file) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // Close existing file stream if open
    if (file_stream_.is_open()) {
        file_stream_.close();
    }
    
    output_ = output;
    if (!log_file.empty()) {
        log_file_ = log_file;
    }
    
    if (output_ == Output::File || output_ == Output::Both) {
        if (log_file_.empty()) {
            throw DiscordException("Log file path required when output includes File");
        }
        initialize_file();
    }
}

void Logger::set_colors_enabled(bool enabled) {
    std::lock_guard<std::mutex> lock(mutex_);
    colors_enabled_ = enabled;
}

std::vector<Logger::LogEntry> Logger::get_buffer() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return buffer_;
}

void Logger::clear_buffer() {
    std::lock_guard<std::mutex> lock(mutex_);
    buffer_.clear();
}

void Logger::flush() {
    std::lock_guard<std::mutex> lock(mutex_);
    if (file_stream_.is_open()) {
        file_stream_.flush();
    }
}

void Logger::trace(const std::string& message) {
    log(Level::Trace, message);
}

void Logger::debug(const std::string& message) {
    log(Level::Debug, message);
}

void Logger::info(const std::string& message) {
    log(Level::Info, message);
}

void Logger::warn(const std::string& message) {
    log(Level::Warning, message);
}

void Logger::error(const std::string& message) {
    log(Level::Error, message);
}

void Logger::critical(const std::string& message) {
    log(Level::Critical, message);
}

std::string Logger::level_to_string(Level level) const {
    switch (level) {
        case Level::Trace: return "TRACE";
        case Level::Debug: return "DEBUG";
        case Level::Info: return "INFO";
        case Level::Warning: return "WARN";
        case Level::Error: return "ERROR";
        case Level::Critical: return "CRITICAL";
        default: return "UNKNOWN";
    }
}

std::string Logger::format_timestamp(std::chrono::system_clock::time_point timestamp) const {
    auto time_t = std::chrono::system_clock::to_time_t(timestamp);
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        timestamp.time_since_epoch()
    ) % 1000;
    
    std::stringstream ss;
    ss << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S");
    ss << '.' << std::setfill('0') << std::setw(3) << ms.count();
    return ss.str();
}

std::string Logger::get_thread_id() const {
    std::stringstream ss;
    ss << std::this_thread::get_id();
    return ss.str();
}

std::string Logger::apply_colors(Level level, const std::string& message) const {
    if (!colors_enabled_) {
        return message;
    }
    
    const char* color_code = "";
    const char* reset_code = "\033[0m";
    
    switch (level) {
        case Level::Trace: color_code = "\033[37m"; break;    // White
        case Level::Debug: color_code = "\033[36m"; break;    // Cyan
        case Level::Info: color_code = "\033[32m"; break;     // Green
        case Level::Warning: color_code = "\033[33m"; break;  // Yellow
        case Level::Error: color_code = "\033[31m"; break;   // Red
        case Level::Critical: color_code = "\033[35m"; break; // Magenta
    }
    
    return std::string(color_code) + message + reset_code;
}

void Logger::write_to_console(const LogEntry& entry) const {
    std::string level_str = level_to_string(entry.level);
    std::string timestamp_str = format_timestamp(entry.timestamp);
    
    std::stringstream ss;
    ss << "[" << timestamp_str << "] "
       << "[" << level_str << "] "
       << "[Thread:" << entry.thread_id << "] "
       << entry.message;
    
    std::string output = apply_colors(entry.level, ss.str());
    std::cout << output << std::endl;
}

void Logger::write_to_file(const LogEntry& entry) {
    if (!file_stream_.is_open()) {
        return;
    }
    
    std::string level_str = level_to_string(entry.level);
    std::string timestamp_str = format_timestamp(entry.timestamp);
    
    file_stream_ << "[" << timestamp_str << "] "
                 << "[" << level_str << "] "
                 << "[Thread:" << entry.thread_id << "] "
                 << entry.message << std::endl;
}

void Logger::initialize_file() {
    file_stream_.open(log_file_, std::ios::app);
    if (!file_stream_.is_open()) {
        throw DiscordException("Failed to open log file: " + log_file_);
    }
}

void initialize_logger(
    Logger::Level level,
    Logger::Output output,
    const std::string& log_file
) {
    g_logger = std::make_shared<Logger>(level, output, log_file);
}

std::shared_ptr<Logger> get_logger() {
    if (!g_logger) {
        // Initialize with default settings if not already initialized
        g_logger = std::make_shared<Logger>();
    }
    return g_logger;
}

} // namespace discord
=== END FILE ===

=== FILE: src/utils/thread_pool.cpp ===
#include <discord/utils/thread_pool.h>

namespace discord {

ThreadPool::ThreadPool(size_t threads) : stop_(false), thread_count_(threads) {
    workers_.reserve(threads);
    for (size_t i = 0; i < threads; ++i) {
        workers_.emplace_back(&ThreadPool::worker_thread, this);
    }
}

ThreadPool::~ThreadPool() {
    shutdown();
}

std::future<void> ThreadPool::submit(std::function<void()> task) {
    auto promise = std::promise<void>();
    auto future = promise.get_future();
    
    auto wrapped_task = [promise = std::move(promise), task = std::move(task)]() mutable {
        try {
            task();
            promise.set_value();
        } catch (...) {
            promise.set_exception(std::current_exception());
        }
    };
    
    {
        std::unique_lock<std::mutex> lock(queue_mutex_);
        if (stop_) {
            throw std::runtime_error("ThreadPool is stopped");
        }
        tasks_.push(std::move(wrapped_task));
    }
    
    condition_.notify_one();
    return future;
}

void ThreadPool::shutdown() {
    {
        std::unique_lock<std::mutex> lock(queue_mutex_);
        stop_ = true;
    }
    
    condition_.notify_all();
    
    for (auto& worker : workers_) {
        if (worker.joinable()) {
            worker.join();
        }
    }
    
    workers_.clear();
}

size_t ThreadPool::get_thread_count() const {
    return thread_count_;
}

size_t ThreadPool::get_pending_tasks() const {
    std::lock_guard<std::mutex> lock(queue_mutex_);
    return tasks_.size();
}

void ThreadPool::worker_thread() {
    while (true) {
        std::function<void()> task;
        
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            condition_.wait(lock, [this] { return stop_ || !tasks_.empty(); });
            
            if (stop_ && tasks_.empty()) {
                return;
            }
            
            task = std::move(tasks_.front());
            tasks_.pop();
        }
        
        task();
    }
}

} // namespace discord
=== END FILE ===

=== FILE: src/utils/config_manager.cpp ===
#include <discord/config.h>
#include <fstream>
#include <cstdlib>

namespace discord {

Config Config::from_file(const std::string& filename) {
    Config config;
    std::ifstream file(filename);
    if (file.is_open()) {
        try {
            nlohmann::json j;
            file >> j;
            config.from_json(j);
        } catch (const std::exception& e) {
            // Use default config if file is invalid
        }
    }
    return config;
}

Config Config::from_env() {
    Config config;
    
    const char* token = std::getenv("DISCORD_BOT_TOKEN");
    if (token) {
        config.token = token;
    }
    
    const char* api_version = std::getenv("DISCORD_API_VERSION");
    if (api_version) {
        config.api_version = api_version;
    }
    
    const char* base_url = std::getenv("DISCORD_BASE_URL");
    if (base_url) {
        config.base_url = base_url;
    }
    
    const char* gateway_url = std::getenv("DISCORD_GATEWAY_URL");
    if (gateway_url) {
        config.gateway_url = gateway_url;
    }
    
    return config;
}

nlohmann::json Config::to_json() const {
    return nlohmann::json{
        {"token", token},
        {"api_version", api_version},
        {"base_url", base_url},
        {"gateway_url", gateway_url},
        {"intents", intents},
        {"compress", compress},
        {"large_threshold", large_threshold},
        {"heartbeat_interval", heartbeat_interval.count()},
        {"connection_timeout", connection_timeout.count()},
        {"request_timeout", request_timeout.count()},
        {"max_retries", max_retries},
        {"retry_delay", retry_delay.count()},
        {"user_agent", user_agent},
        {"rate_limit", nlohmann::json{
            {"max_requests", rate_limit.max_requests},
            {"window", rate_limit.window.count()}
        }},
        {"sharding", nlohmann::json{
            {"shard_id", sharding.shard_id},
            {"shard_count", sharding.shard_count}
        }}
    };
}

void Config::from_json(const nlohmann::json& j) {
    if (j.contains("token")) j.at("token").get_to(token);
    if (j.contains("api_version")) j.at("api_version").get_to(api_version);
    if (j.contains("base_url")) j.at("base_url").get_to(base_url);
    if (j.contains("gateway_url")) j.at("gateway_url").get_to(gateway_url);
    if (j.contains("intents")) j.at("intents").get_to(intents);
    if (j.contains("compress")) j.at("compress").get_to(compress);
    if (j.contains("large_threshold")) j.at("large_threshold").get_to(large_threshold);
    if (j.contains("heartbeat_interval")) heartbeat_interval = std::chrono::milliseconds(j["heartbeat_interval"]);
    if (j.contains("connection_timeout")) connection_timeout = std::chrono::milliseconds(j["connection_timeout"]);
    if (j.contains("request_timeout")) request_timeout = std::chrono::milliseconds(j["request_timeout"]);
    if (j.contains("max_retries")) j.at("max_retries").get_to(max_retries);
    if (j.contains("retry_delay")) retry_delay = std::chrono::milliseconds(j["retry_delay"]);
    if (j.contains("user_agent")) j.at("user_agent").get_to(user_agent);
    
    if (j.contains("rate_limit")) {
        const auto& rl = j["rate_limit"];
        if (rl.contains("max_requests")) rl.at("max_requests").get_to(rate_limit.max_requests);
        if (rl.contains("window")) rate_limit.window = std::chrono::milliseconds(rl["window"]);
    }
    
    if (j.contains("sharding")) {
        const auto& s = j["sharding"];
        if (s.contains("shard_id")) s.at("shard_id").get_to(sharding.shard_id);
        if (s.contains("shard_count")) s.at("shard_count").get_to(sharding.shard_count);
    }
}

ConfigManager& ConfigManager::instance() {
    static ConfigManager instance;
    return instance;
}

void ConfigManager::load_config(const Config& config) {
    config_ = config;
}

const Config& ConfigManager::get_config() const {
    return config_;
}

void ConfigManager::set_token(const std::string& token) {
    config_.token = token;
}

void ConfigManager::set_intents(int intents) {
    config_.intents = intents;
}

void ConfigManager::set_sharding(int shard_id, int shard_count) {
    config_.sharding.shard_id = shard_id;
    config_.sharding.shard_count = shard_count;
}

}
=== END FILE ===

=== FILE: src/utils/auth.cpp ===
#include <discord/utils/auth.h>
#include <discord/api/http_client.h>

namespace discord {

std::string Auth::bot_token(const std::string& token) {
    return "Bot " + token;
}

std::string Auth::bearer_token(const std::string& token) {
    return "Bearer " + token;
}

bool Auth::validate_token(const std::string& token) {
    HTTPClient client(token);
    auto response = client.get("/users/@me");
    return !response.is_null();
}

nlohmann::json Auth::get_current_user(const std::string& token) {
    HTTPClient client(token);
    return client.get("/users/@me");
}

}
=== END FILE ===

=== FILE: src/utils/embed_builder.cpp ===
#include <discord/utils/embed_builder.h>
#include <sstream>
#include <iomanip>

namespace discord {

EmbedBuilder::EmbedBuilder() {
    embed_ = nlohmann::json::object();
}

EmbedBuilder& EmbedBuilder::title(const std::string& title) {
    embed_["title"] = title;
    return *this;
}

EmbedBuilder& EmbedBuilder::description(const std::string& description) {
    embed_["description"] = description;
    return *this;
}

EmbedBuilder& EmbedBuilder::url(const std::string& url) {
    embed_["url"] = url;
    return *this;
}

EmbedBuilder& EmbedBuilder::color(int color) {
    embed_["color"] = color;
    return *this;
}

EmbedBuilder& EmbedBuilder::timestamp(const std::chrono::system_clock::time_point& timestamp) {
    auto time_t = std::chrono::system_clock::to_time_t(timestamp);
    embed_["timestamp"] = std::put_time(std::gmtime(&time_t), "%Y-%m-%dT%H:%M:%S.000Z");
    return *this;
}

EmbedBuilder& EmbedBuilder::footer(const std::string& text, const std::string& icon_url) {
    nlohmann::json footer = nlohmann::json::object();
    footer["text"] = text;
    if (!icon_url.empty()) {
        footer["icon_url"] = icon_url;
    }
    embed_["footer"] = footer;
    return *this;
}

EmbedBuilder& EmbedBuilder::thumbnail(const std::string& url, int height, int width) {
    nlohmann::json thumbnail = nlohmann::json::object();
    thumbnail["url"] = url;
    if (height > 0) thumbnail["height"] = height;
    if (width > 0) thumbnail["width"] = width;
    embed_["thumbnail"] = thumbnail;
    return *this;
}

EmbedBuilder& EmbedBuilder::image(const std::string& url, int height, int width) {
    nlohmann::json image = nlohmann::json::object();
    image["url"] = url;
    if (height > 0) image["height"] = height;
    if (width > 0) image["width"] = width;
    embed_["image"] = image;
    return *this;
}

EmbedBuilder& EmbedBuilder::author(const std::string& name, const std::string& url, const std::string& icon_url) {
    nlohmann::json author = nlohmann::json::object();
    author["name"] = name;
    if (!url.empty()) author["url"] = url;
    if (!icon_url.empty()) author["icon_url"] = icon_url;
    embed_["author"] = author;
    return *this;
}

EmbedBuilder& EmbedBuilder::field(const std::string& name, const std::string& value, bool is_inline) {
    if (!embed_.contains("fields")) {
        embed_["fields"] = nlohmann::json::array();
    }
    
    nlohmann::json field = nlohmann::json::object();
    field["name"] = name;
    field["value"] = value;
    field["inline"] = is_inline;
    
    embed_["fields"].push_back(field);
    return *this;
}

nlohmann::json EmbedBuilder::build() const {
    return embed_;
}

int EmbedBuilder::color_from_rgb(int r, int g, int b) {
    return (r << 16) | (g << 8) | b;
}

int EmbedBuilder::color_from_hex(const std::string& hex) {
    std::string hex_color = hex;
    if (hex_color[0] == '#') {
        hex_color = hex_color.substr(1);
    }
    
    std::stringstream ss;
    ss << std::hex << hex_color;
    int color;
    ss >> color;
    
    return color;
}

} // namespace discord
=== END FILE ===

=== FILE: src/api/http_client.cpp ===
#include <discord/api/http_client.h>
#include <sstream>
#include <iostream>
#include <future>
#include <nlohmann/json.hpp>

namespace discord {

HTTPClient::HTTPClient(const std::string& token, const std::string& base_url) 
    : curl_(nullptr), running_(true), timeout_(30000), base_url_(base_url), token_(token) {
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl_ = curl_easy_init();
    
    if (!curl_) {
        throw std::runtime_error("Failed to initialize CURL");
    }
    
    worker_thread_ = std::thread(&HTTPClient::worker_loop, this);
}

HTTPClient::~HTTPClient() {
    shutdown();
    if (curl_) {
        curl_easy_cleanup(curl_);
    }
    curl_global_cleanup();
}

size_t HTTPClient::WriteCallback(void* contents, size_t size, size_t nmemb, std::string* userp) {
    userp->append((char*)contents, size * nmemb);
    return size * nmemb;
}

size_t HTTPClient::HeaderCallback(void* contents, size_t size, size_t nmemb, std::string* userp) {
    userp->append((char*)contents, size * nmemb);
    return size * nmemb;
}

void HTTPClient::worker_loop() {
    while (running_) {
        std::unique_lock<std::mutex> lock(queue_mutex_);
        queue_cv_.wait(lock, [this] { return !request_queue_.empty() || !running_; });
        
        if (!running_) break;
        
        auto* request = request_queue_.front();
        request_queue_.pop();
        lock.unlock();
        
        try {
            std::string response = perform_request(request->method, request->url, 
                                                  request->data, request->headers);
            
            nlohmann::json json_response;
            if (!response.empty()) {
                json_response = nlohmann::json::parse(response);
            }
            
            request->promise.set_value(json_response);
        } catch (const std::exception& e) {
            request->promise.set_exception(std::current_exception());
        }
        
        delete request;
    }
}

std::string HTTPClient::perform_request(const std::string& method, const std::string& url, 
                                         const nlohmann::json& data, const IHttpClient::Headers& headers) {
    std::string response;
    std::string header_response;
    
    curl_easy_reset(curl_);
    curl_easy_setopt(curl_, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl_, CURLOPT_WRITEFUNCTION, WriteCallback);
    curl_easy_setopt(curl_, CURLOPT_WRITEDATA, &response);
    curl_easy_setopt(curl_, CURLOPT_HEADERFUNCTION, HeaderCallback);
    curl_easy_setopt(curl_, CURLOPT_HEADERDATA, &header_response);
    curl_easy_setopt(curl_, CURLOPT_TIMEOUT_MS, timeout_.count());
    curl_easy_setopt(curl_, CURLOPT_FOLLOWLOCATION, 1L);
    curl_easy_setopt(curl_, CURLOPT_SSL_VERIFYPEER, 1L);
    curl_easy_setopt(curl_, CURLOPT_SSL_VERIFYHOST, 2L);
    
    // Set default headers including authorization
    IHttpClient::Headers all_headers = get_default_headers();
    for (const auto& header : headers) {
        all_headers.push_back(header);
    }
    
    // Set headers
    struct curl_slist* chunk = nullptr;
    for (const auto& header : all_headers) {
        std::string header_str = header.first + ": " + header.second;
        chunk = curl_slist_append(chunk, header_str.c_str());
    }
    
    if (method == "GET") {
        curl_easy_setopt(curl_, CURLOPT_HTTPGET, 1L);
    } else if (method == "POST") {
        curl_easy_setopt(curl_, CURLOPT_POST, 1L);
        std::string json_str = data.dump();
        curl_easy_setopt(curl_, CURLOPT_POSTFIELDS, json_str.c_str());
        chunk = curl_slist_append(chunk, "Content-Type: application/json");
    } else if (method == "PUT") {
        curl_easy_setopt(curl_, CURLOPT_CUSTOMREQUEST, "PUT");
        std::string json_str = data.dump();
        curl_easy_setopt(curl_, CURLOPT_POSTFIELDS, json_str.c_str());
        chunk = curl_slist_append(chunk, "Content-Type: application/json");
    } else if (method == "PATCH") {
        curl_easy_setopt(curl_, CURLOPT_CUSTOMREQUEST, "PATCH");
        std::string json_str = data.dump();
        curl_easy_setopt(curl_, CURLOPT_POSTFIELDS, json_str.c_str());
        chunk = curl_slist_append(chunk, "Content-Type: application/json");
    } else if (method == "DELETE") {
        curl_easy_setopt(curl_, CURLOPT_CUSTOMREQUEST, "DELETE");
    }
    
    curl_easy_setopt(curl_, CURLOPT_HTTPHEADER, chunk);
    
    CURLcode res = curl_easy_perform(curl_);
    
    curl_slist_free_all(chunk);
    
    if (res != CURLE_OK) {
        throw std::runtime_error("CURL error: " + std::string(curl_easy_strerror(res)));
    }
    
    long response_code;
    curl_easy_getinfo(curl_, CURLINFO_RESPONSE_CODE, &response_code);
    
    if (response_code >= 400) {
        std::string error_msg = "HTTP error " + std::to_string(response_code);
        if (!response.empty()) {
            try {
                auto json_response = nlohmann::json::parse(response);
                if (json_response.contains("message")) {
                    error_msg += ": " + json_response["message"].get<std::string>();
                }
            } catch (...) {
                // Ignore JSON parsing errors for error messages
            }
        }
        throw std::runtime_error(error_msg);
    }
    
    return response;
}

std::future<nlohmann::json> HTTPClient::get(const std::string& url, const IHttpClient::Headers& headers) {
    auto request = new Request{"GET", base_url_ + url, {}, headers, {}};
    auto future = request->promise.get_future();
    
    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        request_queue_.push(request);
    }
    queue_cv_.notify_one();
    
    return future;
}

std::future<nlohmann::json> HTTPClient::post(const std::string& url, const nlohmann::json& data, const IHttpClient::Headers& headers) {
    auto request = new Request{"POST", base_url_ + url, data, headers, {}};
    auto future = request->promise.get_future();
    
    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        request_queue_.push(request);
    }
    queue_cv_.notify_one();
    
    return future;
}

std::future<nlohmann::json> HTTPClient::put(const std::string& url, const nlohmann::json& data, const IHttpClient::Headers& headers) {
    auto request = new Request{"PUT", base_url_ + url, data, headers, {}};
    auto future = request->promise.get_future();
    
    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        request_queue_.push(request);
    }
    queue_cv_.notify_one();
    
    return future;
}

std::future<nlohmann::json> HTTPClient::patch(const std::string& url, const nlohmann::json& data, const IHttpClient::Headers& headers) {
    auto request = new Request{"PATCH", base_url_ + url, data, headers, {}};
    auto future = request->promise.get_future();
    
    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        request_queue_.push(request);
    }
    queue_cv_.notify_one();
    
    return future;
}

std::future<nlohmann::json> HTTPClient::delete_(const std::string& url, const IHttpClient::Headers& headers) {
    auto request = new Request{"DELETE", base_url_ + url, {}, headers, {}};
    auto future = request->promise.get_future();
    
    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        request_queue_.push(request);
    }
    queue_cv_.notify_one();
    
    return future;
}

std::future<void> HTTPClient::set_timeout(std::chrono::milliseconds timeout) {
    auto promise = std::promise<void>();
    auto future = promise.get_future();
    
    timeout_ = timeout;
    promise.set_value();
    
    return future;
}

void HTTPClient::shutdown() {
    running_ = false;
    queue_cv_.notify_all();
    
    if (worker_thread_.joinable()) {
        worker_thread_.join();
    }
    
    // Clear remaining requests
    std::lock_guard<std::mutex> lock(queue_mutex_);
    while (!request_queue_.empty()) {
        auto* request = request_queue_.front();
        request_queue_.pop();
        request->promise.set_exception(std::make_exception_ptr(
            std::runtime_error("HTTP client shutting down")));
        delete request;
    }
}

IHttpClient::Headers HTTPClient::get_default_headers() const {
    IHttpClient::Headers headers;
    headers.emplace_back("Authorization", "Bot " + token_);
    headers.emplace_back("User-Agent", "DiscordBot (https://github.com/discordcpp/discord.cpp, 1.0.0)");
    headers.emplace_back("Content-Type", "application/json");
    return headers;
}

void HTTPClient::set_base_url(const std::string& url) {
    base_url_ = url;
}

void HTTPClient::set_token(const std::string& token) {
    token_ = token;
}

} // namespace discord
=== END FILE ===

=== FILE: src/api/rate_limiter.cpp ===
#include <discord/api/rate_limiter.h>
#include <algorithm>

namespace discord {

RateLimiter::RateLimiter() = default;
RateLimiter::~RateLimiter() = default;

void RateLimiter::update_limits(const std::string& endpoint, const RateLimitInfo& info) {
    std::lock_guard<std::mutex> lock(mutex_);
    rate_limits_[endpoint] = info;
    
    if (info.global) {
        global_reset_time_ = info.reset_time;
    }
}

bool RateLimiter::can_make_request(const std::string& endpoint) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto now = std::chrono::steady_clock::now();
    
    if (now < global_reset_time_) {
        return false;
    }
    
    auto it = rate_limits_.find(endpoint);
    if (it != rate_limits_.end() && it->second.remaining >= 0) {
        if (it->second.remaining == 0 && now < it->second.reset_time) {
            return false;
        }
    }
    
    auto endpoint_it = endpoint_limits_.find(endpoint);
    if (endpoint_it != endpoint_limits_.end()) {
        cleanup_old_requests(endpoint);
        if (endpoint_it->second.request_times.size() >= static_cast<size_t>(endpoint_it->second.max_requests)) {
            return false;
        }
    }
    
    return true;
}

void RateLimiter::wait_if_needed(const std::string& endpoint) {
    auto wait_time = get_wait_time(endpoint);
    if (wait_time.count() > 0) {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_.wait_for(lock, wait_time);
    }
}

void RateLimiter::set_global_limit(std::chrono::milliseconds delay) {
    std::lock_guard<std::mutex> lock(mutex_);
    global_reset_time_ = std::chrono::steady_clock::now() + delay;
}

void RateLimiter::set_endpoint_limit(const std::string& endpoint, int max_requests, std::chrono::milliseconds window) {
    std::lock_guard<std::mutex> lock(mutex_);
    endpoint_limits_[endpoint] = {max_requests, window, {}};
}

void RateLimiter::cleanup_old_requests(const std::string& endpoint) {
    auto it = endpoint_limits_.find(endpoint);
    if (it == endpoint_limits_.end()) return;
    
    auto now = std::chrono::steady_clock::now();
    auto cutoff = now - it->second.window;
    
    while (!it->second.request_times.empty() && it->second.request_times.front() < cutoff) {
        it->second.request_times.pop();
    }
}

std::chrono::milliseconds RateLimiter::get_wait_time(const std::string& endpoint) {
    auto now = std::chrono::steady_clock::now();
    
    if (now < global_reset_time_) {
        return std::chrono::duration_cast<std::chrono::milliseconds>(global_reset_time_ - now);
    }
    
    auto it = rate_limits_.find(endpoint);
    if (it != rate_limits_.end() && it->second.remaining == 0 && now < it->second.reset_time) {
        return std::chrono::duration_cast<std::chrono::milliseconds>(it->second.reset_time - now);
    }
    
    auto endpoint_it = endpoint_limits_.find(endpoint);
    if (endpoint_it != endpoint_limits_.end()) {
        cleanup_old_requests(endpoint);
        if (endpoint_it->second.request_times.size() >= static_cast<size_t>(endpoint_it->second.max_requests)) {
            auto oldest_request = endpoint_it->second.request_times.front();
            auto reset_time = oldest_request + endpoint_it->second.window;
            if (reset_time > now) {
                return std::chrono::duration_cast<std::chrono::milliseconds>(reset_time - now);
            }
        }
    }
    
    return std::chrono::milliseconds(0);
}

RequestQueue::RequestQueue() = default;
RequestQueue::~RequestQueue() {
    stop();
}

void RequestQueue::enqueue(const std::string& endpoint, RequestFunction request) {
    {
        std::lock_guard<std::mutex> lock(mutex_);
        requests_.push({endpoint, std::move(request), std::chrono::steady_clock::now()});
    }
    cv_.notify_one();
}

void RequestQueue::start() {
    if (running_) return;
    
    running_ = true;
    worker_thread_ = std::thread(&RequestQueue::process_requests, this);
}

void RequestQueue::stop() {
    if (!running_) return;
    
    running_ = false;
    cv_.notify_all();
    
    if (worker_thread_.joinable()) {
        worker_thread_.join();
    }
}

void RequestQueue::set_rate_limiter(std::shared_ptr<RateLimiter> rate_limiter) {
    rate_limiter_ = std::move(rate_limiter);
}

void RequestQueue::process_requests() {
    while (running_) {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_.wait(lock, [this] { return !requests_.empty() || !running_; });
        
        if (!running_) break;
        
        if (requests_.empty()) continue;
        
        auto request = requests_.front();
        requests_.pop();
        lock.unlock();
        
        if (rate_limiter_) {
            rate_limiter_->wait_if_needed(request.endpoint);
        }
        
        try {
            request.function();
        } catch (const std::exception& e) {
            // Log error and continue
        }
    }
}

}
=== END FILE ===

=== FILE: src/api/rest_endpoints.cpp ===
#include <discord/api/rest_endpoints.h>
#include <discord/api/http_client.h>
#include <memory>
#include <cstdlib>

namespace discord {

static HTTPClient* get_http_client() {
    static HTTPClient* client = nullptr;
    if (!client) {
        const char* token = std::getenv("DISCORD_BOT_TOKEN");
        if (!token) {
            throw std::runtime_error("DISCORD_BOT_TOKEN environment variable not set");
        }
        client = new HTTPClient(token);
    }
    return client;
}

nlohmann::json APIEndpoints::get_user(const std::string& user_id) {
    return get_http_client()->get("/users/" + user_id).get();
}

nlohmann::json APIEndpoints::get_current_user() {
    return get_http_client()->get("/users/@me").get();
}

nlohmann::json APIEndpoints::modify_current_user(const nlohmann::json& data) {
    return get_http_client()->patch("/users/@me", data).get();
}

nlohmann::json APIEndpoints::get_current_user_guilds() {
    return get_http_client()->get("/users/@me/guilds").get();
}

nlohmann::json APIEndpoints::leave_guild(const std::string& guild_id) {
    return get_http_client()->delete_("/users/@me/guilds/" + guild_id).get();
}

nlohmann::json APIEndpoints::get_guild(const std::string& guild_id) {
    return get_http_client()->get("/guilds/" + guild_id).get();
}

nlohmann::json APIEndpoints::get_guild_channels(const std::string& guild_id) {
    return get_http_client()->get("/guilds/" + guild_id + "/channels").get();
}

nlohmann::json APIEndpoints::get_guild_members(const std::string& guild_id, int limit, const std::string& after) {
    std::string endpoint = "/guilds/" + guild_id + "/members?limit=" + std::to_string(limit);
    if (!after.empty()) {
        endpoint += "&after=" + after;
    }
    return get_http_client()->get(endpoint).get();
}

nlohmann::json APIEndpoints::get_guild_member(const std::string& guild_id, const std::string& user_id) {
    return get_http_client()->get("/guilds/" + guild_id + "/members/" + user_id).get();
}

nlohmann::json APIEndpoints::get_channel(const std::string& channel_id) {
    return get_http_client()->get("/channels/" + channel_id).get();
}

nlohmann::json APIEndpoints::modify_channel(const std::string& channel_id, const nlohmann::json& data) {
    return get_http_client()->patch("/channels/" + channel_id, data).get();
}

nlohmann::json APIEndpoints::delete_channel(const std::string& channel_id) {
    return get_http_client()->delete_("/channels/" + channel_id).get();
}

nlohmann::json APIEndpoints::get_channel_messages(const std::string& channel_id, int limit, const std::string& before, const std::string& after, const std::string& around) {
    std::string endpoint = "/channels/" + channel_id + "/messages?limit=" + std::to_string(limit);
    if (!before.empty()) endpoint += "&before=" + before;
    if (!after.empty()) endpoint += "&after=" + after;
    if (!around.empty()) endpoint += "&around=" + around;
    return get_http_client()->get(endpoint).get();
}

nlohmann::json APIEndpoints::get_channel_message(const std::string& channel_id, const std::string& message_id) {
    return get_http_client()->get("/channels/" + channel_id + "/messages/" + message_id).get();
}

nlohmann::json APIEndpoints::send_message(const std::string& channel_id, const nlohmann::json& data) {
    return get_http_client()->post("/channels/" + channel_id + "/messages", data).get();
}

nlohmann::json APIEndpoints::edit_message(const std::string& channel_id, const std::string& message_id, const nlohmann::json& data) {
    return get_http_client()->patch("/channels/" + channel_id + "/messages/" + message_id, data).get();
}

nlohmann::json APIEndpoints::delete_message(const std::string& channel_id, const std::string& message_id) {
    return get_http_client()->delete_("/channels/" + channel_id + "/messages/" + message_id).get();
}

nlohmann::json APIEndpoints::create_interaction_response(const std::string& interaction_id, const std::string& interaction_token, const nlohmann::json& data) {
    return get_http_client()->post("/interactions/" + interaction_id + "/" + interaction_token + "/callback", data).get();
}

nlohmann::json APIEndpoints::get_original_interaction_response(const std::string& interaction_id, const std::string& interaction_token) {
    return get_http_client()->get("/webhooks/" + interaction_id + "/" + interaction_token + "/messages/@original").get();
}

nlohmann::json APIEndpoints::edit_original_interaction_response(const std::string& interaction_id, const std::string& interaction_token, const nlohmann::json& data) {
    return get_http_client()->patch("/webhooks/" + interaction_id + "/" + interaction_token + "/messages/@original", data).get();
}

nlohmann::json APIEndpoints::delete_original_interaction_response(const std::string& interaction_id, const std::string& interaction_token) {
    return get_http_client()->delete_("/webhooks/" + interaction_id + "/" + interaction_token + "/messages/@original").get();
}

nlohmann::json APIEndpoints::get_gateway() {
    return get_http_client()->get("/gateway").get();
}

nlohmann::json APIEndpoints::get_gateway_bot() {
    return get_http_client()->get("/gateway/bot").get();
}

// Reactions
nlohmann::json APIEndpoints::add_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji) {
    return get_http_client()->put("/channels/" + channel_id + "/messages/" + message_id + "/reactions/" + emoji + "/@me", {}).get();
}

nlohmann::json APIEndpoints::remove_reaction(const std::string& channel_id, const std::string& message_id, const std::string& emoji, const std::string& user_id) {
    std::string endpoint = "/channels/" + channel_id + "/messages/" + message_id + "/reactions/" + emoji;
    if (!user_id.empty()) {
        endpoint += "/" + user_id;
    } else {
        endpoint += "/@me";
    }
    return get_http_client()->delete_(endpoint).get();
}

// Webhooks
nlohmann::json APIEndpoints::edit_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id, const nlohmann::json& message) {
    return get_http_client()->patch("/webhooks/" + application_id + "/" + interaction_token + "/messages/" + message_id, message).get();
}

nlohmann::json APIEndpoints::delete_followup_message(const std::string& application_id, const std::string& interaction_token, const std::string& message_id) {
    return get_http_client()->delete_("/webhooks/" + application_id + "/" + interaction_token + "/messages/" + message_id).get();
}

// Guild roles
nlohmann::json APIEndpoints::create_guild_role(const std::string& guild_id, const nlohmann::json& role_data) {
    return get_http_client()->post("/guilds/" + guild_id + "/roles", role_data).get();
}

nlohmann::json APIEndpoints::delete_guild_role(const std::string& guild_id, const std::string& role_id) {
    return get_http_client()->delete_("/guilds/" + guild_id + "/roles/" + role_id).get();
}

nlohmann::json APIEndpoints::add_guild_member_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id) {
    return get_http_client()->put("/guilds/" + guild_id + "/members/" + user_id + "/roles/" + role_id, {}).get();
}

nlohmann::json APIEndpoints::remove_guild_member_role(const std::string& guild_id, const std::string& user_id, const std::string& role_id) {
    return get_http_client()->delete_("/guilds/" + guild_id + "/members/" + user_id + "/roles/" + role_id).get();
}

// Channel creation
nlohmann::json APIEndpoints::create_channel(const std::string& guild_id, const nlohmann::json& data) {
    return get_http_client()->post("/guilds/" + guild_id + "/channels", data).get();
}

} // namespace discord
=== END FILE ===

=== FILE: src/cache/cache_manager.cpp ===
#include <discord/cache/cache_manager.h>
#include <discord/utils/logger.h>
#include <discord/core/exceptions.h>
#include <algorithm>
#include <regex>
#include <cstring>

namespace discord {

CacheManager::CacheManager(const CacheConfig& config) 
    : config_(config)
    , last_cleanup_(std::chrono::system_clock::now())
    , cleanup_running_(false) {
    
    LOG_INFO("CacheManager initialized with max_entries: " + std::to_string(config_.max_entries));
}

CacheManager::~CacheManager() {
    std::lock_guard<std::mutex> lock(mutex_);
    cleanup_expired(true);
    LOG_INFO("CacheManager destroyed");
}

void CacheManager::set(const std::string& key, const nlohmann::json& value, std::chrono::seconds ttl) {
    if (key.empty()) {
        throw DiscordException("Cache key cannot be empty");
    }

    std::lock_guard<std::mutex> lock(mutex_);
    
    // Check if cleanup is needed
    if (should_cleanup()) {
        cleanup_expired();
    }

    // Check if we need to evict entries
    if (cache_.size() >= config_.max_entries) {
        evict_lru();
    }

    // Create new cache entry
    CacheEntry entry(value, ttl.count() > 0 ? ttl : config_.default_ttl);
    cache_[key] = std::move(entry);
    
    update_stats();
    LOG_DEBUG("Cache entry set: " + key);
}

std::optional<nlohmann::json> CacheManager::get(const std::string& key) {
    if (key.empty()) {
        return std::nullopt;
    }

    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = cache_.find(key);
    if (it == cache_.end()) {
        return std::nullopt;
    }

    // Check if entry is expired
    if (it->second.is_expired()) {
        cache_.erase(it);
        update_stats();
        LOG_DEBUG("Cache entry expired and removed: " + key);
        return std::nullopt;
    }

    LOG_DEBUG("Cache entry hit: " + key);
    return it->second.value;
}

void CacheManager::remove(const std::string& key) {
    if (key.empty()) {
        return;
    }

    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = cache_.find(key);
    if (it != cache_.end()) {
        notify_eviction(key, it->second.value);
        cache_.erase(it);
        update_stats();
        LOG_DEBUG("Cache entry removed: " + key);
    }
}

void CacheManager::clear() {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // Notify all entries before clearing
    for (const auto& [key, entry] : cache_) {
        notify_eviction(key, entry.value);
    }
    
    cache_.clear();
    update_stats();
    LOG_INFO("Cache cleared");
}

bool CacheManager::exists(const std::string& key) {
    if (key.empty()) {
        return false;
    }

    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = cache_.find(key);
    if (it == cache_.end()) {
        return false;
    }

    // Check if entry is expired
    if (it->second.is_expired()) {
        cache_.erase(it);
        update_stats();
        return false;
    }

    return true;
}

std::vector<std::string> CacheManager::keys(const std::string& pattern) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    std::vector<std::string> result;
    std::regex regex_pattern(pattern_to_regex(pattern));
    
    for (const auto& [key, entry] : cache_) {
        if (!entry.is_expired() && std::regex_match(key, regex_pattern)) {
            result.push_back(key);
        }
    }
    
    return result;
}

void CacheManager::set_config(const CacheConfig& config) {
    std::lock_guard<std::mutex> lock(mutex_);
    config_ = config;
    
    // If max entries decreased, evict excess entries
    if (cache_.size() > config_.max_entries) {
        evict_lru(cache_.size() - config_.max_entries);
    }
    
    LOG_INFO("Cache configuration updated");
}

const CacheConfig& CacheManager::get_config() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return config_;
}

CacheStats CacheManager::get_stats() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return stats_;
}

void CacheManager::force_cleanup() {
    std::lock_guard<std::mutex> lock(mutex_);
    cleanup_expired(true);
}

void CacheManager::add_eviction_callback(std::function<void(const std::string&, const nlohmann::json&)> callback) {
    std::lock_guard<std::mutex> lock(mutex_);
    eviction_callbacks_.push_back(std::move(callback));
}

void CacheManager::remove_eviction_callback(const std::function<void(const std::string&, const nlohmann::json&)>& callback) {
    std::lock_guard<std::mutex> lock(mutex_);
    eviction_callbacks_.erase(
        std::remove_if(eviction_callbacks_.begin(), eviction_callbacks_.end(),
            [&callback](const auto& cb) { 
                // Simple comparison by target address (not perfect but functional)
                return cb.target<void(*)(const std::string&, const nlohmann::json&)>() == 
                       callback.target<void(*)(const std::string&, const nlohmann::json&)>(); 
            }),
        eviction_callbacks_.end()
    );
}

void CacheManager::set_persistent(const std::string& key, const nlohmann::json& value) {
    if (key.empty()) {
        throw DiscordException("Cache key cannot be empty");
    }

    std::lock_guard<std::mutex> lock(mutex_);
    
    if (should_cleanup()) {
        cleanup_expired();
    }

    if (cache_.size() >= config_.max_entries) {
        evict_lru();
    }

    CacheEntry entry(value, std::chrono::seconds::zero(), true);
    cache_[key] = std::move(entry);
    
    update_stats();
    LOG_DEBUG("Persistent cache entry set: " + key);
}

std::unordered_map<std::string, nlohmann::json> CacheManager::get_multiple(const std::vector<std::string>& keys) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    std::unordered_map<std::string, nlohmann::json> result;
    
    for (const auto& key : keys) {
        auto it = cache_.find(key);
        if (it != cache_.end() && !it->second.is_expired()) {
            result[key] = it->second.value;
        }
    }
    
    return result;
}

void CacheManager::set_multiple(const std::unordered_map<std::string, nlohmann::json>& entries, 
                               std::chrono::seconds ttl) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    if (should_cleanup()) {
        cleanup_expired();
    }

    // Check if we need to evict entries
    size_t required_space = entries.size();
    if (cache_.size() + required_space > config_.max_entries) {
        evict_lru(required_space);
    }

    // Add all entries
    for (const auto& [key, value] : entries) {
        if (!key.empty()) {
            CacheEntry entry(value, ttl.count() > 0 ? ttl : config_.default_ttl);
            cache_[key] = std::move(entry);
        }
    }
    
    update_stats();
    LOG_DEBUG("Multiple cache entries set: " + std::to_string(entries.size()));
}

void CacheManager::remove_multiple(const std::vector<std::string>& keys) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    for (const auto& key : keys) {
        auto it = cache_.find(key);
        if (it != cache_.end()) {
            notify_eviction(key, it->second.value);
            cache_.erase(it);
        }
    }
    
    update_stats();
    LOG_DEBUG("Multiple cache entries removed: " + std::to_string(keys.size()));
}

std::vector<std::pair<std::string, nlohmann::json>> CacheManager::get_matching(const std::string& pattern) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    std::vector<std::pair<std::string, nlohmann::json>> result;
    std::regex regex_pattern(pattern_to_regex(pattern));
    
    for (const auto& [key, entry] : cache_) {
        if (!entry.is_expired() && std::regex_match(key, regex_pattern)) {
            result.emplace_back(key, entry.value);
        }
    }
    
    return result;
}

size_t CacheManager::get_memory_usage() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return stats_.memory_usage_bytes;
}

size_t CacheManager::size() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return cache_.size();
}

bool CacheManager::empty() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return cache_.empty();
}

std::chrono::seconds CacheManager::get_ttl(const std::string& key) const {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = cache_.find(key);
    if (it == cache_.end() || it->second.is_expired()) {
        return std::chrono::seconds(0);
    }
    
    if (it->second.is_persistent) {
        return std::chrono::seconds::max();
    }
    
    auto now = std::chrono::system_clock::now();
    if (it->second.expires_at <= now) {
        return std::chrono::seconds(0);
    }
    
    return std::chrono::duration_cast<std::chrono::seconds>(it->second.expires_at - now);
}

void CacheManager::update_ttl(const std::string& key, std::chrono::seconds ttl) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = cache_.find(key);
    if (it != cache_.end() && !it->second.is_persistent) {
        if (ttl.count() > 0) {
            it->second.expires_at = std::chrono::system_clock::now() + ttl;
        } else {
            it->second.expires_at = std::chrono::system_clock::time_point::max();
        }
        LOG_DEBUG("TTL updated for key: " + key);
    }
}

nlohmann::json CacheManager::export_cache() const {
    std::lock_guard<std::mutex> lock(mutex_);
    
    nlohmann::json export_data;
    export_data["entries"] = nlohmann::json::object();
    
    for (const auto& [key, entry] : cache_) {
        if (!entry.is_expired()) {
            nlohmann::json entry_data;
            entry_data["value"] = entry.value;
            entry_data["created_at"] = std::chrono::duration_cast<std::chrono::seconds>(
                entry.created_at.time_since_epoch()).count();
            entry_data["expires_at"] = std::chrono::duration_cast<std::chrono::seconds>(
                entry.expires_at.time_since_epoch()).count();
            entry_data["is_persistent"] = entry.is_persistent;
            
            export_data["entries"][key] = entry_data;
        }
    }
    
    export_data["config"] = {
        {"max_entries", config_.max_entries},
        {"default_ttl", config_.default_ttl.count()},
        {"cleanup_interval", config_.cleanup_interval.count()},
        {"enable_persistence", config_.enable_persistence},
        {"enable_compression", config_.enable_compression},
        {"cleanup_threshold", config_.cleanup_threshold}
    };
    
    return export_data;
}

void CacheManager::import_cache(const nlohmann::json& data, bool overwrite) {
    if (!data.contains("entries")) {
        return;
    }

    std::lock_guard<std::mutex> lock(mutex_);
    
    for (const auto& [key, entry_data] : data["entries"].items()) {
        if (key.empty()) {
            continue;
        }

        if (!overwrite && cache_.find(key) != cache_.end()) {
            continue;
        }

        try {
            nlohmann::json value = entry_data["value"];
            bool is_persistent = entry_data.value("is_persistent", false);
            
            auto created_at = std::chrono::system_clock::time_point(
                std::chrono::seconds(entry_data.value("created_at", 0)));
            auto expires_at = std::chrono::system_clock::time_point(
                std::chrono::seconds(entry_data.value("expires_at", 0)));
            
            CacheEntry entry(value);
            entry.created_at = created_at;
            entry.expires_at = expires_at;
            entry.is_persistent = is_persistent;
            
            cache_[key] = std::move(entry);
        } catch (const std::exception& e) {
            LOG_ERROR("Failed to import cache entry " + key + ": " + e.what());
        }
    }
    
    update_stats();
    LOG_INFO("Cache import completed");
}

// Private methods

size_t CacheManager::estimate_memory_usage(const nlohmann::json& value) const {
    // Rough estimation - in a real implementation, this would be more accurate
    std::string json_str = value.dump();
    return json_str.size() + sizeof(CacheEntry) + sizeof(std::string);
}

void CacheManager::cleanup_expired(bool force) {
    if (!force && !should_cleanup()) {
        return;
    }

    size_t removed_count = 0;
    auto it = cache_.begin();
    
    while (it != cache_.end()) {
        if (it->second.is_expired()) {
            notify_eviction(it->first, it->second.value);
            it = cache_.erase(it);
            removed_count++;
        } else {
            ++it;
        }
    }
    
    last_cleanup_ = std::chrono::system_clock::now();
    update_stats();
    
    if (removed_count > 0) {
        LOG_DEBUG("Cleaned up " + std::to_string(removed_count) + " expired cache entries");
    }
}

void CacheManager::evict_lru(size_t required_space) {
    if (cache_.empty()) {
        return;
    }

    // Simple LRU implementation - in practice, you'd want to track access times
    size_t to_remove = required_space > 0 ? required_space : 
                       static_cast<size_t>(cache_.size() * config_.cleanup_threshold);
    
    size_t removed = 0;
    auto it = cache_.begin();
    
    while (it != cache_.end() && removed < to_remove) {
        // Skip persistent entries during eviction
        if (!it->second.is_persistent) {
            notify_eviction(it->first, it->second.value);
            it = cache_.erase(it);
            removed++;
        } else {
            ++it;
        }
    }
    
    update_stats();
    LOG_DEBUG("Evicted " + std::to_string(removed) + " cache entries");
}

bool CacheManager::should_cleanup() const {
    auto now = std::chrono::system_clock::now();
    return (now - last_cleanup_) >= config_.cleanup_interval;
}

void CacheManager::update_stats() {
    stats_.total_entries = cache_.size();
    stats_.expired_entries = 0;
    stats_.persistent_entries = 0;
    stats_.memory_usage_bytes = 0;
    
    for (const auto& [key, entry] : cache_) {
        if (entry.is_expired()) {
            stats_.expired_entries++;
        }
        if (entry.is_persistent) {
            stats_.persistent_entries++;
        }
        stats_.memory_usage_bytes += key.size() + estimate_memory_usage(entry.value);
    }
    
    stats_.last_cleanup = last_cleanup_;
}

void CacheManager::notify_eviction(const std::string& key, const nlohmann::json& value) {
    for (const auto& callback : eviction_callbacks_) {
        try {
            callback(key, value);
        } catch (const std::exception& e) {
            LOG_ERROR("Eviction callback error: " + std::string(e.what()));
        }
    }
}

std::string CacheManager::pattern_to_regex(const std::string& pattern) const {
    // Convert simple wildcard pattern to regex
    std::string regex_pattern = pattern;
    std::replace(regex_pattern.begin(), regex_pattern.end(), '*', ".*");
    std::replace(regex_pattern.begin(), regex_pattern.end(), '?', ".");
    return "^" + regex_pattern + "$";
}

// CacheFactory implementation

std::shared_ptr<ICache> CacheFactory::create_memory_cache(const CacheConfig& config) {
    return std::make_shared<CacheManager>(config);
}

std::shared_ptr<ICache> CacheFactory::create_redis_cache(
    const CacheConfig& config,
    const std::string& connection_string
) {
    // TODO: Implement Redis cache when Redis support is added
    // For now, return memory cache as fallback
    LOG_WARN("Redis cache not implemented yet, falling back to memory cache");
    return create_memory_cache(config);
}

} // namespace discord
=== END FILE ===

=== FILE: src/cache/memory_cache.cpp ===
#include <discord/cache/memory_cache.h>
#include <algorithm>
#include <fnmatch.h>

namespace discord {

void MemoryCache::set(const std::string& key, const nlohmann::json& value, std::chrono::seconds ttl) {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    
    // Default TTL of 1 hour if not specified
    if (ttl == std::chrono::seconds{}) {
        ttl = std::chrono::seconds(3600);
    }
    
    cache_[key] = CacheEntry(value, ttl);
}

std::optional<nlohmann::json> MemoryCache::get(const std::string& key) {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    
    auto it = cache_.find(key);
    if (it == cache_.end()) {
        return std::nullopt;
    }
    
    if (it->second.is_expired()) {
        // Need to upgrade to unique lock to remove expired entry
        lock.unlock();
        std::unique_lock<std::shared_mutex> unique_lock(mutex_);
        cache_.erase(key);
        return std::nullopt;
    }
    
    return it->second.value;
}

void MemoryCache::remove(const std::string& key) {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    cache_.erase(key);
}

void MemoryCache::clear() {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    cache_.clear();
}

bool MemoryCache::exists(const std::string& key) {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    
    auto it = cache_.find(key);
    if (it == cache_.end()) {
        return false;
    }
    
    if (it->second.is_expired()) {
        lock.unlock();
        std::unique_lock<std::shared_mutex> unique_lock(mutex_);
        cache_.erase(key);
        return false;
    }
    
    return true;
}

std::vector<std::string> MemoryCache::keys(const std::string& pattern) {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    cleanup_expired();
    
    if (pattern == "*") {
        std::vector<std::string> all_keys;
        all_keys.reserve(cache_.size());
        for (const auto& pair : cache_) {
            all_keys.push_back(pair.first);
        }
        return all_keys;
    }
    
    return pattern_match(pattern);
}

void MemoryCache::cleanup_expired() {
    // This method should be called with a unique lock held
    auto now = std::chrono::system_clock::now();
    auto it = cache_.begin();
    
    while (it != cache_.end()) {
        if (it->second.is_expired()) {
            it = cache_.erase(it);
        } else {
            ++it;
        }
    }
}

std::vector<std::string> MemoryCache::pattern_match(const std::string& pattern) const {
    std::vector<std::string> matches;
    
    for (const auto& pair : cache_) {
        if (fnmatch(pattern.c_str(), pair.first.c_str(), 0) == 0) {
            matches.push_back(pair.first);
        }
    }
    
    return matches;
}

} // namespace discord
=== END FILE ===

=== FILE: src/cache/redis_cache.cpp ===

=== END FILE ===

=== FILE: src/gateway/websocket_client.cpp ===
#include <discord/gateway/websocket_client.h>
#include <discord/utils/logger.h>
#include <websocketpp/config/asio_client.hpp>
#include <websocketpp/client.hpp>
#include <zlib.h>
#include <iostream>
#include <vector>
#include <cstring>

namespace discord {

using websocket_client = websocketpp::client<websocketpp::config::asio_tls_client>;

class WebSocketClient::Impl {
public:
    Impl() : is_connected_(false), compression_enabled_(false), 
              zlib_stream_(), reconnect_manager_(std::make_unique<ReconnectionManager>()) {
        client_.set_access_channels(websocketpp::log::alevel::none);
        client_.clear_access_channels(websocketpp::log::alevel::all);
        client_.set_error_channels(websocketpp::log::elevel::none);
        
        client_.init_asio();
        
        client_.set_tls_init_handler([](websocketpp::connection_hdl) {
            auto ctx = std::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::tlsv12);
            ctx->set_options(boost::asio::ssl::context::default_workarounds);
            return ctx;
        });
        
        client_.set_open_handler([this](websocketpp::connection_hdl hdl) {
            is_connected_ = true;
            connection_hdl_ = hdl;
            reconnect_manager_->handle_connection_restored();
            LOG_INFO("WebSocket connection established");
        });
        
        client_.set_close_handler([this](websocketpp::connection_hdl hdl) {
            is_connected_ = false;
            auto con = client_.get_con_from_hdl(hdl);
            auto close_code = con->get_remote_close_reason();
            auto reason = con->get_remote_close_reason();
            
            LOG_WARN("WebSocket connection closed: " + std::to_string(close_code) + " " + reason);
            
            if (close_callback_) {
                close_callback_(close_code, reason);
            }
            
            // Handle reconnection
            reconnect_manager_->handle_disconnect(close_code, reason);
        });
        
        client_.set_message_handler([this](websocketpp::connection_hdl hdl, websocket_client::message_ptr msg) {
            try {
                std::string payload_str;
                
                // Check if message is compressed (binary messages)
                if (msg->get_opcode() == websocketpp::frame::opcode::binary) {
                    payload_str = decompress_message(msg->get_payload());
                } else {
                    payload_str = msg->get_payload();
                }
                
                auto payload = nlohmann::json::parse(payload_str);
                
                // Handle gateway events that affect reconnection
                if (payload.contains("op")) {
                    int opcode = payload["op"];
                    if (opcode == static_cast<int>(GatewayOpcode::HELLO)) {
                        // Start heartbeat
                        if (payload.contains("d") && payload["d"].contains("heartbeat_interval")) {
                            int interval = payload["d"]["heartbeat_interval"];
                            start_heartbeat(interval);
                        }
                    } else if (opcode == static_cast<int>(GatewayOpcode::INVALID_SESSION)) {
                        bool can_resume = payload.value("d", false);
                        reconnect_manager_->handle_invalid_session(can_resume);
                    } else if (opcode == static_cast<int>(GatewayOpcode::RECONNECT)) {
                        reconnect_manager_->handle_disconnect(1000, "Reconnect requested by Discord");
                    }
                }
                
                if (event_callback_) {
                    event_callback_(payload);
                }
            } catch (const std::exception& e) {
                LOG_ERROR("Failed to parse WebSocket message: " + std::string(e.what()));
            }
        });
        
        // Setup reconnection callbacks
        reconnect_manager_->set_callbacks(
            [this](bool should_resume) {
                if (should_resume) {
                    resume();
                } else {
                    identify();
                }
            },
            [this]() {
                resume();
            }
        );
    }
    
    bool connect(const std::string& url) {
        try {
            websocketpp::lib::error_code ec;
            websocket_client::connection_ptr con = client_.get_connection(url, ec);
            
            if (ec) {
                return false;
            }
            
            client_.connect(con);
            
            thread_ = std::thread([this]() {
                try {
                    client_.run();
                } catch (const std::exception& e) {
                    is_connected_ = false;
                }
            });
            
            return true;
        } catch (const std::exception& e) {
            return false;
        }
    }
    
    void disconnect() {
        if (is_connected_) {
            client_.close(connection_hdl_, websocketpp::close::status::normal, "");
        }
        if (thread_.joinable()) {
            thread_.join();
        }
    }
    
    bool is_connected() const {
        return is_connected_;
    }
    
    void send(const nlohmann::json& payload) {
        if (is_connected_) {
            try {
                client_.send(connection_hdl_, payload.dump(), websocketpp::frame::opcode::text);
            } catch (const std::exception& e) {
                // Silent error handling
            }
        }
    }
    
    void on_event(EventCallback callback) {
        event_callback_ = std::move(callback);
    }
    
    void on_close(CloseCallback callback) {
        close_callback_ = std::move(callback);
    }
    
    void set_token(const std::string& token) {
        token_ = token;
    }
    
    void set_intents(int intents) {
        intents_ = intents;
    }
    
    void identify() {
        nlohmann::json identify;
        identify["op"] = 2;
        identify["d"] = nlohmann::json{
            {"token", token_},
            {"intents", intents_},
            {"properties", nlohmann::json{
                {"os", "linux"},
                {"browser", "discord.cpp"},
                {"device", "discord.cpp"}
            }}
        };
        send(identify);
    }
    
    void resume() {
        if (session_id_.empty()) {
            identify();
            return;
        }
        
        nlohmann::json resume;
        resume["op"] = 6;
        resume["d"] = nlohmann::json{
            {"token", token_},
            {"session_id", session_id_},
            {"seq", last_sequence_}
        };
        send(resume);
        LOG_INFO("Attempting to resume session");
    }
    
    void start_heartbeat(int interval_ms) {
        if (heartbeat_thread_.joinable()) {
            heartbeat_thread_.join();
        }
        
        heartbeat_thread_ = std::thread([this, interval_ms]() {
            while (is_connected_) {
                std::this_thread::sleep_for(std::chrono::milliseconds(interval_ms));
                
                if (is_connected_) {
                    nlohmann::json heartbeat;
                    heartbeat["op"] = 1;
                    heartbeat["d"] = last_sequence_;
                    send(heartbeat);
                }
            }
        });
    }
    
    void enable_auto_reconnect(bool enabled) {
        reconnect_manager_->enable_auto_reconnect(enabled);
    }
    
    void set_reconnection_config(int max_retries, std::chrono::milliseconds base_delay, std::chrono::milliseconds max_delay) {
        reconnect_manager_->set_max_retries(max_retries);
        reconnect_manager_->set_base_delay(base_delay);
        reconnect_manager_->set_max_delay(max_delay);
    }
    
    bool is_reconnecting() const {
        return reconnect_manager_->is_reconnecting();
    }
    
    void stop_reconnecting() {
        reconnect_manager_->stop_reconnecting();
    }
    
    void enable_compression(bool enabled) {
        compression_enabled_ = enabled;
        if (enabled) {
            initialize_compression();
        } else {
            cleanup_compression();
        }
    }
    
    void initialize_compression() {
        compression_buffer_.resize(COMPRESSION_BUFFER_SIZE);
        
        zlib_stream_.zalloc = Z_NULL;
        zlib_stream_.zfree = Z_NULL;
        zlib_stream_.opaque = Z_NULL;
        zlib_stream_.avail_in = 0;
        zlib_stream_.next_in = Z_NULL;
        
        if (inflateInit2(&zlib_stream_, 15 + 32) != Z_OK) {
            LOG_ERROR("Failed to initialize zlib inflation");
            compression_enabled_ = false;
        }
    }
    
    void cleanup_compression() {
        if (compression_enabled_) {
            inflateEnd(&zlib_stream_);
        }
    }
    
    std::string decompress_message(const std::string& compressed_data) {
        if (!compression_enabled_) {
            return compressed_data;
        }
        
        // Discord sends zlib-compressed messages with 4-byte header
        if (compressed_data.size() < 4) {
            return compressed_data;
        }
        
        // Skip the 4-byte header
        const char* data_ptr = compressed_data.data() + 4;
        size_t data_size = compressed_data.size() - 4;
        
        zlib_stream_.avail_in = static_cast<uInt>(data_size);
        zlib_stream_.next_in = reinterpret_cast<const Bytef*>(data_ptr);
        
        std::string result;
        do {
            zlib_stream_.avail_out = static_cast<uInt>(compression_buffer_.size());
            zlib_stream_.next_out = compression_buffer_.data();
            
            int ret = inflate(&zlib_stream_, Z_NO_FLUSH);
            
            if (ret == Z_NEED_DICT || ret == Z_DATA_ERROR || ret == Z_MEM_ERROR) {
                LOG_ERROR("Zlib decompression error: " + std::to_string(ret));
                return compressed_data; // Return original data on error
            }
            
            size_t have = compression_buffer_.size() - zlib_stream_.avail_out;
            result.append(reinterpret_cast<char*>(compression_buffer_.data()), have);
            
        } while (zlib_stream_.avail_out == 0);
        
        return result;
    }

private:
    websocket_client client_;
    std::thread thread_;
    std::thread heartbeat_thread_;
    websocketpp::connection_hdl connection_hdl_;
    std::atomic<bool> is_connected_;
    std::string token_;
    int intents_;
    std::string session_id_;
    int last_sequence_;
    bool compression_enabled_;
    
    // Compression support
    z_stream zlib_stream_;
    std::vector<uint8_t> compression_buffer_;
    static constexpr size_t COMPRESSION_BUFFER_SIZE = 8192;
    
    EventCallback event_callback_;
    CloseCallback close_callback_;
    std::unique_ptr<ReconnectionManager> reconnect_manager_;
};

WebSocketClient::WebSocketClient() : pImpl(std::make_unique<Impl>()) {}

WebSocketClient::~WebSocketClient() = default;

bool WebSocketClient::connect(const std::string& url) {
    return pImpl->connect(url);
}

void WebSocketClient::disconnect() {
    pImpl->disconnect();
}

bool WebSocketClient::is_connected() const {
    return pImpl->is_connected();
}

void WebSocketClient::send(const nlohmann::json& payload) {
    pImpl->send(payload);
}

void WebSocketClient::on_event(EventCallback callback) {
    pImpl->on_event(std::move(callback));
}

void WebSocketClient::on_close(CloseCallback callback) {
    pImpl->on_close(std::move(callback));
}

void WebSocketClient::set_token(const std::string& token) {
    pImpl->set_token(token);
}

void WebSocketClient::set_intents(int intents) {
    pImpl->set_intents(intents);
}

void WebSocketClient::identify() {
    pImpl->identify();
}

void WebSocketClient::enable_auto_reconnect(bool enabled) {
    pImpl->enable_auto_reconnect(enabled);
}

void WebSocketClient::set_reconnection_config(int max_retries, 
                                           std::chrono::milliseconds base_delay,
                                           std::chrono::milliseconds max_delay) {
    pImpl->set_reconnection_config(max_retries, base_delay, max_delay);
}

bool WebSocketClient::is_reconnecting() const {
    return pImpl->is_reconnecting();
}

void WebSocketClient::stop_reconnecting() {
    pImpl->stop_reconnecting();
}

void WebSocketClient::enable_compression(bool enabled) {
    pImpl->enable_compression(enabled);
}

bool WebSocketClient::is_compression_enabled() const {
    return pImpl->compression_enabled_;
}

} // namespace discord
=== END FILE ===

=== FILE: src/gateway/shard_manager.cpp ===
#include <discord/gateway/shard_manager.h>
#include <discord/utils/logger.h>
#include <discord/api/rest_endpoints.h>
#include <discord/core/exceptions.h>
#include <algorithm>
#include <random>
#include <sstream>
#include <iomanip>

namespace discord {

ShardManager::ShardManager(const std::string& token, const ShardConfig& config)
    : config_(config), bot_token_(token) {
    
    if (!validate_config()) {
        throw DiscordException("Invalid shard configuration");
    }
    
    // Get gateway information
    session_info_ = get_gateway_info();
    
    if (config_.auto_sharding) {
        config_.shard_count = calculate_shard_count();
    }
    
    LOG_INFO("ShardManager initialized with " + std::to_string(config_.shard_count) + " shards");
}

ShardManager::~ShardManager() {
    stop();
}

bool ShardManager::start() {
    if (is_running_.load()) {
        LOG_WARN("ShardManager is already running");
        return false;
    }
    
    if (!validate_config()) {
        LOG_ERROR("Invalid shard configuration");
        return false;
    }
    
    is_running_ = true;
    is_shutting_down_ = false;
    
    LOG_INFO("Starting " + std::to_string(config_.shard_count) + " shards");
    
    // Start connection threads with concurrency limits
    for (int i = 0; i < config_.shard_count; ++i) {
        if (!can_start_session()) {
            wait_for_session_slot();
        }
        
        connection_threads_.emplace_back([this, i]() {
            if (is_shutting_down_.load()) return;
            
            try {
                connect_shard(i);
            } catch (const std::exception& e) {
                LOG_ERROR("Failed to connect shard " + std::to_string(i) + ": " + e.what());
            }
        });
        
        // Add delay between connections to respect rate limits
        if (i < config_.shard_count - 1) {
            std::this_thread::sleep_for(config_.connection_delay);
        }
    }
    
    // Wait for all connection threads to complete
    for (auto& thread : connection_threads_) {
        if (thread.joinable()) {
            thread.join();
        }
    }
    
    connection_threads_.clear();
    
    LOG_INFO("All shards started");
    return true;
}

void ShardManager::stop() {
    if (!is_running_.load()) {
        return;
    }
    
    is_shutting_down_ = true;
    is_running_ = false;
    
    LOG_INFO("Stopping all shards");
    
    // Disconnect all shards
    std::lock_guard<std::mutex> lock(mutex_);
    for (auto& [shard_id, client] : shards_) {
        if (client) {
            client->disconnect();
        }
    }
    
    // Wait for connection threads
    for (auto& thread : connection_threads_) {
        if (thread.joinable()) {
            thread.join();
        }
    }
    
    connection_threads_.clear();
    shards_.clear();
    shard_info_.clear();
    
    LOG_INFO("All shards stopped");
}

bool ShardManager::connect_shard_by_id(int shard_id) {
    if (shard_id < 0 || shard_id >= config_.shard_count) {
        LOG_ERROR("Invalid shard ID: " + std::to_string(shard_id));
        return false;
    }
    
    std::lock_guard<std::mutex> lock(mutex_);
    connect_shard(shard_id);
    return true;
}

void ShardManager::disconnect_shard_by_id(int shard_id) {
    std::lock_guard<std::mutex> lock(mutex_);
    disconnect_shard(shard_id);
}

void ShardManager::reconnect_shard(int shard_id, bool resume) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = shards_.find(shard_id);
    if (it != shards_.end()) {
        disconnect_shard(shard_id);
        
        if (resume && shard_info_[shard_id].is_resumable) {
            // Attempt resume after a short delay
            std::this_thread::sleep_for(std::chrono::milliseconds(1000));
            connect_shard(shard_id);
        } else {
            // Force identify
            shard_info_[shard_id].session_id.clear();
            shard_info_[shard_id].sequence_number = 0;
            connect_shard(shard_id);
        }
    }
}

void ShardManager::reconnect_all(bool resume) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    for (int i = 0; i < config_.shard_count; ++i) {
        if (shards_.find(i) != shards_.end()) {
            disconnect_shard(i);
        }
    }
    
    // Wait a bit before reconnecting
    std::this_thread::sleep_for(std::chrono::milliseconds(2000));
    
    for (int i = 0; i < config_.shard_count; ++i) {
        if (!resume || !shard_info_[i].is_resumable) {
            shard_info_[i].session_id.clear();
            shard_info_[i].sequence_number = 0;
        }
        connect_shard(i);
        
        if (i < config_.shard_count - 1) {
            std::this_thread::sleep_for(config_.connection_delay);
        }
    }
}

bool ShardManager::send_to_shard(int shard_id, const nlohmann::json& event) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = shards_.find(shard_id);
    if (it != shards_.end() && it->second) {
        it->second->send(event);
        return true;
    }
    
    return false;
}

int ShardManager::send_to_all_shards(const nlohmann::json& event) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    int sent_count = 0;
    for (auto& [shard_id, client] : shards_) {
        if (client) {
            client->send(event);
            sent_count++;
        }
    }
    
    return sent_count;
}

const ShardInfo* ShardManager::get_shard_info(int shard_id) const {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = shard_info_.find(shard_id);
    if (it != shard_info_.end()) {
        return &it->second;
    }
    
    return nullptr;
}

std::unordered_map<int, ShardInfo> ShardManager::get_all_shard_info() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return shard_info_;
}

int ShardManager::get_connected_shard_count() const {
    std::lock_guard<std::mutex> lock(mutex_);
    
    int count = 0;
    for (const auto& [shard_id, info] : shard_info_) {
        if (info.is_connected) {
            count++;
        }
    }
    
    return count;
}

int ShardManager::get_total_shard_count() const {
    return config_.shard_count;
}

bool ShardManager::is_running() const {
    return is_running_.load();
}

bool ShardManager::is_shard_connected(int shard_id) const {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = shard_info_.find(shard_id);
    if (it != shard_info_.end()) {
        return it->second.is_connected;
    }
    
    return false;
}

void ShardManager::set_event_callback(EventCallback callback) {
    event_callback_ = std::move(callback);
}

void ShardManager::set_shard_state_callback(ShardStateCallback callback) {
    shard_state_callback_ = std::move(callback);
}

void ShardManager::set_ready_callback(ReadyCallback callback) {
    ready_callback_ = std::move(callback);
}

void ShardManager::set_config(const ShardConfig& config) {
    if (is_running_.load()) {
        LOG_WARN("Cannot update configuration while ShardManager is running");
        return;
    }
    
    config_ = config;
}

const ShardConfig& ShardManager::get_config() const {
    return config_;
}

const GatewaySession& ShardManager::get_session_info() const {
    return session_info_;
}

void ShardManager::identify_all() {
    std::lock_guard<std::mutex> lock(mutex_);
    
    for (auto& [shard_id, info] : shard_info_) {
        info.session_id.clear();
        info.sequence_number = 0;
        info.is_resumable = false;
    }
    
    reconnect_all(false);
}

void ShardManager::resume_all() {
    reconnect_all(true);
}

nlohmann::json ShardManager::get_statistics() const {
    std::lock_guard<std::mutex> lock(mutex_);
    
    nlohmann::json stats;
    stats["total_shards"] = config_.shard_count;
    stats["connected_shards"] = get_connected_shard_count();
    stats["is_running"] = is_running_.load();
    stats["sessions_started_recently"] = sessions_started_recently_.load();
    
    nlohmann::json shard_stats = nlohmann::json::object();
    for (const auto& [shard_id, info] : shard_info_) {
        nlohmann::json shard_info;
        shard_info["is_connected"] = info.is_connected;
        shard_info["is_resumable"] = info.is_resumable;
        shard_info["reconnect_attempts"] = info.reconnect_attempts;
        shard_info["sequence_number"] = info.sequence_number;
        
        auto now = std::chrono::steady_clock::now();
        auto uptime = std::chrono::duration_cast<std::chrono::seconds>(now - info.connect_time);
        shard_info["uptime_seconds"] = uptime.count();
        
        shard_stats[std::to_string(shard_id)] = shard_info;
    }
    
    stats["shards"] = shard_stats;
    return stats;
}

void ShardManager::set_auto_reconnect(bool enabled) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    for (auto& [shard_id, client] : shards_) {
        if (client) {
            client->enable_auto_reconnect(enabled);
        }
    }
}

void ShardManager::set_reconnection_config(int max_retries,
                                        std::chrono::milliseconds base_delay,
                                        std::chrono::milliseconds max_delay) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    for (auto& [shard_id, client] : shards_) {
        if (client) {
            client->set_reconnection_config(max_retries, base_delay, max_delay);
        }
    }
}

// Private methods

bool ShardManager::initialize_shard(int shard_id) {
    if (shard_id < 0 || shard_id >= config_.shard_count) {
        return false;
    }
    
    std::lock_guard<std::mutex> lock(mutex_);
    
    // Create shard info if it doesn't exist
    if (shard_info_.find(shard_id) == shard_info_.end()) {
        shard_info_.emplace(shard_id, ShardInfo(shard_id, config_.shard_count));
    }
    
    // Create WebSocket client if it doesn't exist
    if (shards_.find(shard_id) == shards_.end()) {
        auto client = std::make_unique<WebSocketClient>();
        client->set_token(bot_token_);
        client->set_intents(0); // Will be set by caller
        
        // Set up event handlers
        client->on_event([this, shard_id](const nlohmann::json& event) {
            handle_shard_event(shard_id, event);
        });
        
        shards_[shard_id] = std::move(client);
    }
    
    return true;
}

void ShardManager::connect_shard(int shard_id) {
    if (!initialize_shard(shard_id)) {
        return;
    }
    
    auto& shard = shards_[shard_id];
    auto& info = shard_info_[shard_id];
    
    LOG_INFO("Connecting shard " + std::to_string(shard_id));
    
    // Update session start limits
    sessions_started_recently_++;
    update_session_limits();
    
    // Connect to gateway
    std::string url = get_gateway_url();
    if (shard->connect(url)) {
        info.is_connected = true;
        info.connect_time = std::chrono::steady_clock::now();
        info.reconnect_attempts = 0;
        
        // Send identify or resume
        if (info.is_resumable && !info.session_id.empty()) {
            resume_shard(shard_id, nlohmann::json{});
        } else {
            identify_shard(shard_id);
        }
        
        if (shard_state_callback_) {
            shard_state_callback_(shard_id, true);
        }
        
        LOG_INFO("Shard " + std::to_string(shard_id) + " connected successfully");
    } else {
        info.is_connected = false;
        info.reconnect_attempts++;
        
        LOG_ERROR("Failed to connect shard " + std::to_string(shard_id));
        
        if (shard_state_callback_) {
            shard_state_callback_(shard_id, false);
        }
    }
}

void ShardManager::disconnect_shard(int shard_id) {
    auto it = shards_.find(shard_id);
    if (it != shards_.end() && it->second) {
        it->second->disconnect();
        
        auto& info = shard_info_[shard_id];
        info.is_connected = false;
        
        if (shard_state_callback_) {
            shard_state_callback_(shard_id, false);
        }
        
        LOG_INFO("Shard " + std::to_string(shard_id) + " disconnected");
    }
}

void ShardManager::handle_shard_event(int shard_id, const nlohmann::json& event) {
    auto& info = shard_info_[shard_id];
    
    // Update sequence number for dispatch events
    if (event.contains("op") && event["op"] == 0 && event.contains("s")) {
        info.sequence_number = event.value("s", 0);
    }
    
    // Handle specific events
    if (event.contains("t")) {
        std::string event_type = event["t"];
        
        if (event_type == "READY") {
            handle_shard_ready(shard_id, event["d"]);
        } else if (event_type == "RESUMED") {
            handle_shard_resume(shard_id, event["d"]);
        }
    }
    
    // Forward to user callback
    if (event_callback_) {
        event_callback_(shard_id, event);
    }
}

void ShardManager::handle_shard_ready(int shard_id, const nlohmann::json& ready_data) {
    auto& info = shard_info_[shard_id];
    
    info.session_id = ready_data.value("session_id", "");
    info.is_resumable = true;
    info.sequence_number = 0;
    
    LOG_INFO("Shard " + std::to_string(shard_id) + " is ready");
    
    if (ready_callback_) {
        ready_callback_(shard_id, ready_data);
    }
}

void ShardManager::handle_shard_resume(int shard_id, const nlohmann::json& resume_data) {
    auto& info = shard_info_[shard_id];
    
    info.is_resumable = true;
    
    LOG_INFO("Shard " + std::to_string(shard_id) + " resumed successfully");
}

GatewaySession ShardManager::get_gateway_info() {
    try {
        auto response = APIEndpoints::get_gateway_bot();
        
        GatewaySession session;
        session.url = response.value("url", "");
        session.shards = response.value("shards", 1);
        
        if (response.contains("session_start_limit")) {
            auto limit = response["session_start_limit"];
            session.session_start_limit_total = limit.value("total", 1000);
            session.session_start_limit_remaining = limit.value("remaining", 1000);
            session.session_start_limit_reset_after = limit.value("reset_after", 0);
            session.last_reset = std::chrono::steady_clock::now();
        }
        
        return session;
    } catch (const std::exception& e) {
        LOG_ERROR("Failed to get gateway info: " + std::string(e.what()));
        
        // Return default session info
        GatewaySession session;
        session.url = "wss://gateway.discord.gg/?v=10&encoding=json";
        session.shards = 1;
        session.session_start_limit_total = 1000;
        session.session_start_limit_remaining = 1000;
        session.session_start_limit_reset_after = 86400000;
        session.last_reset = std::chrono::steady_clock::now();
        
        return session;
    }
}

int ShardManager::calculate_shard_count() {
    if (session_info_.shards > 0) {
        return session_info_.shards;
    }
    
    // Default to 1 shard if we can't determine the optimal count
    return 1;
}

bool ShardManager::can_start_session() {
    update_session_limits();
    return session_info_.can_start_session();
}

void ShardManager::wait_for_session_slot() {
    while (!can_start_session() && !is_shutting_down_.load()) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        update_session_limits();
    }
}

void ShardManager::update_session_limits() {
    auto now = std::chrono::steady_clock::now();
    auto time_since_reset = std::chrono::duration_cast<std::chrono::milliseconds>(
        now - session_info_.last_reset);
    
    // Reset if enough time has passed
    if (time_since_reset.count() >= session_info_.session_start_limit_reset_after) {
        session_info_.session_start_limit_remaining = session_info_.session_start_limit_total;
        session_info_.last_reset = now;
        sessions_started_recently_ = 0;
        last_session_reset_ = now;
    }
}

int ShardManager::get_shard_for_guild(const std::string& guild_id) {
    if (config_.shard_count <= 1) {
        return 0;
    }
    
    try {
        uint64_t guild_id_num = std::stoull(guild_id);
        return static_cast<int>((guild_id_num >> 22) % config_.shard_count);
    } catch (const std::exception&) {
        return 0;
    }
}

bool ShardManager::validate_config() const {
    return config_.shard_count > 0 && 
           config_.max_concurrency > 0 &&
           !bot_token_.empty();
}

std::string ShardManager::get_gateway_url() const {
    std::string url = session_info_.url;
    
    if (url.empty()) {
        url = "wss://gateway.discord.gg/?v=10&encoding=json";
    }
    
    // Add compression if enabled
    if (config_.compress) {
        url += "&compress=zlib-stream";
    }
    
    return url;
}

void ShardManager::identify_shard(int shard_id) {
    auto& shard = shards_[shard_id];
    auto& info = shard_info_[shard_id];
    
    nlohmann::json identify;
    identify["op"] = 2;
    identify["d"] = nlohmann::json{
        {"token", bot_token_},
        {"intents", 0}, // Will be set by caller
        {"properties", nlohmann::json{
            {"os", "linux"},
            {"browser", "discord.cpp"},
            {"device", "discord.cpp"}
        }},
        {"shard", nlohmann::json::array({shard_id, config_.shard_count})}
    };
    
    shard->send(identify);
    LOG_DEBUG("Sent IDENTIFY for shard " + std::to_string(shard_id));
}

void ShardManager::resume_shard(int shard_id, const nlohmann::json& resume_data) {
    auto& shard = shards_[shard_id];
    auto& info = shard_info_[shard_id];
    
    nlohmann::json resume;
    resume["op"] = 6;
    resume["d"] = nlohmann::json{
        {"token", bot_token_},
        {"session_id", info.session_id},
        {"seq", info.sequence_number}
    };
    
    shard->send(resume);
    LOG_DEBUG("Sent RESUME for shard " + std::to_string(shard_id));
}

// ShardFactory implementation

ShardConfig ShardFactory::create_small_bot_config() {
    ShardConfig config;
    config.shard_count = 1;
    config.max_concurrency = 1;
    config.connection_delay = std::chrono::milliseconds(5000);
    return config;
}

ShardConfig ShardFactory::create_medium_bot_config() {
    ShardConfig config;
    config.shard_count = 4;
    config.max_concurrency = 2;
    config.connection_delay = std::chrono::milliseconds(2500);
    return config;
}

ShardConfig ShardFactory::create_large_bot_config() {
    ShardConfig config;
    config.shard_count = 16;
    config.max_concurrency = 4;
    config.connection_delay = std::chrono::milliseconds(1000);
    return config;
}

int ShardFactory::calculate_optimal_shards(int guild_count) {
    // Discord recommends 1 shard per 1000-2500 guilds
    const int guilds_per_shard = 2000;
    return std::max(1, (guild_count + guilds_per_shard - 1) / guilds_per_shard);
}

ShardConfig ShardFactory::create_config_for_guild_count(int guild_count) {
    int shard_count = calculate_optimal_shards(guild_count);
    
    ShardConfig config;
    config.shard_count = shard_count;
    config.max_concurrency = std::min(4, shard_count);
    config.connection_delay = std::chrono::milliseconds(std::max(500, 5000 / shard_count));
    
    return config;
}

} // namespace discord
=== END FILE ===

=== FILE: src/gateway/gateway_events.cpp ===

=== END FILE ===

=== FILE: src/gateway/reconnection.cpp ===
#include <discord/gateway/reconnection.h>
#include <random>
#include <algorithm>

namespace discord {

ReconnectionManager::ReconnectionManager() = default;
ReconnectionManager::~ReconnectionManager() {
    stop_reconnecting();
}

void ReconnectionManager::set_callbacks(ReconnectCallback reconnect_cb, ResumeCallback resume_cb) {
    std::lock_guard<std::mutex> lock(mutex_);
    reconnect_callback_ = std::move(reconnect_cb);
    resume_callback_ = std::move(resume_cb);
}

void ReconnectionManager::handle_disconnect(int close_code, const std::string& reason) {
    if (!auto_reconnect_enabled_.load()) {
        return;
    }
    
    std::lock_guard<std::mutex> lock(mutex_);
    
    bool can_resume = is_resumable_close_code(close_code) && session_info_.can_resume;
    
    if (can_resume) {
        session_info_.can_resume = true;
    } else {
        session_info_.can_resume = false;
        session_info_.session_id.clear();
        session_info_.sequence_number = 0;
    }
    
    start_reconnect_sequence();
}

void ReconnectionManager::handle_invalid_session(bool can_resume) {
    {
        std::lock_guard<std::mutex> lock(mutex_);
        session_info_.can_resume = can_resume;
        if (!can_resume) {
            session_info_.session_id.clear();
            session_info_.sequence_number = 0;
        }
    }
    
    start_reconnect_sequence();
}

void ReconnectionManager::handle_connection_restored() {
    {
        std::lock_guard<std::mutex> lock(mutex_);
        is_reconnecting_ = false;
        current_retry_count_ = 0;
        should_stop_ = true;
        cv_.notify_all();
    }
    
    if (reconnect_thread_.joinable()) {
        reconnect_thread_.join();
    }
}

void ReconnectionManager::enable_auto_reconnect(bool enabled) {
    auto_reconnect_enabled_ = enabled;
}

void ReconnectionManager::set_max_retries(int max_retries) {
    max_retries_ = max_retries;
}

void ReconnectionManager::set_base_delay(std::chrono::milliseconds delay) {
    base_delay_ = delay;
}

void ReconnectionManager::set_max_delay(std::chrono::milliseconds delay) {
    max_delay_ = delay;
}

bool ReconnectionManager::should_resume() const {
    std::lock_guard<std::mutex> lock(const_cast<std::mutex&>(mutex_));
    return session_info_.can_resume && !session_info_.session_id.empty();
}

bool ReconnectionManager::is_reconnecting() const {
    return is_reconnecting_;
}

void ReconnectionManager::stop_reconnecting() {
    should_stop_ = true;
    cv_.notify_all();
    
    if (reconnect_thread_.joinable()) {
        reconnect_thread_.join();
    }
}

void ReconnectionManager::reset_session() {
    std::lock_guard<std::mutex> lock(mutex_);
    session_info_.session_id.clear();
    session_info_.sequence_number = 0;
    session_info_.can_resume = false;
}

void ReconnectionManager::attempt_reconnection() {
    bool should_resume = this->should_resume();
    
    if (reconnect_callback_) {
        reconnect_callback_(should_resume);
    }
    
    if (should_resume && resume_callback_) {
        resume_callback_();
    }
}

std::chrono::milliseconds ReconnectionManager::calculate_backoff_delay(int attempt) const {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.8, 1.2);
    
    auto base = base_delay_.load();
    auto max_delay = max_delay_.load();
    
    auto delay = std::chrono::milliseconds(
        static_cast<long long>(base.count() * std::pow(2, attempt) * dis(gen))
    );
    
    return std::min(delay, max_delay);
}

void ReconnectionManager::exponential_backoff_reconnect() {
    while (!should_stop_.load() && current_retry_count_.load() < max_retries_.load()) {
        auto delay = calculate_backoff_delay(current_retry_count_.load());
        
        {
            std::unique_lock<std::mutex> lock(mutex_);
            if (cv_.wait_for(lock, delay, [this] { return should_stop_.load(); })) {
                return;
            }
        }
        
        if (should_stop_.load()) break;
        
        attempt_reconnection();
        current_retry_count_++;
        
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    }
    
    is_reconnecting_ = false;
}

bool ReconnectionManager::is_resumable_close_code(int close_code) const {
    switch (close_code) {
        case 1000: // Normal Closure
        case 1001: // Going Away
        case 1006: // Abnormal Closure
        case 1009: // Message Too Big
        case 1011: // Internal Server Error
        case 1012: // Service Restart
        case 1013: // Try Again Later
        case 1014: // Bad Gateway
            return true;
        case 4000: // Unknown Error
        case 4001: // Unknown Opcode
        case 4002: // Decode Error
        case 4003: // Not Authenticated
        case 4004: // Authentication Failed
        case 4005: // Already Authenticated
        case 4007: // Invalid Seq
        case 4008: // Rate Limited
        case 4009: // Session Timed Out
        case 4010: // Invalid Shard
        case 4011: // Sharding Required
        case 4012: // Invalid API Version
        case 4013: // Invalid Intents
        case 4014: // Disallowed Intents
            return false;
        default:
            return close_code >= 1000 && close_code < 2000;
    }
}

void ReconnectionManager::start_reconnect_sequence() {
    if (is_reconnecting_.load()) {
        return;
    }
    
    is_reconnecting_ = true;
    current_retry_count_ = 0;
    should_stop_ = false;
    
    if (reconnect_thread_.joinable()) {
        reconnect_thread_.join();
    }
    
    reconnect_thread_ = std::thread(&ReconnectionManager::exponential_backoff_reconnect, this);
}

}
=== END FILE ===

=== FILE: src/events/event_dispatcher.cpp ===
#include <discord/events/event_dispatcher.h>
#include <discord/utils/logger.h>
#include <algorithm>
#include <random>
#include <regex>
#include <condition_variable>

namespace discord {

// EventCollector template implementations

template<typename T>
std::string EventCollector<T>::start(EventDispatcher* dispatcher, const std::string& event_name) {
    if (is_active_) {
        return handler_id_;
    }
    
    std::string collector_id = "collector_" + std::to_string(reinterpret_cast<uintptr_t>(this));
    handler_id_ = collector_id;
    is_active_ = true;
    start_time_ = std::chrono::steady_clock::now();
    
    // Register collector callback with dispatcher
    auto callback = [this](const nlohmann::json& event) {
        if (!is_active_) {
            return;
        }
        
        try {
            T typed_event = event; // This requires T to be constructible from json
            if (!filter_ || filter_(typed_event)) {
                std::unique_lock<std::shared_mutex> lock(mutex_);
                collected_items_.push_back(std::move(typed_event));
                
                if (should_stop_collecting()) {
                    lock.unlock();
                    stop();
                }
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Event collector error: " + std::string(e.what()));
        }
    };
    
    dispatcher->on(event_name, std::move(callback), 0, collector_id);
    return collector_id;
}

template<typename T>
void EventCollector<T>::stop() {
    if (!is_active_) {
        return;
    }
    
    is_active_ = false;
    
    // TODO: Remove handler from dispatcher
    // This requires dispatcher to provide removal by ID
}

template<typename T>
bool EventCollector<T>::process_event(const nlohmann::json& event) {
    if (!is_active_) {
        return false;
    }
    
    if (is_timed_out()) {
        if (config_.dispose_on_timeout) {
            stop();
        }
        return false;
    }
    
    try {
        T typed_event = event;
        if (!filter_ || filter_(typed_event)) {
            std::unique_lock<std::shared_mutex> lock(mutex_);
            collected_items_.push_back(std::move(typed_event));
            
            return should_stop_collecting();
        }
    } catch (const std::exception& e) {
        LOG_ERROR("Event collector processing error: " + std::string(e.what()));
    }
    
    return false;
}

template<typename T>
std::optional<T> EventCollector<T>::wait_for_first(std::chrono::milliseconds timeout) {
    auto deadline = std::chrono::steady_clock::now() + timeout;
    
    while (is_active_ && std::chrono::steady_clock::now() < deadline) {
        {
            std::shared_lock<std::shared_mutex> lock(mutex_);
            if (!collected_items_.empty()) {
                return collected_items_.front();
            }
        }
        
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
    
    return first();
}

template<typename T>
std::vector<T> EventCollector<T>::wait_for_all(std::chrono::milliseconds timeout) {
    auto deadline = std::chrono::steady_clock::now() + timeout;
    
    while (is_active_ && std::chrono::steady_clock::now() < deadline) {
        {
            std::shared_lock<std::shared_mutex> lock(mutex_);
            if (should_stop_collecting()) {
                return collected_items_;
            }
        }
        
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
    
    return get_collected();
}

// EventDispatcher implementation

EventDispatcher::EventDispatcher() 
    : start_time_(std::chrono::steady_clock::now()) {
    LOG_INFO("EventDispatcher initialized");
}

EventDispatcher::~EventDispatcher() {
    clear();
    LOG_INFO("EventDispatcher destroyed");
}

std::string EventDispatcher::on(const std::string& event_name, 
                               EventCallback callback,
                               int priority,
                               const std::string& handler_id,
                               bool once) {
    std::string final_handler_id = handler_id;
    if (final_handler_id.empty()) {
        final_handler_id = "handler_" + std::to_string(reinterpret_cast<uintptr_t>(callback.target_type()));
    }
    
    std::unique_lock<std::shared_mutex> lock(handlers_mutex_);
    
    EventHandlerInfo info(std::move(callback), priority, final_handler_id, once);
    handlers_[event_name].push_back(std::move(info));
    
    // Sort handlers by priority (higher priority first)
    sort_handlers(handlers_[event_name]);
    
    LOG_DEBUG("Registered handler for event: " + event_name + " with ID: " + final_handler_id);
    return final_handler_id;
}

bool EventDispatcher::off(const std::string& event_name, const std::string& handler_id) {
    std::unique_lock<std::shared_mutex> lock(handlers_mutex_);
    
    auto it = handlers_.find(event_name);
    if (it == handlers_.end()) {
        return false;
    }
    
    auto& handlers = it->second;
    auto handler_it = std::remove_if(handlers.begin(), handlers.end(),
        [&handler_id](const EventHandlerInfo& info) {
            return info.id == handler_id;
        });
    
    bool removed = handler_it != handlers.end();
    if (removed) {
        LOG_DEBUG("Removed handler for event: " + event_name + " with ID: " + handler_id);
    }
    
    return removed;
}

size_t EventDispatcher::off_all(const std::string& event_name) {
    std::unique_lock<std::shared_mutex> lock(handlers_mutex_);
    
    auto it = handlers_.find(event_name);
    if (it == handlers_.end()) {
        return 0;
    }
    
    size_t count = it->second.size();
    handlers_.erase(it);
    
    LOG_DEBUG("Removed all " + std::to_string(count) + " handlers for event: " + event_name);
    return count;
}

void EventDispatcher::emit(const std::string& event_name, const nlohmann::json& event_data) {
    update_stats();
    
    execute_middleware_chain(event_name, event_data, [this, &event_name, &event_data]() {
        std::shared_lock<std::shared_mutex> lock(handlers_mutex_);
        
        auto it = handlers_.find(event_name);
        if (it == handlers_.end()) {
            return;
        }
        
        // Copy handlers to avoid holding lock during execution
        auto handlers = it->second;
        lock.unlock();
        
        std::vector<EventHandlerInfo> to_remove;
        
        for (auto& handler_info : handlers) {
            try {
                handler_info.callback(event_data);
                handlers_executed_++;
                
                if (handler_info.once) {
                    to_remove.push_back(handler_info);
                }
            } catch (const std::exception& e) {
                LOG_ERROR("Event handler error for " + event_name + ": " + std::string(e.what()));
            }
        }
        
        // Remove one-time handlers
        if (!to_remove.empty()) {
            std::unique_lock<std::shared_mutex> write_lock(handlers_mutex_);
            auto& handler_list = handlers_[event_name];
            
            for (const auto& remove_info : to_remove) {
                handler_list.erase(
                    std::remove_if(handler_list.begin(), handler_list.end(),
                        [&remove_info](const EventHandlerInfo& info) {
                            return info.id == remove_info.id;
                        })
                );
            }
        }
    });
}

void EventDispatcher::emit_filtered(const std::string& event_name,
                                const nlohmann::json& event_data,
                                const std::vector<EventFilter>& filters) {
    // Apply all filters - if any returns false, don't emit
    for (const auto& filter : filters) {
        if (!filter || !filter(event_data)) {
            return;
        }
    }
    
    emit(event_name, event_data);
}

std::optional<nlohmann::json> EventDispatcher::wait_for(const std::string& event_name,
                                                    EventFilter filter,
                                                    std::chrono::milliseconds timeout) {
    std::optional<nlohmann::json> result;
    std::condition_variable cv;
    std::mutex cv_mutex;
    bool event_received = false;
    
    auto handler_id = on(event_name, [&result, &event_received, &cv](const nlohmann::json& event) {
        if (!filter || filter(event)) {
            result = event;
            event_received = true;
            cv.notify_one();
        }
    }, 0, "", true); // Remove after first match
    
    std::unique_lock<std::mutex> lock(cv_mutex);
    cv.wait_for(lock, timeout, [&event_received] { return event_received; });
    
    if (!event_received) {
        off(event_name, handler_id);
    }
    
    return result;
}

template<typename T>
std::shared_ptr<EventCollector<T>> EventDispatcher::create_collector(const std::string& event_name,
                                                               typename EventCollector<T>::FilterFunction filter,
                                                               const CollectorConfig& config) {
    auto collector = std::make_shared<EventCollector<T>>(filter, config);
    std::string handler_id = collector->start(this, event_name);
    
    // Track collector for cleanup
    {
        std::unique_lock<std::shared_mutex> lock(collectors_mutex_);
        active_collectors_[handler_id] = collector;
    }
    
    return collector;
}

void EventDispatcher::add_middleware(std::shared_ptr<IEventMiddleware> middleware) {
    std::unique_lock<std::shared_mutex> lock(middleware_mutex_);
    middleware_.push_back(std::move(middleware));
    
    // Sort by priority (higher priority first)
    std::sort(middleware_.begin(), middleware_.end(),
        [](const auto& a, const auto& b) {
            return a->get_priority() > b->get_priority();
        });
    
    LOG_DEBUG("Added middleware: " + middleware->get_name());
}

bool EventDispatcher::remove_middleware(const std::string& middleware_name) {
    std::unique_lock<std::shared_mutex> lock(middleware_mutex_);
    
    auto it = std::remove_if(middleware_.begin(), middleware_.end(),
        [&middleware_name](const auto& middleware) {
            return middleware->get_name() == middleware_name;
        });
    
    bool removed = it != middleware_.end();
    if (removed) {
        LOG_DEBUG("Removed middleware: " + middleware_name);
    }
    
    return removed;
}

std::vector<EventHandlerInfo> EventDispatcher::get_handlers(const std::string& event_name) const {
    std::shared_lock<std::shared_mutex> lock(handlers_mutex_);
    
    auto it = handlers_.find(event_name);
    if (it == handlers_.end()) {
        return {};
    }
    
    return it->second;
}

nlohmann::json EventDispatcher::get_statistics() const {
    auto now = std::chrono::steady_clock::now();
    auto uptime = std::chrono::duration_cast<std::chrono::seconds>(now - start_time_);
    
    std::shared_lock<std::shared_mutex> handlers_lock(handlers_mutex_);
    std::shared_lock<std::shared_mutex> collectors_lock(collectors_mutex_);
    
    size_t total_handlers = 0;
    for (const auto& [event_name, handlers] : handlers_) {
        total_handlers += handlers.size();
    }
    
    nlohmann::json stats;
    stats["uptime_seconds"] = uptime.count();
    stats["events_dispatched"] = events_dispatched_.load();
    stats["handlers_executed"] = handlers_executed_.load();
    stats["total_handlers"] = total_handlers;
    stats["active_collectors"] = active_collectors_.size();
    stats["event_types"] = nlohmann::json::object();
    
    for (const auto& [event_name, handlers] : handlers_) {
        stats["event_types"][event_name] = handlers.size();
    }
    
    return stats;
}

void EventDispatcher::reset_statistics() {
    events_dispatched_ = 0;
    handlers_executed_ = 0;
    start_time_ = std::chrono::steady_clock::now();
    
    LOG_INFO("EventDispatcher statistics reset");
}

void EventDispatcher::handle_dispatch(const nlohmann::json& payload) {
    if (!payload.contains("t") || !payload.contains("d")) {
        return;
    }
    
    std::string event_name = payload["t"];
    nlohmann::json event_data = payload["d"];
    
    emit(event_name, event_data);
}

size_t EventDispatcher::get_handler_count() const {
    std::shared_lock<std::shared_mutex> lock(handlers_mutex_);
    
    size_t total = 0;
    for (const auto& [event_name, handlers] : handlers_) {
        total += handlers.size();
    }
    
    return total;
}

size_t EventDispatcher::get_active_collector_count() const {
    std::shared_lock<std::shared_mutex> lock(collectors_mutex_);
    return active_collectors_.size();
}

void EventDispatcher::clear() {
    {
        std::unique_lock<std::shared_mutex> handlers_lock(handlers_mutex_);
        handlers_.clear();
    }
    
    {
        std::unique_lock<std::shared_mutex> collectors_lock(collectors_mutex_);
        
        // Stop all active collectors
        for (auto& [handler_id, collector_ptr] : active_collectors_) {
            // TODO: Call stop on collectors when interface is available
            // This requires collectors to be stored with proper type
        }
        
        active_collectors_.clear();
    }
    
    LOG_INFO("EventDispatcher cleared all handlers and collectors");
}

// Private methods

void EventDispatcher::sort_handlers(std::vector<EventHandlerInfo>& handlers) const {
    std::sort(handlers.begin(), handlers.end(),
        [](const EventHandlerInfo& a, const EventHandlerInfo& b) {
            if (a.priority != b.priority) {
                return a.priority > b.priority; // Higher priority first
            }
            return a.created_at < b.created_at; // Earlier handlers first
        });
}

void EventDispatcher::execute_middleware_chain(const std::string& event_name,
                                         const nlohmann::json& event_data,
                                         std::function<void()> final_handler) {
    std::shared_lock<std::shared_mutex> lock(middleware_mutex_);
    
    if (middleware_.empty()) {
        lock.unlock();
        final_handler();
        return;
    }
    
    // Create middleware chain
    auto middleware_chain = middleware_;
    lock.unlock();
    
    size_t index = 0;
    std::function<void()> next_middleware = [&, final_handler]() {
        if (index >= middleware_chain.size()) {
            final_handler();
            return;
        }
        
        auto& middleware = middleware_chain[index];
        index++;
        
        // Continue to next middleware in chain
        auto next = [&, next_middleware]() {
            next_middleware();
        };
        
        if (!middleware->process(event_name, event_data, next)) {
            LOG_DEBUG("Middleware " + middleware->get_name() + " blocked event: " + event_name);
        }
    };
    
    // Start middleware chain
    next_middleware();
}

void EventDispatcher::update_stats() {
    events_dispatched_++;
}

// EventFilters namespace implementations

namespace EventFilters {

EventFilter by_user_id(const std::string& user_id) {
    return [user_id](const nlohmann::json& event) {
        if (event.contains("author") && event["author"].contains("id")) {
            return event["author"]["id"] == user_id;
        }
        return false;
    };
}

EventFilter by_channel_id(const std::string& channel_id) {
    return [channel_id](const nlohmann::json& event) {
        if (event.contains("channel_id")) {
            return event["channel_id"] == channel_id;
        }
        return false;
    };
}

EventFilter by_guild_id(const std::string& guild_id) {
    return [guild_id](const nlohmann::json& event) {
        if (event.contains("guild_id")) {
            return event["guild_id"] == guild_id;
        }
        return false;
    };
}

EventFilter by_content(const std::string& content) {
    return [content](const nlohmann::json& event) {
        if (!event.contains("content")) {
            return false;
        }
        
        // Support wildcards
        if (content.find('*') != std::string::npos) {
            try {
                std::regex pattern(content.replace("*", ".*"));
                return std::regex_match(event["content"], pattern);
            } catch (const std::exception&) {
                return event["content"] == content;
            }
        }
        
        return event["content"] == content;
    };
}

EventFilter by_bot(bool is_bot) {
    return [is_bot](const nlohmann::json& event) {
        if (event.contains("author") && event["author"].contains("bot")) {
            return event["author"]["bot"] == is_bot;
        }
        return false;
    };
}

EventFilter and_filter(const std::vector<EventFilter>& filters) {
    return [filters](const nlohmann::json& event) {
        for (const auto& filter : filters) {
            if (!filter || !filter(event)) {
                return false;
            }
        }
        return true;
    };
}

EventFilter or_filter(const std::vector<EventFilter>& filters) {
    return [filters](const nlohmann::json& event) {
        for (const auto& filter : filters) {
            if (filter && filter(event)) {
                return true;
            }
        }
        return false;
    };
}

EventFilter not_filter(EventFilter filter) {
    return [filter](const nlohmann::json& event) {
        return !filter || !filter(event);
    };
}

} // namespace EventFilters

// EventMiddleware namespace implementations

namespace EventMiddleware {

RateLimiter::RateLimiter(int max_events, std::chrono::milliseconds window)
    : max_events_per_window_(max_events), window_size_(window) {
    LOG_INFO("RateLimiter initialized: " + std::to_string(max_events) + " events per " + 
             std::to_string(window.count()) + "ms");
}

bool RateLimiter::process(const std::string& event_name,
                        const nlohmann::json& event_data,
                        std::function<void()> next) {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    
    auto now = std::chrono::steady_clock::now();
    auto& counter = counters_[event_name];
    
    // Reset counter if window has passed
    if (now - counter.second >= window_size_) {
        counter.first = 0;
        counter.second = now;
    }
    
    if (counter.first >= max_events_per_window_) {
        LOG_DEBUG("Rate limited event: " + event_name);
        return false;
    }
    
    counter.first++;
    lock.unlock();
    
    next();
    return true;
}

Logger::Logger(bool log_all) : log_all_events_(log_all) {
    LOG_INFO("Event Logger middleware initialized");
}

bool Logger::process(const std::string& event_name,
                    const nlohmann::json& event_data,
                    std::function<void()> next) {
    bool should_log = log_all_events_ || 
                     std::find(logged_events_.begin(), logged_events_.end(), event_name) != logged_events_.end();
    
    if (should_log) {
        LOG_DEBUG("Event: " + event_name + " | Data: " + event_data.dump());
    }
    
    next();
    return true;
}

void Validator::add_validator(const std::string& event_name, std::function<bool(const nlohmann::json&)> validator) {
    validators_[event_name] = std::move(validator);
    LOG_DEBUG("Added validator for event: " + event_name);
}

bool Validator::process(const std::string& event_name,
                      const nlohmann::json& event_data,
                      std::function<void()> next) {
    auto it = validators_.find(event_name);
    if (it != validators_.end()) {
        try {
            if (!it->second(event_data)) {
                LOG_WARN("Event validation failed: " + event_name);
                return false;
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Event validation error for " + event_name + ": " + std::string(e.what()));
            return false;
        }
    }
    
    next();
    return true;
}

} // namespace EventMiddleware

} // namespace discord
=== END FILE ===

=== FILE: src/events/event_handlers.cpp ===
#include <discord/events/event_handlers.h>
#include <discord/utils/logger.h>
#include <discord/events/event_dispatcher.h>

namespace discord {

EventHandlers::EventHandlers(EventDispatcher* dispatcher) 
    : dispatcher_(dispatcher) {
    LOG_INFO("EventHandlers initialized");
}

EventHandlers::~EventHandlers() {
    clear_all();
    LOG_INFO("EventHandlers destroyed");
}

std::string EventHandlers::register_handler(const std::string& event_name, 
                                       std::function<void(const nlohmann::json&)> callback,
                                       const std::string& handler_id) {
    if (!dispatcher_) {
        LOG_ERROR("EventDispatcher is null");
        return "";
    }
    
    std::string final_handler_id = handler_id;
    if (final_handler_id.empty()) {
        final_handler_id = "handler_" + std::to_string(reinterpret_cast<uintptr_t>(callback.target_type()));
    }
    
    std::string registered_id = dispatcher_->on(event_name, std::move(callback), 0, final_handler_id);
    registered_handler_ids_.push_back(registered_id);
    
    LOG_DEBUG("Registered handler for event: " + event_name + " with ID: " + final_handler_id);
    return final_handler_id;
}

// Message events

std::string EventHandlers::on_message(MessageCallback callback, MessageFilter filter) {
    auto wrapped_callback = [callback](const nlohmann::json& event) {
        if (!filter || filter(event)) {
            callback(event);
        }
    };
    
    return register_handler("MESSAGE_CREATE", std::move(wrapped_callback));
}

std::string EventHandlers::on_message_update(MessageCallback callback, MessageFilter filter) {
    auto wrapped_callback = [callback](const nlohmann::json& event) {
        if (!filter || filter(event)) {
            callback(event);
        }
    };
    
    return register_handler("MESSAGE_UPDATE", std::move(wrapped_callback));
}

std::string EventHandlers::on_message_delete(MessageCallback callback, MessageFilter filter) {
    auto wrapped_callback = [callback](const nlohmann::json& event) {
        if (!filter || filter(event)) {
            callback(event);
        }
    };
    
    return register_handler("MESSAGE_DELETE", std::move(wrapped_callback));
}

std::string EventHandlers::on_message_bulk_delete(MessageCallback callback) {
    return register_handler("MESSAGE_DELETE_BULK", std::move(callback));
}

// Reaction events

std::string EventHandlers::on_reaction_add(ReactionCallback callback, MessageFilter filter) {
    auto wrapped_callback = [callback](const nlohmann::json& event) {
        if (!filter || filter(event)) {
            callback(event);
        }
    };
    
    return register_handler("MESSAGE_REACTION_ADD", std::move(wrapped_callback));
}

std::string EventHandlers::on_reaction_remove(ReactionCallback callback, MessageFilter filter) {
    auto wrapped_callback = [callback](const nlohmann::json& event) {
        if (!filter || filter(event)) {
            callback(event);
        }
    };
    
    return register_handler("MESSAGE_REACTION_REMOVE", std::move(wrapped_callback));
}

std::string EventHandlers::on_reaction_clear(ReactionCallback callback, MessageFilter filter) {
    auto wrapped_callback = [callback](const nlohmann::json& event) {
        if (!filter || filter(event)) {
            callback(event);
        }
    };
    
    return register_handler("MESSAGE_REACTION_REMOVE_ALL", std::move(wrapped_callback));
}

// Guild events

std::string EventHandlers::on_guild_create(GuildCallback callback) {
    return register_handler("GUILD_CREATE", std::move(callback));
}

std::string EventHandlers::on_guild_update(GuildCallback callback) {
    return register_handler("GUILD_UPDATE", std::move(callback));
}

std::string EventHandlers::on_guild_delete(GuildCallback callback) {
    return register_handler("GUILD_DELETE", std::move(callback));
}

// Member events

std::string EventHandlers::on_member_join(MemberCallback callback, MessageFilter filter) {
    auto wrapped_callback = [callback](const nlohmann::json& event) {
        if (!filter || filter(event)) {
            callback(event);
        }
    };
    
    return register_handler("GUILD_MEMBER_ADD", std::move(wrapped_callback));
}

std::string EventHandlers::on_member_remove(MemberCallback callback, MessageFilter filter) {
    auto wrapped_callback = [callback](const nlohmann::json& event) {
        if (!filter || filter(event)) {
            callback(event);
        }
    };
    
    return register_handler("GUILD_MEMBER_REMOVE", std::move(wrapped_callback));
}

std::string EventHandlers::on_member_update(MemberCallback callback) {
    return register_handler("GUILD_MEMBER_UPDATE", std::move(callback));
}

// Channel events

std::string EventHandlers::on_channel_create(ChannelCallback callback) {
    return register_handler("CHANNEL_CREATE", std::move(callback));
}

std::string EventHandlers::on_channel_update(ChannelCallback callback) {
    return register_handler("CHANNEL_UPDATE", std::move(callback));
}

std::string EventHandlers::on_channel_delete(ChannelCallback callback) {
    return register_handler("CHANNEL_DELETE", std::move(callback));
}

// Voice events

std::string EventHandlers::on_voice_state_update(VoiceCallback callback) {
    return register_handler("VOICE_STATE_UPDATE", std::move(callback));
}

// Interaction events

std::string EventHandlers::on_interaction_create(InteractionCallback callback, MessageFilter filter) {
    auto wrapped_callback = [callback](const nlohmann::json& event) {
        if (!filter || filter(event)) {
            callback(event);
        }
    };
    
    return register_handler("INTERACTION_CREATE", std::move(wrapped_callback));
}

void EventHandlers::clear_all() {
    if (!dispatcher_) {
        return;
    }
    
    for (const auto& handler_id : registered_handler_ids_) {
        dispatcher_->off("", handler_id); // Remove all handlers by ID
    }
    
    registered_handler_ids_.clear();
    LOG_INFO("Cleared all event handlers");
}

size_t EventHandlers::get_handler_count() const {
    return registered_handler_ids_.size();
}

std::shared_ptr<EventCollector<nlohmann::json>> EventHandlers::create_message_collector(
        EventFilter filter,
        const CollectorConfig& config) {
    
    if (!dispatcher_) {
        LOG_ERROR("EventDispatcher is null");
        return nullptr;
    }
    
    return dispatcher_->create_collector<nlohmann::json>("MESSAGE_CREATE", filter, config);
}

std::shared_ptr<EventCollector<nlohmann::json>> EventHandlers::create_reaction_collector(
        EventFilter filter,
        const CollectorConfig& config) {
    
    if (!dispatcher_) {
        LOG_ERROR("EventDispatcher is null");
        return nullptr;
    }
    
    return dispatcher_->create_collector<nlohmann::json>("MESSAGE_REACTION_ADD", filter, config);
}

// EventUtils namespace implementations

namespace EventUtils {

std::string extract_message_id(const nlohmann::json& event) {
    if (event.contains("id")) {
        return event["id"];
    }
    return "";
}

std::string extract_channel_id(const nlohmann::json& event) {
    if (event.contains("channel_id")) {
        return event["channel_id"];
    }
    return "";
}

std::string extract_guild_id(const nlohmann::json& event) {
    if (event.contains("guild_id")) {
        return event["guild_id"];
    }
    return "";
}

std::string extract_user_id(const nlohmann::json& event) {
    if (event.contains("author") && event["author"].contains("id")) {
        return event["author"]["id"];
    }
    return "";
}

bool is_bot_message(const nlohmann::json& event) {
    if (event.contains("author") && event["author"].contains("bot")) {
        return event["author"]["bot"];
    }
    return false;
}

bool mentions_user(const nlohmann::json& event, const std::string& user_id) {
    if (!event.contains("mentions")) {
        return false;
    }
    
    for (const auto& mention : event["mentions"]) {
        if (mention.contains("id") && mention["id"] == user_id) {
            return true;
        }
    }
    
    return false;
}

bool is_in_channel(const nlohmann::json& event, const std::string& channel_id) {
    return extract_channel_id(event) == channel_id;
}

bool is_in_guild(const nlohmann::json& event, const std::string& guild_id) {
    return extract_guild_id(event) == guild_id;
}

} // namespace EventUtils

} // namespace discord
=== END FILE ===

=== FILE: src/events/middleware.cpp ===
#include <discord/events/middleware.h>
#include <discord/utils/logger.h>
#include <algorithm>
#include <chrono>

namespace discord {

// EventMiddleware implementation

EventMiddleware::EventMiddleware() {
    LOG_INFO("EventMiddleware initialized");
}

EventMiddleware::~EventMiddleware() {
    clear();
    LOG_INFO("EventMiddleware destroyed");
}

void EventMiddleware::add_middleware(std::shared_ptr<IEventMiddleware> middleware) {
    if (!middleware) {
        return;
    }
    
    std::unique_lock<std::shared_mutex> lock(mutex_);
    middleware_.push_back(std::move(middleware));
    sort_middleware();
    
    LOG_DEBUG("Added middleware: " + middleware->get_name());
}

bool EventMiddleware::remove_middleware(const std::string& middleware_name) {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    
    auto it = std::remove_if(middleware_.begin(), middleware_.end(),
        [&middleware_name](const auto& middleware) {
            return middleware->get_name() == middleware_name;
        });
    
    bool removed = it != middleware_.end();
    if (removed) {
        LOG_DEBUG("Removed middleware: " + middleware_name);
    }
    
    return removed;
}

void EventMiddleware::process_event(const std::string& event_name,
                                 const nlohmann::json& event_data,
                                 std::function<void()> final_handler) {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    
    // Process middleware chain
    size_t index = 0;
    auto next_middleware = [&, final_handler, &index, &event_name, &event_data]() {
        if (index >= middleware_.size()) {
            final_handler();
            return;
        }
        
        auto& middleware = middleware_[index];
        index++;
        
        auto next = [&, final_handler, &index, &event_name, &event_data]() {
            next_middleware();
        };
        
        if (!middleware->process(event_name, event_data, next)) {
            LOG_DEBUG("Middleware " + middleware->get_name() + " blocked event: " + event_name);
        }
    };
    
    // Start middleware chain
    if (middleware_.empty()) {
        final_handler();
    } else {
        next_middleware();
    }
}

std::vector<std::shared_ptr<IEventMiddleware>> EventMiddleware::get_middleware() const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    return middleware_;
}

void EventMiddleware::clear() {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    middleware_.clear();
    LOG_INFO("Cleared all middleware");
}

void EventMiddleware::sort_middleware() {
    std::sort(middleware_.begin(), middleware_.end(),
        [](const auto& a, const auto& b) {
            return a->get_priority() > b->get_priority();
        });
}

// BuiltInMiddleware implementations

namespace BuiltInMiddleware {

// Authentication middleware

Authentication::Authentication(const std::string& token, bool require_user_id)
    : bot_token_(token), require_user_id_(require_user_id) {
    LOG_INFO("Authentication middleware initialized");
}

bool Authentication::process(const std::string& event_name,
                              const nlohmann::json& event_data,
                              std::function<void()> next) {
    // TODO: Implement actual authentication logic
    // This would validate tokens, check user permissions, etc.
    LOG_DEBUG("Authentication middleware processing event: " + event_name);
    next();
    return true;
}

// PermissionChecker middleware

PermissionChecker::PermissionChecker(const std::unordered_map<std::string, uint64_t>& permissions)
    : required_permissions_(permissions) {
    LOG_INFO("PermissionChecker middleware initialized");
}

bool PermissionChecker::process(const std::string& event_name,
                              const nlohmann::json& event_data,
                              std::function<void()> next) {
    // TODO: Implement actual permission checking logic
    // This would check if the event has required permissions
    LOG_DEBUG("PermissionChecker middleware processing event: " + event_name);
    next();
    return true;
}

// Transformer middleware

Transformer::Transformer(const std::unordered_map<std::string, 
                                     std::function<nlohmann::json(nlohmann::json)>>& transformers)
    : transformers_(transformers) {
    LOG_INFO("Transformer middleware initialized");
}

bool Transformer::process(const std::string& event_name,
                        const nlohmann::json& event_data,
                        std::function<void()> next) {
    auto it = transformers_.find(event_name);
    if (it != transformers_.end()) {
        try {
            auto transformed_data = it->second(event_data);
            // TODO: Pass transformed data to next middleware
            // This requires modifying the event data flow
            LOG_DEBUG("Transformer middleware transformed event: " + event_name);
        } catch (const std::exception& e) {
            LOG_ERROR("Transformer middleware error: " + std::string(e.what()));
        }
    }
    
    next();
    return true;
}

// Filter middleware

Filter::Filter(const std::vector<EventFilter>& filters, const std::string& mode)
    : filters_(filters), filter_mode_(mode) {
    LOG_INFO("Filter middleware initialized with mode: " + mode);
}

bool Filter::process(const std::string& event_name,
                    const nlohmann::json& event_data,
                    std::function<void()> next) {
    bool should_pass = true;
    
    if (filter_mode_ == "all") {
        // All filters must pass
        should_pass = std::all_of(filters_.begin(), filters_.end(),
            [&event_data](const auto& filter) {
                return !filter || filter(event_data);
            });
    } else {
        // Any filter can pass
        should_pass = std::any_of(filters_.begin(), filters_.end(),
            [&event_data](const auto& filter) {
                return !filter || filter(event_data);
            });
    }
    
    if (should_pass) {
        next();
    } else {
        LOG_DEBUG("Filter middleware blocked event: " + event_name);
    }
    
    return should_pass;
}

// Cache middleware

Cache::Cache(size_t max_size, std::chrono::milliseconds ttl)
    : max_cache_size_(max_size), cache_ttl_(ttl) {
    LOG_INFO("Cache middleware initialized");
}

bool Cache::process(const std::string& event_name,
                  const nlohmann::json& event_data,
                  std::function<void()> next) {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    
    cleanup_cache();
    
    // Check if event is already cached
    auto& cache = event_cache_[event_name];
    auto it = std::find_if(cache.begin(), cache.end(),
        [&event_data](const nlohmann::json& cached_event) {
            return cached_event["id"] == event_data["id"];
        });
    
    if (it != cache.end()) {
        LOG_DEBUG("Cache middleware found cached event: " + event_name);
        return false; // Don't process duplicate
    }
    
    // Add to cache
    if (cache.size() >= max_cache_size_) {
        cache.erase(cache.begin()); // Remove oldest
    }
    
    nlohmann::json cached_event = event_data;
    cached_event["cached_at"] = std::chrono::duration_cast<std::chrono::seconds>(
        std::chrono::steady_clock::now().time_since_epoch()).count();
    
    cache.push_back(cached_event);
    
    lock.unlock();
    next();
    return true;
}

void Cache::cleanup_cache() {
    auto now = std::chrono::steady_clock::now();
    
    for (auto& [event_name, cache] : event_cache_) {
        auto it = std::remove_if(cache.begin(), cache.end(),
            [now, this](const nlohmann::json& cached_event) {
                if (!cached_event.contains("cached_at")) {
                    return true;
                }
                
                auto cached_at = std::chrono::seconds(cached_event["cached_at"]);
                auto event_time = std::chrono::steady_clock::time_point(
                    std::chrono::duration_cast<std::chrono::steady_clock::duration>(cached_at));
                
                return (now - event_time) > cache_ttl_;
            });
        
        if (it != cache.end()) {
            LOG_DEBUG("Cleaned up expired cached events for: " + event_name);
        }
    }
}

std::vector<nlohmann::json> Cache::get_cached_events(const std::string& event_name) const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    
    auto it = event_cache_.find(event_name);
    if (it != event_cache_.end()) {
        return it->second;
    }
    
    return {};
}

void Cache::clear_cache(const std::string& event_name) {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    
    auto it = event_cache_.find(event_name);
    if (it != event_cache_.end()) {
        it->second.clear();
        LOG_DEBUG("Cleared cache for event: " + event_name);
    }
}

// Metrics middleware

Metrics::Metrics() = default;

bool Metrics::process(const std::string& event_name,
                    const nlohmann::json& event_data,
                    std::function<void()> next) {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    
    auto now = std::chrono::steady_clock::now();
    
    event_counts_[event_name]++;
    last_event_times_[event_name] = now;
    
    LOG_DEBUG("Metrics middleware recorded event: " + event_name);
    next();
    return true;
}

nlohmann::json Metrics::get_metrics() const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    
    nlohmann::json metrics;
    metrics["event_counts"] = nlohmann::json::object();
    metrics["last_event_times"] = nlohmann::json::object();
    metrics["error_counts"] = error_counts_;
    
    for (const auto& [event_name, count] : event_counts_) {
        metrics["event_counts"][event_name] = count;
    }
    
    for (const auto& [event_name, time] : last_event_times_) {
        metrics["last_event_times"][event_name] = std::chrono::duration_cast<std::chrono::seconds>(
            time.time_since_epoch()).count();
    }
    
    return metrics;
}

void Metrics::reset_metrics() {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    
    event_counts_.clear();
    last_event_times_.clear();
    error_counts_.clear();
    
    LOG_INFO("Metrics middleware reset");
}

// Debugger middleware

Debugger::Debugger(const std::vector<std::string>& events, bool log_all, bool include_stack)
    : debug_events_(events), log_all_events_(log_all), include_stack_trace_(include_stack) {
    LOG_INFO("Debugger middleware initialized");
}

bool Debugger::process(const std::string& event_name,
                    const nlohmann::json& event_data,
                    std::function<void()> next) {
    bool should_log = log_all_events_ || 
                     std::find(debug_events_.begin(), debug_events_.end(), event_name) != debug_events_.end();
    
    if (should_log) {
        std::string debug_info = "DEBUG EVENT: " + event_name + " | " + event_data.dump();
        
        if (include_stack_trace_) {
            // TODO: Add stack trace information
            debug_info += " | STACK_TRACE";
        }
        
        LOG_DEBUG(debug_info);
    }
    
    next();
    return true;
}

} // namespace BuiltInMiddleware

// MiddlewareFactory implementations

std::shared_ptr<BuiltInMiddleware::Authentication> MiddlewareFactory::create_authentication(
        const std::string& token,
        bool require_user_id) {
    return std::make_shared<BuiltInMiddleware::Authentication>(token, require_user_id);
}

std::shared_ptr<BuiltInMiddleware::PermissionChecker> MiddlewareFactory::create_permission_checker(
        const std::unordered_map<std::string, uint64_t>& permissions) {
    return std::make_shared<BuiltInMiddleware::PermissionChecker>(permissions);
}

std::shared_ptr<BuiltInMiddleware::Transformer> MiddlewareFactory::create_transformer(
        const std::unordered_map<std::string, std::function<nlohmann::json(nlohmann::json)>>& transformers) {
    return std::make_shared<BuiltInMiddleware::Transformer>(transformers);
}

std::shared_ptr<BuiltInMiddleware::Filter> MiddlewareFactory::create_filter(
        const std::vector<EventFilter>& filters,
        const std::string& mode) {
    return std::make_shared<BuiltInMiddleware::Filter>(filters, mode);
}

std::shared_ptr<BuiltInMiddleware::Cache> MiddlewareFactory::create_cache(
        size_t max_size,
        std::chrono::milliseconds ttl) {
    return std::make_shared<BuiltInMiddleware::Cache>(max_size, ttl);
}

std::shared_ptr<BuiltInMiddleware::Metrics> MiddlewareFactory::create_metrics() {
    return std::make_shared<BuiltInMiddleware::Metrics>();
}

std::shared_ptr<BuiltInMiddleware::Debugger> MiddlewareFactory::create_debugger(
        const std::vector<std::string>& events,
        bool log_all,
        bool include_stack) {
    return std::make_shared<BuiltInMiddleware::Debugger>(events, log_all, include_stack);
}

} // namespace discord
=== END FILE ===

=== FILE: src/components/component_json.cpp ===
#include "../include/discord/components/component_json.h"
#include "../include/discord/components/component_base.h"
#include "../include/discord/components/button.h"
#include "../include/discord/components/select_menu.h"
#include "../include/discord/components/text_input.h"
#include "../include/discord/components/action_row.h"
#include "../include/discord/components/section.h"
#include "../include/discord/components/container.h"
#include "../include/discord/components/content_display.h"
#include "../include/discord/utils/types.h"
#include <stdexcept>
#include <fstream>
#include <algorithm>

namespace discord::components {

    nlohmann::json ComponentJson::serialize_component(const IComponent& component) {
        return component.to_json();
    }

    nlohmann::json ComponentJson::serialize_components(const std::vector<std::shared_ptr<IComponent>>& components) {
        nlohmann::json json = nlohmann::json::array();
        for (const auto& component : components) {
            if (component) {
                json.push_back(component->to_json());
            }
        }
        return json;
    }

    std::unique_ptr<IComponent> ComponentJson::deserialize_component(const nlohmann::json& json) {
        if (!json.contains("type")) {
            throw std::invalid_argument("JSON missing required 'type' field");
        }

        ComponentType type = static_cast<ComponentType>(json["type"].get<int>());
        
        switch (type) {
            case ComponentType::BUTTON:
                return deserialize_button(json);
            case ComponentType::STRING_SELECT:
                return deserialize_string_select(json);
            case ComponentType::USER_SELECT:
                return deserialize_user_select(json);
            case ComponentType::ROLE_SELECT:
                return deserialize_role_select(json);
            case ComponentType::CHANNEL_SELECT:
                return deserialize_channel_select(json);
            case ComponentType::MENTIONABLE_SELECT:
                return deserialize_mentionable_select(json);
            case ComponentType::TEXT_INPUT:
                return deserialize_text_input(json);
            case ComponentType::ACTION_ROW:
                return deserialize_action_row(json);
            case ComponentType::SECTION:
                return deserialize_section(json);
            case ComponentType::CONTAINER:
                return deserialize_container(json);
            case ComponentType::TEXT_DISPLAY:
                return deserialize_text_display(json);
            case ComponentType::THUMBNAIL:
                return deserialize_thumbnail(json);
            case ComponentType::MEDIA_GALLERY:
                return deserialize_media_gallery(json);
            case ComponentType::FILE:
                return deserialize_file(json);
            case ComponentType::SEPARATOR:
                return deserialize_separator(json);
            case ComponentType::LABEL:
                return deserialize_label(json);
            default:
                throw std::invalid_argument("Unknown component type: " + std::to_string(static_cast<int>(type)));
        }
    }

    std::vector<std::shared_ptr<IComponent>> ComponentJson::deserialize_components(const nlohmann::json& json_array) {
        if (!json_array.is_array()) {
            throw std::invalid_argument("JSON must be an array for component deserialization");
        }

        std::vector<std::shared_ptr<IComponent>> components;
        components.reserve(json_array.size());
        
        for (const auto& component_json : json_array) {
            components.push_back(deserialize_component(component_json));
        }
        
        return components;
    }

    ComponentType ComponentJson::detect_component_type(const nlohmann::json& json) {
        if (!json.contains("type")) {
            return ComponentType::UNKNOWN;
        }
        
        try {
            return static_cast<ComponentType>(json["type"].get<int>());
        } catch (...) {
            return ComponentType::UNKNOWN;
        }
    }

    bool ComponentJson::is_valid_component_json(const nlohmann::json& json) {
        if (!json.contains("type")) {
            return false;
        }

        ComponentType type = detect_component_type(json);
        return type != ComponentType::UNKNOWN;
    }

    ValidationResult ComponentJson::validate_component_json(const nlohmann::json& json) {
        ValidationResult result;
        
        try {
            auto component = deserialize_component(json);
            if (component) {
                return component->validate();
            }
            result.valid = false;
            result.errors.push_back("Failed to deserialize component");
        } catch (const std::exception& e) {
            result.valid = false;
            result.errors.push_back(e.what());
        }
        
        return result;
    }

    std::string ComponentJson::get_serialization_error(const nlohmann::json& json) {
        // TODO: Implement detailed error reporting
        (void)json; // Suppress unused parameter warning
        return "Component serialization error";
    }

    std::string ComponentJson::get_deserialization_error(const nlohmann::json& json) {
        // TODO: Implement detailed error reporting
        (void)json; // Suppress unused parameter warning
        return "Component deserialization error";
    }

    std::string ComponentJson::to_pretty_string(const IComponent& component) {
        return component.to_json().dump(2);
    }

    std::string ComponentJson::to_pretty_string(const std::vector<std::shared_ptr<IComponent>>& components) {
        return serialize_components(components).dump(2);
    }

    std::string ComponentJson::to_pretty_string(const nlohmann::json& json) {
        return json.dump(2);
    }

    bool ComponentJson::save_component_to_file(const IComponent& component, const std::string& filepath) {
        try {
            std::ofstream file(filepath);
            if (!file.is_open()) {
                return false;
            }
            
            file << component.to_json().dump(2);
            return file.good();
        } catch (...) {
            return false;
        }
    }

    bool ComponentJson::save_components_to_file(const std::vector<std::shared_ptr<IComponent>>& components, const std::string& filepath) {
        try {
            std::ofstream file(filepath);
            if (!file.is_open()) {
                return false;
            }
            
            file << serialize_components(components).dump(2);
            return file.good();
        } catch (...) {
            return false;
        }
    }

    std::unique_ptr<IComponent> ComponentJson::load_component_from_file(const std::string& filepath) {
        try {
            std::ifstream file(filepath);
            if (!file.is_open()) {
                return nullptr;
            }
            
            nlohmann::json json;
            file >> json;
            return deserialize_component(json);
        } catch (...) {
            return nullptr;
        }
    }

    std::vector<std::shared_ptr<IComponent>> ComponentJson::load_components_from_file(const std::string& filepath) {
        try {
            std::ifstream file(filepath);
            if (!file.is_open()) {
                return {};
            }
            
            nlohmann::json json;
            file >> json;
            return deserialize_components(json);
        } catch (...) {
            return {};
        }
    }

    // Component-specific deserializers
    std::unique_ptr<Button> ComponentJson::deserialize_button(const nlohmann::json& json) {
        // TODO: Implement button deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<StringSelect> ComponentJson::deserialize_string_select(const nlohmann::json& json) {
        // TODO: Implement string select deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<UserSelect> ComponentJson::deserialize_user_select(const nlohmann::json& json) {
        // TODO: Implement user select deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<RoleSelect> ComponentJson::deserialize_role_select(const nlohmann::json& json) {
        // TODO: Implement role select deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<ChannelSelect> ComponentJson::deserialize_channel_select(const nlohmann::json& json) {
        // TODO: Implement channel select deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<MentionableSelect> ComponentJson::deserialize_mentionable_select(const nlohmann::json& json) {
        // TODO: Implement mentionable select deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<TextInput> ComponentJson::deserialize_text_input(const nlohmann::json& json) {
        // TODO: Implement text input deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<ActionRow> ComponentJson::deserialize_action_row(const nlohmann::json& json) {
        // TODO: Implement action row deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<Section> ComponentJson::deserialize_section(const nlohmann::json& json) {
        // TODO: Implement section deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<Container> ComponentJson::deserialize_container(const nlohmann::json& json) {
        // TODO: Implement container deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<TextDisplay> ComponentJson::deserialize_text_display(const nlohmann::json& json) {
        // TODO: Implement text display deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<Thumbnail> ComponentJson::deserialize_thumbnail(const nlohmann::json& json) {
        // TODO: Implement thumbnail deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<MediaGallery> ComponentJson::deserialize_media_gallery(const nlohmann::json& json) {
        // TODO: Implement media gallery deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<File> ComponentJson::deserialize_file(const nlohmann::json& json) {
        // TODO: Implement file deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<Separator> ComponentJson::deserialize_separator(const nlohmann::json& json) {
        // TODO: Implement separator deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

    std::unique_ptr<Label> ComponentJson::deserialize_label(const nlohmann::json& json) {
        // TODO: Implement label deserialization
        (void)json; // Suppress unused parameter warning
        return nullptr;
    }

} // namespace discord::components
=== END FILE ===

=== FILE: src/components/component_builder.cpp ===
#include "../include/discord/components/component_builder.h"
#include "../include/discord/components/component_base.h"
#include "../include/discord/components/button.h"
#include "../include/discord/components/select_menu.h"
#include "../include/discord/components/text_input.h"
#include "../include/discord/components/action_row.h"
#include "../include/discord/components/section.h"
#include "../include/discord/components/container.h"
#include "../include/discord/components/content_display.h"
#include "../include/discord/utils/types.h"
#include <stdexcept>
#include <algorithm>

namespace discord::components {

    ComponentBuilder::ComponentBuilder() : current_component_(nullptr) {}

    ComponentBuilder::~ComponentBuilder() = default;

    // Button builders
    ComponentBuilder& ComponentBuilder::button(const std::string& label,
                                             const std::string& custom_id,
                                             const std::string& style,
                                             const std::optional<std::string>& emoji,
                                             bool disabled) {
        auto button = std::make_shared<Button>(label, style, custom_id, emoji, disabled);
        add_component(button);
        return *this;
    }

    ComponentBuilder& ComponentBuilder::primary_button(const std::string& label,
                                                const std::string& custom_id,
                                                const std::optional<std::string>& emoji,
                                                bool disabled) {
        return button(label, "primary", custom_id, emoji, disabled);
    }

    ComponentBuilder& ComponentBuilder::secondary_button(const std::string& label,
                                                   const std::string& custom_id,
                                                   const std::optional<std::string>& emoji,
                                                   bool disabled) {
        return button(label, "secondary", custom_id, emoji, disabled);
    }

    ComponentBuilder& ComponentBuilder::success_button(const std::string& label,
                                                const std::string& custom_id,
                                                const std::optional<std::string>& emoji,
                                                bool disabled) {
        return button(label, "success", custom_id, emoji, disabled);
    }

    ComponentBuilder& ComponentBuilder::danger_button(const std::string& label,
                                               const std::string& custom_id,
                                               const std::optional<std::string>& emoji,
                                               bool disabled) {
        return button(label, "danger", custom_id, emoji, disabled);
    }

    ComponentBuilder& ComponentBuilder::link_button(const std::string& label,
                                          const std::string& url,
                                          const std::optional<std::string>& emoji,
                                          bool disabled) {
        return button(label, url, emoji, disabled);
    }

    ComponentBuilder& ComponentBuilder::premium_button(const std::string& label,
                                                const std::string& sku_id,
                                                const std::optional<std::string>& emoji,
                                                bool disabled) {
        return button(label, "premium", sku_id, emoji, disabled);
    }

    ComponentBuilder& ComponentBuilder::button_emoji(const std::string& emoji) {
        if (current_component_ && current_component_->get_type() == ComponentType::BUTTON) {
            auto button = std::static_pointer_cast<Button>(current_component_);
            if (button) {
                button->set_emoji(emoji);
            }
        }
        return *this;
    }

    // Select menu builders
    ComponentBuilder& ComponentBuilder::string_select(const std::string& custom_id,
                                                   const std::vector<SelectOption>& options,
                                                   const std::string& placeholder,
                                                   int min_values,
                                                   int max_values,
                                                   bool disabled) {
        auto select = std::make_shared<StringSelect>(custom_id, options, placeholder, min_values, max_values, disabled);
        add_component(select);
        return *this;
    }

    ComponentBuilder& ComponentBuilder::user_select(const std::string& custom_id,
                                                const std::string& placeholder,
                                                int min_values,
                                                int max_values,
                                                bool disabled) {
        auto select = std::make_shared<UserSelect>(custom_id, placeholder, min_values, max_values, disabled);
        add_component(select);
        return *this;
    }

    ComponentBuilder& ComponentBuilder::role_select(const std::string& custom_id,
                                                const std::string& placeholder,
                                                int min_values,
                                                int max_values,
                                                bool disabled) {
        auto select = std::make_shared<RoleSelect>(custom_id, placeholder, min_values, max_values, disabled);
        add_component(select);
        return *this;
    }

    ComponentBuilder& ComponentBuilder::channel_select(const std::string& custom_id,
                                                   const std::vector<std::string>& channel_types,
                                                   const std::string& placeholder,
                                                   int min_values,
                                                   int max_values,
                                                   bool disabled) {
        auto select = std::make_shared<ChannelSelect>(custom_id, channel_types, placeholder, min_values, max_values, disabled);
        add_component(select);
        return *this;
    }

    ComponentBuilder& ComponentBuilder::mentionable_select(const std::string& custom_id,
                                                        const std::string& placeholder,
                                                        int min_values,
                                                        int max_values,
                                                        bool disabled) {
        auto select = std::make_shared<MentionableSelect>(custom_id, placeholder, min_values, max_values, disabled);
        add_component(select);
        return *this;
    }

    ComponentBuilder& ComponentBuilder::select_placeholder(const std::string& placeholder) {
        if (current_component_ && current_component_->get_type() == ComponentType::STRING_SELECT) {
            auto select = std::static_pointer_cast<StringSelect>(current_component_);
            if (select) {
                select->set_placeholder(placeholder);
            }
        }
        return *this;
    }

    ComponentBuilder& ComponentBuilder::select_min_values(int min_values) {
        if (current_component_ && current_component_->get_type() == ComponentType::STRING_SELECT) {
            auto select = std::static_pointer_cast<StringSelect>(current_component_);
            if (select) {
                select->set_min_values(min_values);
            }
        }
        return *this;
    }

    ComponentBuilder& ComponentBuilder::select_max_values(int max_values) {
        if (current_component_ && current_component_->get_type() == ComponentType::STRING_SELECT) {
            auto select = std::static_pointer_cast<StringSelect>(current_component_);
            if (select) {
                select->set_max_values(max_values);
            }
        }
        return *this;
    }

    ComponentBuilder& ComponentBuilder::select_option(const std::string& label,
                                             const std::string& value,
                                             const std::optional<std::string>& description,
                                             const std::optional<std::string>& emoji,
                                             bool default_) {
        if (current_component_ && current_component_->get_type() == ComponentType::STRING_SELECT) {
            auto select = std::static_pointer_cast<StringSelect>(current_component_);
            if (select) {
                select->add_option(SelectOption(label, value, description, emoji, default_));
            }
        }
        return *this;
    }

    // Text input builders
    ComponentBuilder& ComponentBuilder::short_text(const std::string& custom_id,
                                                const std::string& label,
                                                const std::optional<std::string>& value,
                                                const std::optional<std::string>& placeholder,
                                                bool required,
                                                int min_length,
                                                int max_length) {
        auto text_input = std::make_shared<TextInput>(custom_id, label, TextInputStyle::SHORT, value, placeholder, required, min_length, max_length);
        add_component(text_input);
        return *this;
    }

    ComponentBuilder& ComponentBuilder::paragraph(const std::string& custom_id,
                                                 const std::string& label,
                                                 const std::optional<std::string>& value,
                                                 const std::optional<std::string>& placeholder,
                                                 bool required,
                                                 int min_length,
                                                 int max_length) {
        auto text_input = std::make_shared<TextInput>(custom_id, label, TextInputStyle::PARAGRAPH, value, placeholder, required, min_length, max_length);
        add_component(text_input);
        return *this;
    }

    ComponentBuilder& ComponentBuilder::text_input_style(TextInputStyle style) {
        if (current_component_ && current_component_->get_type() == ComponentType::TEXT_INPUT) {
            auto text_input = std::static_pointer_cast<TextInput>(current_component_);
            if (text_input) {
                text_input->set_style(style);
            }
        }
        return *this;
    }

    ComponentBuilder& ComponentBuilder::text_input_value(const std::string& value) {
        if (current_component_ && current_component_->get_type() == ComponentType::TEXT_INPUT) {
            auto text_input = std::static_pointer_cast<TextInput>(current_component_);
            if (text_input) {
                text_input->set_value(value);
            }
        }
        return *this;
    }

    ComponentBuilder& ComponentBuilder::text_input_placeholder(const std::string& placeholder) {
        if (current_component_ && current_component_->get_type() == ComponentType::TEXT_INPUT) {
            auto text_input = std::static_pointer_cast<TextInput>(current_component_);
            if (text_input) {
                text_input->set_placeholder(placeholder);
            }
        }
        return *this;
    }

    ComponentBuilder& ComponentBuilder::text_input_required(bool required) {
        if (current_component_ && current_component_->get_type() == ComponentType::TEXT_INPUT) {
            auto text_input = std::static_pointer_cast<TextInput>(current_component_);
            if (text_input) {
                text_input->set_required(required);
            }
        }
        return *this;
    }

    ComponentBuilder& ComponentBuilder::text_input_min_length(int min_length) {
        if (current_component_ && current_component_->get_type() == ComponentType::TEXT_INPUT) {
            auto text_input = std::static_pointer_cast<TextInput>(current_component_);
            if (text_input) {
                text_input->set_min_length(min_length);
            }
        }
        return *this;
    }

    ComponentBuilder& ComponentBuilder::text_input_max_length(int max_length) {
        if (current_component_ && current_component_->get_type() == ComponentType::TEXT_INPUT) {
            auto text_input = std::static_pointer_cast<TextInput>(current_component_);
            if (text_input) {
                text_input->set_max_length(max_length);
            }
        }
        return *this;
    }

    // Layout builders
    ComponentBuilder& ComponentBuilder::new_row() {
        current_component_ = std::make_unique<ActionRow>();
        return *this;
    }

    ComponentBuilder& ComponentBuilder::new_section(const std::string& text) {
        current_component_ = std::make_unique<Section>(text);
        return *this;
    }

    ComponentBuilder& ComponentBuilder::new_container() {
        current_component_ = std::make_unique<Container>();
        return *this;
    }

    ComponentBuilder& ComponentBuilder::finish_current() {
        if (current_component_) {
            components_.push_back(current_component_);
            current_component_ = nullptr;
        }
        return *this;
    }

    ComponentBuilder& ComponentBuilder::finish_current() {
        return finish_current();
    }

    ComponentBuilder& ComponentBuilder::build() {
        if (!current_component_) {
            throw std::runtime_error("No component to build");
        }
        
        auto result = current_component_;
        current_component_ = nullptr;
        return result;
    }

    ComponentBuilder& ComponentBuilder::build_all() {
        if (components_.empty()) {
            throw std::runtime_error("No components to build");
        }
        
        auto result = components_;
        components_.clear();
        return result;
    }

    // Convenience methods
    ComponentBuilder& ComponentBuilder::with_button(const std::function<ComponentBuilder&>& builder) {
        return builder.button("", "", "", "", "", "", "");
    }

    ComponentBuilder& ComponentBuilder::with_select(const std::function<ComponentBuilder&>& builder) {
        return builder.string_select("", {}, {}, "", 1, 25);
    }

    ComponentBuilder& ComponentBuilder::with_text_input(const std::function<ComponentBuilder&>& builder) {
        return builder.short_text("", "", "", "", false, false, 0, 4000);
    }

    ComponentBuilder& ComponentBuilder::with_row(const std::function<ComponentBuilder&>& builder) {
        return builder.new_row()
            .primary_button("", "")
            .secondary_button("", "")
            .finish_current();
    }

    ComponentBuilder& ComponentBuilder::with_section(const std::function<ComponentBuilder&>& builder) {
        return builder.new_section("Text content")
            .with_button("", "Click me", "click_me")
            .finish_current();
    }

    ComponentBuilder& ComponentBuilder::with_container(const std::function<ComponentBuilder&>& builder) {
        return builder.new_container();
    }

} // namespace discord::components
=== END FILE ===

=== FILE: src/components/content_display.cpp ===
#include "../include/discord/components/content_display.h"
#include "../include/discord/utils/types.h"
#include <stdexcept>

namespace discord::components {

    TextDisplay::TextDisplay(const std::string& content)
        : content_(content) {
        if (content_.length() > 2000) {
            throw std::invalid_argument("TextDisplay content cannot exceed 2000 characters");
        }
    }

    nlohmann::json TextDisplay::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::TEXT_DISPLAY);
        json["text"] = content_;
        return json;
    }

    bool TextDisplay::validate() const {
        return !content_.empty() && content_.length() <= 2000;
    }

    std::unique_ptr<IComponent> TextDisplay::clone() const {
        return std::make_unique<TextDisplay>(content_);
    }

    std::unique_ptr<TextDisplay> TextDisplay::create(const std::string& content) {
        return std::make_unique<TextDisplay>(content);
    }

    Thumbnail::Thumbnail(const std::string& url,
                   const std::optional<std::string>& alt_text,
                   const std::optional<int>& width,
                   const std::optional<int>& height)
        : url_(url),
          alt_text_(alt_text),
          width_(width),
          height_(height) {
        
        if (url_.empty()) {
            throw std::invalid_argument("Thumbnail URL cannot be empty");
        }
        
        if (width_.has_value() && width_.value() < 16) {
            throw std::invalid_argument("Thumbnail width must be at least 16 pixels");
        }
        
        if (height_.has_value() && height_.value() < 16) {
            throw std::invalid_argument("Thumbnail height must be at least 16 pixels");
        }
    }

    nlohmann::json Thumbnail::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::THUMBNAIL);
        json["url"] = url_;
        
        if (alt_text_.has_value()) {
            json["alt_text"] = alt_text_.value();
        }
        
        if (width_.has_value()) {
            json["width"] = width_.value();
        }
        
        if (height_.has_value()) {
            json["height"] = height_.value();
        }
        
        return json;
    }

    bool Thumbnail::validate() const {
        if (url_.empty()) {
            return false;
        }
        
        if (width_.has_value() && width_.value() < 16) {
            return false;
        }
        
        if (height_.has_value() && height_.value() < 16) {
            return false;
        }
        
        return true;
    }

    std::unique_ptr<Thumbnail> Thumbnail::create(const std::string& url,
                                            const std::optional<std::string>& alt_text,
                                            const std::optional<int>& width,
                                            const std::optional<int>& height) {
        return std::make_unique<Thumbnail>(url, alt_text, width, height);
    }

    MediaGallery::MediaGallery(const std::vector<std::string>& items,
                           const std::optional<std::string>& alt_text)
        : items_(items),
          alt_text_(alt_text) {
        
        if (items_.size() > 10) {
            throw std::invalid_argument("MediaGallery cannot contain more than 10 items");
        }
        
        for (const auto& item : items_) {
            if (item.empty()) {
                throw std::invalid_argument("MediaGallery items cannot be empty");
            }
        }
    }

    nlohmann::json MediaGallery::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::MEDIA_GALLERY);
        json["items"] = items_;
        
        if (alt_text_.has_value()) {
            json["alt_text"] = alt_text_.value();
        }
        
        return json;
    }

    bool MediaGallery::validate() const {
        if (items_.empty() || items_.size() > 10) {
            return false;
        }
        
        for (const auto& item : items_) {
            if (item.empty()) {
                return false;
            }
        }
        
        return true;
    }

    void MediaGallery::add_item(const std::string& item) {
        if (items_.size() >= 10) {
            throw std::invalid_argument("MediaGallery cannot contain more than 10 items");
        }
        
        if (item.empty()) {
            throw std::invalid_argument("MediaGallery items cannot be empty");
        }
        
        items_.push_back(item);
    }

    void MediaGallery::remove_item(size_t index) {
        if (index < items_.size()) {
            items_.erase(items_.begin() + index);
        }
    }

    void MediaGallery::clear_items() {
        items_.clear();
    }

    std::unique_ptr<MediaGallery> MediaGallery::create(const std::vector<std::string>& items,
                                                const std::optional<std::string>& alt_text) {
        return std::make_unique<MediaGallery>(items, alt_text);
    }

    File::File(const std::string& url,
               const std::string& filename,
               const std::optional<int>& size_bytes)
        : url_(url),
          filename_(filename),
          size_bytes_(size_bytes) {
        
        if (url_.empty()) {
            throw std::invalid_argument("File URL cannot be empty");
        }
        
        if (filename_.empty()) {
            throw std::invalid_argument("File filename cannot be empty");
        }
        
        if (size_bytes_.has_value() && size_bytes_.value() < 0) {
            throw std::invalid_argument("File size_bytes must be non-negative");
        }
    }

    nlohmann::json File::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::FILE);
        json["url"] = url_;
        json["filename"] = filename_;
        
        if (size_bytes_.has_value()) {
            json["size_bytes"] = size_bytes_.value();
        }
        
        return json;
    }

    bool File::validate() const {
        if (url_.empty() || filename_.empty()) {
            return false;
        }
        
        if (size_bytes_.has_value() && size_bytes_.value() < 0) {
            return false;
        }
        
        return true;
    }

    std::unique_ptr<File> File::create(const std::string& url,
                                       const std::string& filename,
                                       const std::optional<int>& size_bytes) {
        return std::make_unique<File>(url, filename, size_bytes);
    }

    Separator::Separator(bool decorative, const std::optional<int>& spacing)
        : decorative_(decorative),
          spacing_(spacing) {
        
        if (spacing_.has_value() && spacing_.value() < 0) {
            throw std::invalid_argument("Separator spacing must be non-negative");
        }
    }

    nlohmann::json Separator::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::SEPARATOR);
        
        if (decorative_) {
            json["decorative"] = true;
        }
        
        if (spacing_.has_value()) {
            json["spacing"] = spacing_.value();
        }
        
        return json;
    }

    bool Separator::validate() const {
        if (spacing_.has_value() && spacing_.value() < 0) {
            return false;
        }
        
        return true;
    }

    std::unique_ptr<Separator> Separator::create(bool decorative, const std::optional<int>& spacing) {
        return std::make_unique<Separator>(decorative, spacing);
    }

    Label::Label(const std::string& text,
                 const std::optional<std::string>& for_component)
        : text_(text),
          for_component_(for_component) {
        
        if (text_.length() > 80) {
            throw std::invalid_argument("Label text cannot exceed 80 characters");
        }
    }

    nlohmann::json Label::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::LABEL);
        json["text"] = text_;
        
        if (for_component_.has_value()) {
            json["for_component"] = for_component_.value();
        }
        
        return json;
    }

    bool Label::validate() const {
        if (text_.empty() || text_.length() > 80) {
            return false;
        }
        
        return true;
    }

    std::unique_ptr<Label> Label::create(const std::string& text,
                                       const std::optional<std::string>& for_component) {
        return std::make_unique<Label>(text, for_component);
    }

} // namespace discord::components
=== END FILE ===

=== FILE: src/components/container.cpp ===
#include "../include/discord/components/container.h"
#include "../include/discord/components/section.h"
#include "../include/discord/components/content_display.h"
#include "../include/discord/utils/types.h"
#include <stdexcept>

namespace discord::components {

    Container::Container(const std::vector<std::shared_ptr<IComponent>>& components)
        : ContainerComponent(components) {
        if (components_.size() > 10) {
            throw std::invalid_argument("Container cannot contain more than 10 components");
        }
    }

    nlohmann::json Container::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::CONTAINER);
        
        nlohmann::json components_array = nlohmann::json::array();
        for (const auto& component : components_) {
            if (component) {
                components_array.push_back(component->to_json());
            }
        }
        json["components"] = components_array;
        
        return json;
    }

    bool Container::validate() const {
        if (components_.size() > 10) {
            return false;
        }

        // Validate each component
        for (const auto& component : components_) {
            if (!component || !component->validate()) {
                return false;
            }
        }

        return true;
    }

    std::unique_ptr<IComponent> Container::clone() const {
        std::vector<std::shared_ptr<IComponent>> cloned_components;
        cloned_components.reserve(components_.size());
        
        for (const auto& component : components_) {
            if (component) {
                cloned_components.push_back(std::shared_ptr<IComponent>(component->clone().release()));
            }
        }
        
        return std::make_unique<Container>(cloned_components);
    }

    bool Container::can_add_component(std::shared_ptr<IComponent> component) const {
        if (!component || components_.size() >= 10) {
            return false;
        }
        return true;
    }

    std::unique_ptr<Container> Container::create(const std::vector<std::shared_ptr<IComponent>>& components) {
        return std::make_unique<Container>(components);
    }

    std::unique_ptr<Container> Container::with_sections(const std::vector<std::shared_ptr<Section>>& sections) {
        std::vector<std::shared_ptr<IComponent>> components;
        components.reserve(sections.size());
        
        for (const auto& section : sections) {
            if (section) {
                components.push_back(std::static_pointer_cast<IComponent>(section));
            }
        }
        
        return std::make_unique<Container>(components);
    }

    std::unique_ptr<Container> Container::with_action_rows(const std::vector<std::shared_ptr<ActionRow>>& action_rows) {
        std::vector<std::shared_ptr<IComponent>> components;
        components.reserve(action_rows.size());
        
        for (const auto& action_row : action_rows) {
            if (action_row) {
                components.push_back(std::static_pointer_cast<IComponent>(action_row));
            }
        }
        
        return std::make_unique<Container>(components);
    }

    std::unique_ptr<Container> Container::mixed(const std::vector<std::shared_ptr<IComponent>>& components) {
        return std::make_unique<Container>(components);
    }

} // namespace discord::components
=== END FILE ===

=== FILE: src/components/section.cpp ===
#include "../include/discord/components/section.h"
#include "../include/discord/components/button.h"
#include "../include/discord/components/select_menu.h"
#include "../include/discord/components/text_input.h"
#include "../include/discord/utils/types.h"

namespace discord::components {

    Section::Section(const std::string& text,
                         const std::optional<std::shared_ptr<IComponent>>& accessory)
        : ContainerComponent(),
          text_(text),
          accessory_(accessory) {
        
        if (text_.length() > 2000) {
            throw std::invalid_argument("Section text cannot exceed 2000 characters");
        }
        
        if (accessory_.has_value()) {
            add_component(accessory_.value());
        }
    }

    void Section::set_text(const std::string& text) {
        if (text.length() > 2000) {
            throw std::invalid_argument("Section text cannot exceed 2000 characters");
        }
        text_ = text;
    }

    void Section::set_accessory(const std::optional<std::shared_ptr<IComponent>>& accessory) {
        accessory_ = accessory;
        
        // Update components list
        components_.clear();
        if (accessory_.has_value()) {
            components_.push_back(accessory_.value());
        }
    }

    nlohmann::json Section::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::SECTION);
        json["text"] = text_;
        
        if (accessory_.has_value() && accessory_.value()) {
            json["accessory"] = accessory_.value()->to_json();
        }
        
        return json;
    }

    bool Section::validate() const {
        if (text_.empty() || text_.length() > 2000) {
            return false;
        }
        
        if (accessory_.has_value()) {
            if (!accessory_.value()) {
                return false;
            }
            
            // Validate that accessory is a valid component type for sections
            ComponentType accessory_type = accessory_.value()->get_type();
            if (accessory_type != ComponentType::BUTTON && 
                accessory_type != ComponentType::STRING_SELECT &&
                accessory_type != ComponentType::USER_SELECT &&
                accessory_type != ComponentType::ROLE_SELECT &&
                accessory_type != ComponentType::CHANNEL_SELECT &&
                accessory_type != ComponentType::MENTIONABLE_SELECT &&
                accessory_type != ComponentType::TEXT_INPUT) {
                return false;
            }
            
            return accessory_.value()->validate();
        }
        
        return true;
    }

    std::unique_ptr<IComponent> Section::clone() const {
        std::optional<std::shared_ptr<IComponent>> cloned_accessory;
        if (accessory_.has_value() && accessory_.value()) {
            cloned_accessory = std::shared_ptr<IComponent>(accessory_.value()->clone().release());
        }
        
        return std::make_unique<Section>(text_, cloned_accessory);
    }

    std::unique_ptr<Section> Section::create(const std::string& text,
                                               const std::optional<std::shared_ptr<IComponent>>& accessory) {
        return std::make_unique<Section>(text, accessory);
    }

    std::unique_ptr<Section> Section::with_button(const std::string& text,
                                                   std::shared_ptr<Button> button) {
        std::optional<std::shared_ptr<IComponent>> accessory;
        if (button) {
            accessory = std::static_pointer_cast<IComponent>(button);
        }
        return std::make_unique<Section>(text, accessory);
    }

    std::unique_ptr<Section> Section::with_select(const std::string& text,
                                                  std::shared_ptr<SelectMenu> select) {
        std::optional<std::shared_ptr<IComponent>> accessory;
        if (select) {
            accessory = std::static_pointer_cast<IComponent>(select);
        }
        return std::make_unique<Section>(text, accessory);
    }

    std::unique_ptr<Section> Section::with_text_input(const std::string& text,
                                                       std::shared_ptr<TextInput> text_input) {
        std::optional<std::shared_ptr<IComponent>> accessory;
        if (text_input) {
            accessory = std::static_pointer_cast<IComponent>(text_input);
        }
        return std::make_unique<Section>(text, accessory);
    }

} // namespace discord::components
=== END FILE ===

=== FILE: src/components/text_input.cpp ===
#include "../include/discord/components/text_input.h"
#include "../include/discord/utils/types.h"
#include <stdexcept>

namespace discord::components {

    TextInput::TextInput(const std::string& custom_id,
                             const std::string& label,
                             TextInputStyle style,
                             const std::optional<std::string>& value,
                             const std::optional<std::string>& placeholder,
                             bool required,
                             int min_length,
                             int max_length)
        : InteractiveComponent(custom_id, false),
          style_(style),
          label_(label),
          value_(value),
          placeholder_(placeholder),
          required_(required),
          min_length_(min_length),
          max_length_(max_length) {
        
        if (custom_id_.empty() || custom_id_.length() > 100) {
            throw std::invalid_argument("TextInput custom_id must be 1-100 characters");
        }
        
        if (label_.empty() || label_.length() > 45) {
            throw std::invalid_argument("TextInput label must be 1-45 characters");
        }
        
        if (min_length_ < 0 || min_length_ > 4000) {
            throw std::invalid_argument("TextInput min_length must be 0-4000");
        }
        
        if (max_length_ < 1 || max_length_ > 4000) {
            throw std::invalid_argument("TextInput max_length must be 1-4000");
        }
        
        if (min_length_ > max_length_) {
            throw std::invalid_argument("TextInput min_length cannot be greater than max_length");
        }
        
        if (value_.has_value() && value_->length() > static_cast<size_t>(max_length_)) {
            throw std::invalid_argument("TextInput value length cannot exceed max_length");
        }
    }

    nlohmann::json TextInput::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::TEXT_INPUT);
        json["custom_id"] = custom_id_;
        json["style"] = static_cast<int>(style_);
        json["label"] = label_;
        
        if (value_.has_value()) {
            json["value"] = value_.value();
        }
        
        if (placeholder_.has_value()) {
            json["placeholder"] = placeholder_.value();
        }
        
        if (required_) {
            json["required"] = true;
        }
        
        json["min_length"] = min_length_;
        json["max_length"] = max_length_;
        
        return json;
    }

    bool TextInput::validate() const {
        if (custom_id_.empty() || custom_id_.length() > 100) {
            return false;
        }
        
        if (label_.empty() || label_.length() > 45) {
            return false;
        }
        
        if (min_length_ < 0 || min_length_ > 4000) {
            return false;
        }
        
        if (max_length_ < 1 || max_length_ > 4000) {
            return false;
        }
        
        if (min_length_ > max_length_) {
            return false;
        }
        
        if (value_.has_value() && value_->length() > static_cast<size_t>(max_length_)) {
            return false;
        }
        
        return true;
    }

    std::unique_ptr<IComponent> TextInput::clone() const {
        return std::make_unique<TextInput>(custom_id_, label_, style_, value_, 
                                       placeholder_, required_, min_length_, max_length_);
    }

    std::unique_ptr<TextInput> TextInput::short_text(const std::string& custom_id,
                                                     const std::string& label,
                                                     const std::optional<std::string>& value,
                                                     const std::optional<std::string>& placeholder,
                                                     bool required,
                                                     int min_length,
                                                     int max_length) {
        return std::make_unique<TextInput>(custom_id, label, TextInputStyle::SHORT, 
                                       value, placeholder, required, min_length, max_length);
    }

    std::unique_ptr<TextInput> TextInput::paragraph(const std::string& custom_id,
                                                  const std::string& label,
                                                  const std::optional<std::string>& value,
                                                  const std::optional<std::string>& placeholder,
                                                  bool required,
                                                  int min_length,
                                                  int max_length) {
        return std::make_unique<TextInput>(custom_id, label, TextInputStyle::PARAGRAPH, 
                                       value, placeholder, required, min_length, max_length);
    }

    std::unique_ptr<TextInput> TextInput::create(const std::string& custom_id,
                                               const std::string& label,
                                               TextInputStyle style,
                                               const std::optional<std::string>& value,
                                               const std::optional<std::string>& placeholder,
                                               bool required,
                                               int min_length,
                                               int max_length) {
        return std::make_unique<TextInput>(custom_id, label, style, value, 
                                       placeholder, required, min_length, max_length);
    }

} // namespace discord::components
=== END FILE ===

=== FILE: src/components/select_menu.cpp ===
#include "../include/discord/components/select_menu.h"
#include "../include/discord/utils/types.h"
#include <stdexcept>
#include <algorithm>

namespace discord::components {

    nlohmann::json SelectOption::to_json() const {
        nlohmann::json json;
        json["label"] = label;
        json["value"] = value;
        
        if (description.has_value()) {
            json["description"] = description.value();
        }
        
        if (emoji.has_value()) {
            json["emoji"] = nlohmann::json{{"name", emoji.value()}};
        }
        
        if (default_) {
            json["default"] = true;
        }
        
        return json;
    }

    SelectMenu::SelectMenu(const std::string& custom_id,
                           const std::string& placeholder,
                           int min_values,
                           int max_values,
                           bool disabled)
        : InteractiveComponent(custom_id, disabled),
          placeholder_(placeholder),
          min_values_(min_values),
          max_values_(max_values) {
        
        if (custom_id_.length() > 100) {
            throw std::invalid_argument("Select menu custom_id cannot exceed 100 characters");
        }
        
        if (min_values_ < 0 || min_values_ > 25) {
            throw std::invalid_argument("min_values must be between 0 and 25");
        }
        
        if (max_values_ < 1 || max_values_ > 25) {
            throw std::invalid_argument("max_values must be between 1 and 25");
        }
        
        if (min_values_ > max_values_) {
            throw std::invalid_argument("min_values cannot be greater than max_values");
        }
    }

    void SelectMenu::set_default_values(const std::vector<std::string>& values) {
        if (values.size() > static_cast<size_t>(max_values_)) {
            throw std::invalid_argument("Default values count cannot exceed max_values");
        }
        default_values_ = values;
    }

    void SelectMenu::add_default_value(const std::string& value) {
        if (default_values_.size() >= static_cast<size_t>(max_values_)) {
            throw std::invalid_argument("Cannot add more default values than max_values allows");
        }
        default_values_.push_back(value);
    }

    StringSelect::StringSelect(const std::string& custom_id,
                             const std::vector<SelectOption>& options,
                             const std::string& placeholder,
                             int min_values,
                             int max_values,
                             bool disabled)
        : SelectMenu(custom_id, placeholder, min_values, max_values, disabled),
          options_(options) {
        
        if (options_.size() > 25) {
            throw std::invalid_argument("String select cannot have more than 25 options");
        }
        
        if (options_.empty()) {
            throw std::invalid_argument("String select must have at least one option");
        }
    }

    nlohmann::json StringSelect::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::STRING_SELECT);
        json["custom_id"] = custom_id_;
        
        if (!placeholder_.empty()) {
            json["placeholder"] = placeholder_;
        }
        
        json["min_values"] = min_values_;
        json["max_values"] = max_values_;
        
        nlohmann::json options_array = nlohmann::json::array();
        for (const auto& option : options_) {
            options_array.push_back(option.to_json());
        }
        json["options"] = options_array;
        
        if (!default_values_.empty()) {
            json["default_values"] = default_values_;
        }
        
        if (disabled_) {
            json["disabled"] = true;
        }
        
        return json;
    }

    bool StringSelect::validate() const {
        if (custom_id_.empty() || custom_id_.length() > 100) {
            return false;
        }
        
        if (options_.empty() || options_.size() > 25) {
            return false;
        }
        
        if (min_values_ < 0 || min_values_ > 25) {
            return false;
        }
        
        if (max_values_ < 1 || max_values_ > 25) {
            return false;
        }
        
        if (min_values_ > max_values_) {
            return false;
        }
        
        if (default_values_.size() > static_cast<size_t>(max_values_)) {
            return false;
        }
        
        // Validate each option
        for (const auto& option : options_) {
            if (option.label.empty() || option.label.length() > 100) {
                return false;
            }
            if (option.value.empty() || option.value.length() > 100) {
                return false;
            }
        }
        
        return true;
    }

    std::unique_ptr<IComponent> StringSelect::clone() const {
        return std::make_unique<StringSelect>(custom_id_, options_, placeholder_, 
                                          min_values_, max_values_, disabled_);
    }

    void StringSelect::add_option(const SelectOption& option) {
        if (options_.size() >= 25) {
            throw std::invalid_argument("String select cannot have more than 25 options");
        }
        options_.push_back(option);
    }

    void StringSelect::remove_option(size_t index) {
        if (index < options_.size()) {
            options_.erase(options_.begin() + index);
        }
    }

    void StringSelect::clear_options() {
        options_.clear();
    }

    std::unique_ptr<StringSelect> StringSelect::create(const std::string& custom_id,
                                                    const std::vector<SelectOption>& options,
                                                    const std::string& placeholder,
                                                    int min_values,
                                                    int max_values) {
        return std::make_unique<StringSelect>(custom_id, options, placeholder, min_values, max_values);
    }

    UserSelect::UserSelect(const std::string& custom_id,
                           const std::string& placeholder,
                           int min_values,
                           int max_values,
                           bool disabled)
        : SelectMenu(custom_id, placeholder, min_values, max_values, disabled) {}

    nlohmann::json UserSelect::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::USER_SELECT);
        json["custom_id"] = custom_id_;
        
        if (!placeholder_.empty()) {
            json["placeholder"] = placeholder_;
        }
        
        json["min_values"] = min_values_;
        json["max_values"] = max_values_;
        
        if (!default_values_.empty()) {
            json["default_values"] = default_values_;
        }
        
        if (disabled_) {
            json["disabled"] = true;
        }
        
        return json;
    }

    bool UserSelect::validate() const {
        if (custom_id_.empty() || custom_id_.length() > 100) {
            return false;
        }
        
        if (min_values_ < 0 || min_values_ > 25) {
            return false;
        }
        
        if (max_values_ < 1 || max_values_ > 25) {
            return false;
        }
        
        if (min_values_ > max_values_) {
            return false;
        }
        
        if (default_values_.size() > static_cast<size_t>(max_values_)) {
            return false;
        }
        
        return true;
    }

    std::unique_ptr<IComponent> UserSelect::clone() const {
        return std::make_unique<UserSelect>(custom_id_, placeholder_, 
                                         min_values_, max_values_, disabled_);
    }

    std::unique_ptr<UserSelect> UserSelect::create(const std::string& custom_id,
                                                  const std::string& placeholder,
                                                  int min_values,
                                                  int max_values) {
        return std::make_unique<UserSelect>(custom_id, placeholder, min_values, max_values);
    }

    RoleSelect::RoleSelect(const std::string& custom_id,
                           const std::string& placeholder,
                           int min_values,
                           int max_values,
                           bool disabled)
        : SelectMenu(custom_id, placeholder, min_values, max_values, disabled) {}

    nlohmann::json RoleSelect::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::ROLE_SELECT);
        json["custom_id"] = custom_id_;
        
        if (!placeholder_.empty()) {
            json["placeholder"] = placeholder_;
        }
        
        json["min_values"] = min_values_;
        json["max_values"] = max_values_;
        
        if (!default_values_.empty()) {
            json["default_values"] = default_values_;
        }
        
        if (disabled_) {
            json["disabled"] = true;
        }
        
        return json;
    }

    bool RoleSelect::validate() const {
        if (custom_id_.empty() || custom_id_.length() > 100) {
            return false;
        }
        
        if (min_values_ < 0 || min_values_ > 25) {
            return false;
        }
        
        if (max_values_ < 1 || max_values_ > 25) {
            return false;
        }
        
        if (min_values_ > max_values_) {
            return false;
        }
        
        if (default_values_.size() > static_cast<size_t>(max_values_)) {
            return false;
        }
        
        return true;
    }

    std::unique_ptr<IComponent> RoleSelect::clone() const {
        return std::make_unique<RoleSelect>(custom_id_, placeholder_, 
                                         min_values_, max_values_, disabled_);
    }

    std::unique_ptr<RoleSelect> RoleSelect::create(const std::string& custom_id,
                                                  const std::string& placeholder,
                                                  int min_values,
                                                  int max_values) {
        return std::make_unique<RoleSelect>(custom_id, placeholder, min_values, max_values);
    }

    ChannelSelect::ChannelSelect(const std::string& custom_id,
                               const std::vector<std::string>& channel_types,
                               const std::string& placeholder,
                               int min_values,
                               int max_values,
                               bool disabled)
        : SelectMenu(custom_id, placeholder, min_values, max_values, disabled),
          channel_types_(channel_types) {}

    nlohmann::json ChannelSelect::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::CHANNEL_SELECT);
        json["custom_id"] = custom_id_;
        
        if (!placeholder_.empty()) {
            json["placeholder"] = placeholder_;
        }
        
        json["min_values"] = min_values_;
        json["max_values"] = max_values_;
        
        if (!channel_types_.empty()) {
            json["channel_types"] = channel_types_;
        }
        
        if (!default_values_.empty()) {
            json["default_values"] = default_values_;
        }
        
        if (disabled_) {
            json["disabled"] = true;
        }
        
        return json;
    }

    bool ChannelSelect::validate() const {
        if (custom_id_.empty() || custom_id_.length() > 100) {
            return false;
        }
        
        if (min_values_ < 0 || min_values_ > 25) {
            return false;
        }
        
        if (max_values_ < 1 || max_values_ > 25) {
            return false;
        }
        
        if (min_values_ > max_values_) {
            return false;
        }
        
        if (default_values_.size() > static_cast<size_t>(max_values_)) {
            return false;
        }
        
        return true;
    }

    std::unique_ptr<IComponent> ChannelSelect::clone() const {
        return std::make_unique<ChannelSelect>(custom_id_, channel_types_, placeholder_,
                                            min_values_, max_values_, disabled_);
    }

    void ChannelSelect::add_channel_type(const std::string& type) {
        channel_types_.push_back(type);
    }

    void ChannelSelect::remove_channel_type(const std::string& type) {
        auto it = std::find(channel_types_.begin(), channel_types_.end(), type);
        if (it != channel_types_.end()) {
            channel_types_.erase(it);
        }
    }

    void ChannelSelect::clear_channel_types() {
        channel_types_.clear();
    }

    std::unique_ptr<ChannelSelect> ChannelSelect::create(const std::string& custom_id,
                                                    const std::vector<std::string>& channel_types,
                                                    const std::string& placeholder,
                                                    int min_values,
                                                    int max_values) {
        return std::make_unique<ChannelSelect>(custom_id, channel_types, placeholder, min_values, max_values);
    }

    MentionableSelect::MentionableSelect(const std::string& custom_id,
                                       const std::string& placeholder,
                                       int min_values,
                                       int max_values,
                                       bool disabled)
        : SelectMenu(custom_id, placeholder, min_values, max_values, disabled) {}

    nlohmann::json MentionableSelect::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::MENTIONABLE_SELECT);
        json["custom_id"] = custom_id_;
        
        if (!placeholder_.empty()) {
            json["placeholder"] = placeholder_;
        }
        
        json["min_values"] = min_values_;
        json["max_values"] = max_values_;
        
        if (!default_values_.empty()) {
            json["default_values"] = default_values_;
        }
        
        if (disabled_) {
            json["disabled"] = true;
        }
        
        return json;
    }

    bool MentionableSelect::validate() const {
        if (custom_id_.empty() || custom_id_.length() > 100) {
            return false;
        }
        
        if (min_values_ < 0 || min_values_ > 25) {
            return false;
        }
        
        if (max_values_ < 1 || max_values_ > 25) {
            return false;
        }
        
        if (min_values_ > max_values_) {
            return false;
        }
        
        if (default_values_.size() > static_cast<size_t>(max_values_)) {
            return false;
        }
        
        return true;
    }

    std::unique_ptr<IComponent> MentionableSelect::clone() const {
        return std::make_unique<MentionableSelect>(custom_id_, placeholder_,
                                                 min_values_, max_values_, disabled_);
    }

    std::unique_ptr<MentionableSelect> MentionableSelect::create(const std::string& custom_id,
                                                            const std::string& placeholder,
                                                            int min_values,
                                                            int max_values) {
        return std::make_unique<MentionableSelect>(custom_id, placeholder, min_values, max_values);
    }

} // namespace discord::components
=== END FILE ===

=== FILE: src/components/action_row.cpp ===
#include "../include/discord/components/action_row.h"
#include "../include/discord/components/button.h"
#include "../include/discord/components/select_menu.h"
#include "../include/discord/components/text_input.h"
#include "../include/discord/utils/types.h"
#include <algorithm>
#include <stdexcept>

namespace discord::components {

    ActionRow::ActionRow(const std::vector<std::shared_ptr<IComponent>>& components)
        : ContainerComponent(components) {
        validate_component_constraints();
    }

    void ActionRow::validate_component_constraints() {
        if (components_.size() > 5) {
            throw std::invalid_argument("ActionRow cannot contain more than 5 components");
        }

        // Check if this is a button-only row
        if (is_button_only()) {
            for (const auto& component : components_) {
                if (component->get_type() != ComponentType::BUTTON) {
                    throw std::invalid_argument("ActionRow with buttons can only contain button components");
                }
            }
        }
    }

    nlohmann::json ActionRow::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(ComponentType::ACTION_ROW);
        
        nlohmann::json components_array = nlohmann::json::array();
        for (const auto& component : components_) {
            if (component) {
                components_array.push_back(component->to_json());
            }
        }
        json["components"] = components_array;
        
        return json;
    }

    bool ActionRow::validate() const {
        if (components_.size() > 5) {
            return false;
        }

        // Validate each component
        for (const auto& component : components_) {
            if (!component || !component->validate()) {
                return false;
            }
        }

        // Check button-only constraint
        if (is_button_only()) {
            return std::all_of(components_.begin(), components_.end(),
                [](const std::shared_ptr<IComponent>& comp) {
                    return comp && comp->get_type() == ComponentType::BUTTON;
                });
        }

        return true;
    }

    std::unique_ptr<IComponent> ActionRow::clone() const {
        std::vector<std::shared_ptr<IComponent>> cloned_components;
        cloned_components.reserve(components_.size());
        
        for (const auto& component : components_) {
            if (component) {
                cloned_components.push_back(std::shared_ptr<IComponent>(component->clone().release()));
            }
        }
        
        return std::make_unique<ActionRow>(cloned_components);
    }

    bool ActionRow::can_add_component(std::shared_ptr<IComponent> component) const {
        if (!component || components_.size() >= 5) {
            return false;
        }

        // If this is a button-only row, only allow buttons
        if (is_button_only()) {
            return component->get_type() == ComponentType::BUTTON;
        }

        // If row already has buttons, only allow buttons
        bool has_buttons = std::any_of(components_.begin(), components_.end(),
            [](const std::shared_ptr<IComponent>& comp) {
                return comp && comp->get_type() == ComponentType::BUTTON;
            });

        if (has_buttons) {
            return component->get_type() == ComponentType::BUTTON;
        }

        return true;
    }

    bool ActionRow::is_button_only() const {
        return std::any_of(components_.begin(), components_.end(),
            [](const std::shared_ptr<IComponent>& comp) {
                return comp && comp->get_type() == ComponentType::BUTTON;
            });
    }

    std::unique_ptr<ActionRow> ActionRow::create(const std::vector<std::shared_ptr<IComponent>>& components) {
        return std::make_unique<ActionRow>(components);
    }

    std::unique_ptr<ActionRow> ActionRow::with_buttons(const std::vector<std::shared_ptr<Button>>& buttons) {
        std::vector<std::shared_ptr<IComponent>> components;
        components.reserve(buttons.size());
        
        for (const auto& button : buttons) {
            if (button) {
                components.push_back(std::static_pointer_cast<IComponent>(button));
            }
        }
        
        return std::make_unique<ActionRow>(components);
    }

    std::unique_ptr<ActionRow> ActionRow::with_selects(const std::vector<std::shared_ptr<SelectMenu>>& selects) {
        std::vector<std::shared_ptr<IComponent>> components;
        components.reserve(selects.size());
        
        for (const auto& select : selects) {
            if (select) {
                components.push_back(std::static_pointer_cast<IComponent>(select));
            }
        }
        
        return std::make_unique<ActionRow>(components);
    }

    std::unique_ptr<ActionRow> ActionRow::with_text_inputs(const std::vector<std::shared_ptr<TextInput>>& text_inputs) {
        std::vector<std::shared_ptr<IComponent>> components;
        components.reserve(text_inputs.size());
        
        for (const auto& text_input : text_inputs) {
            if (text_input) {
                components.push_back(std::static_pointer_cast<IComponent>(text_input));
            }
        }
        
        return std::make_unique<ActionRow>(components);
    }

} // namespace discord::components
=== END FILE ===

=== FILE: src/components/button.cpp ===
/**
 * @file button.cpp
 * @brief Button component implementation
 */

#include "../../include/discord/components/button.h"
#include <stdexcept>
#include <memory>
#include <nlohmann/json.hpp>

namespace discord::components {

    discord::components::Button::Button(const std::string& label,
                   discord::components::ButtonStyle style,
                   const std::string& custom_id,
                   const std::optional<std::string>& emoji,
                   bool disabled)
        : InteractiveComponent(custom_id, disabled),
          style_(style),
          label_(label),
          emoji_(emoji) {
        
        if (label_.empty()) {
            throw std::invalid_argument("Button label cannot be empty");
        }
        
        if (label_.length() > 80) {
            throw std::invalid_argument("Button label cannot exceed 80 characters");
        }
        
        if (style_ == discord::components::ButtonStyle::LINK && custom_id_.empty() && !url_.has_value()) {
            throw std::invalid_argument("Link buttons must have a URL");
        }
        
        if (style_ != discord::components::ButtonStyle::LINK && !custom_id_.empty()) {
            throw std::invalid_argument("Non-link buttons must have a custom_id");
        }
    }

    discord::components::Button::Button(const std::string& label,
                   const std::string& url,
                   const std::optional<std::string>& emoji,
                   bool disabled)
        : InteractiveComponent("", disabled),
          style_(discord::components::ButtonStyle::LINK),
          label_(label),
          url_(url),
          emoji_(emoji) {
        
        if (label_.empty()) {
            throw std::invalid_argument("Button label cannot be empty");
        }
        
        if (label_.length() > 80) {
            throw std::invalid_argument("Button label cannot exceed 80 characters");
        }
        
        if (url_.value_or("").empty()) {
            throw std::invalid_argument("Link button URL cannot be empty");
        }
    }

    nlohmann::json discord::components::Button::to_json() const {
        nlohmann::json json;
        json["type"] = static_cast<int>(discord::components::ComponentType::BUTTON);
        json["style"] = static_cast<int>(style_);
        json["label"] = label_;
        
        if (style_ != discord::components::ButtonStyle::LINK) {
            json["custom_id"] = custom_id_;
        } else {
            json["url"] = url_.value();
        }
        
        if (emoji_.has_value()) {
            json["emoji"] = {{"name", emoji_.value()}};
        }
        
        if (disabled_) {
            json["disabled"] = true;
        }
        
        return json;
    }

    bool discord::components::Button::validate() const {
        if (label_.empty() || label_.length() > 80) {
            return false;
        }
        
        if (style_ == discord::components::ButtonStyle::LINK) {
            return url_.has_value() && !url_.value().empty();
        } else {
            return !custom_id_.empty() && custom_id_.length() <= 100;
        }
    }

    std::unique_ptr<discord::components::IComponent> discord::components::Button::clone() const {
        if (style_ == discord::components::ButtonStyle::LINK) {
            return std::make_unique<Button>(label_, url_.value(), emoji_, disabled_);
        } else {
            return std::make_unique<Button>(label_, style_, custom_id_, emoji_, disabled_);
        }
    }

    // Static factory methods
    std::unique_ptr<discord::components::Button> discord::components::Button::primary(const std::string& label,
                                            const std::string& custom_id,
                                            const std::optional<std::string>& emoji) {
        return std::make_unique<Button>(label, discord::components::ButtonStyle::PRIMARY, custom_id, emoji);
    }

    std::unique_ptr<discord::components::Button> discord::components::Button::secondary(const std::string& label,
                                              const std::string& custom_id,
                                              const std::optional<std::string>& emoji) {
        return std::make_unique<Button>(label, discord::components::ButtonStyle::SECONDARY, custom_id, emoji);
    }

    std::unique_ptr<discord::components::Button> discord::components::Button::success(const std::string& label,
                                            const std::string& custom_id,
                                            const std::optional<std::string>& emoji) {
        return std::make_unique<Button>(label, discord::components::ButtonStyle::SUCCESS, custom_id, emoji);
    }

    std::unique_ptr<discord::components::Button> discord::components::Button::danger(const std::string& label,
                                           const std::string& custom_id,
                                           const std::optional<std::string>& emoji) {
        return std::make_unique<Button>(label, discord::components::ButtonStyle::DANGER, custom_id, emoji);
    }

    std::unique_ptr<discord::components::Button> discord::components::Button::link(const std::string& label,
                                         const std::string& url,
                                         const std::optional<std::string>& emoji) {
        return std::make_unique<Button>(label, url, emoji);
    }

    std::unique_ptr<discord::components::Button> discord::components::Button::premium(const std::string& label,
                                           const std::string& sku_id,
                                           const std::optional<std::string>& emoji) {
        // Premium buttons would require SKU integration
        // For now, return a primary button with SKU info in custom_id
        return std::make_unique<Button>(label, discord::components::ButtonStyle::PREMIUM, sku_id, emoji);
    }

} // namespace discord::components
=== END FILE ===

